## Copyright (C) 2003-2012, 2014-2023 Free Software Foundation, Inc.
## Written by Keisuke Nishida, Roger While, Simon Sobisch, Ron Norman,
## Brian Tiffin, Joe Robbins, Edward Hart
##
## This file is part of GnuCOBOL.
##
## The GnuCOBOL compiler is free software: you can redistribute it
## and/or modify it under the terms of the GNU General Public License
## as published by the Free Software Foundation, either version 3 of the
## License, or (at your option) any later version.
##
## GnuCOBOL is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with GnuCOBOL.  If not, see <https://www.gnu.org/licenses/>.

### GnuCOBOL Test Suite


AT_SETUP([OPEN EXTEND and CLOSE, SEQUENTIAL])
AT_KEYWORDS([runfile empty CLOSE OPTIONAL WRITE READ])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT  OPTIONAL      FILE-OPT
                   ASSIGN        TO "testfile"
                   ORGANIZATION  IS SEQUENTIAL
                   FILE STATUS   IS WSFS.
           SELECT  FILE0         ASSIGN TO "testfile"
                   ORGANIZATION  IS SEQUENTIAL
                   FILE STATUS   IS WSFS.
       DATA DIVISION.
       FILE SECTION.
       FD  FILE0.
       01  F0REC             PIC X(80).
       FD  FILE-OPT.
       01  FOREC             PIC X(80).
       WORKING-STORAGE SECTION.
       01  WSFS              PIC X(2).
       PROCEDURE DIVISION.
      *
           OPEN EXTEND FILE-OPT
           IF WSFS NOT = "05"
              DISPLAY "STATUS EXTEND, missing optional file:" WSFS.
           MOVE ALL "A" TO FOREC
           WRITE FOREC
           IF WSFS NOT = "00"
              DISPLAY "STATUS WRITE A:" WSFS.
           CLOSE FILE-OPT
           IF WSFS NOT = "00"
              DISPLAY "STATUS CLOSE:" WSFS.
           OPEN EXTEND FILE0
           IF WSFS NOT = "00"
              DISPLAY "STATUS EXTEND, empty file:" WSFS.
           MOVE ALL "B" TO F0REC
           WRITE F0REC
           IF WSFS NOT = "00"
              DISPLAY "STATUS WRITE B:" WSFS.
           CLOSE FILE0
      *
           OPEN INPUT FILE-OPT
           IF WSFS NOT = "00"
              DISPLAY "STATUS INPUT:" WSFS.
           READ FILE-OPT NEXT
           IF WSFS NOT = "00"
              DISPLAY "STATUS READ A:" WSFS.
           READ FILE-OPT NEXT
           IF WSFS NOT = "00"
              DISPLAY "STATUS READ B:" WSFS.
           CLOSE FILE-OPT
      *
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([variable-length SEQUENTIAL data integrity])
AT_KEYWORDS([runfile record OPEN])

# LINE SEQUENTIAL testfile, read as variable RECORD 
AT_DATA([TEST1], [<?xml version="1.0" encoding="ISO-8859-1"?>
<SampleTag Test="v0.1" Date="2022-02-16" Heure="10:56:11">
    <ListeAccuse>
        <Accuse Type="type1" tag1="123" tag2="456" tag3="789"/>
        <Accuse Type="type1" tag1="123" tag2="456" tag3="789"/>
        <Accuse Type="type1" tag1="123" tag2="456" tag3="789"/>
        <Accuse Type="type2" tag1="123" tag2="456" tag3="789"/>
        <Accuse Type="type2" tag1="123" tag2="456" tag3="789"/>
        <Accuse Type="type2" tag1="123" tag2="456" tag3="789"/>
        <Accuse Type="type2" tag1="123" tag2="456" tag3="789"/>
        <Accuse Type="type2" tag1="123" tag2="456" tag3="789"/>
    </ListeAccuse>
</SampleTag>
])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
          SELECT TEST-XML00 ASSIGN TO 'DATA' FILE STATUS ST-TEST.
       DATA DIVISION.
       FILE SECTION.
       FD TEST-XML00 RECORD VARYING FROM 5 TO 500 CHARACTERS.
       01 E-ENR                          PIC X(500).
       WORKING-STORAGE SECTION.
       01 ST-TEST  PIC X(2).
       01 W-TYPE   PIC 9(03) VALUE ZERO.
       01 EOF-TEST-XML   PIC 9(03) VALUE ZERO.
       01 COUNT-PASS   PIC 9(02) VALUE ZERO.
       PROCEDURE DIVISION.
       DEBUT.
           OPEN INPUT  TEST-XML00
           IF ST-TEST (1:) NOT = "00"
              DISPLAY "OPEN ERROR: " ST-TEST WITH NO ADVANCING
              GOBACK.
           INITIALIZE W-TYPE E-ENR
           PERFORM UNTIL (EOF-TEST-XML = 1 OR (W-TYPE = 1 OR 2))
               READ TEST-XML00 NEXT
                   AT END
                       MOVE 1 TO EOF-TEST-XML
                   NOT AT END
                   ADD 1 TO COUNT-PASS
               END-READ
           END-PERFORM
           CLOSE TEST-XML00
           DISPLAY COUNT-PASS
       STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([DD_DATA=TEST1 $COBCRUN_DIRECT ./prog], [0],
[OPEN ERROR: 39], [])

# TODO: add testcase that has a valid length first to check for later
#       status 04 on read - both with "record too long" and "record too small"

AT_CLEANUP


AT_SETUP([DELETE FILE, SEQUENTIAL])
AT_KEYWORDS([runfile FILE OPEN I-O OPTIONAL])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT  OPTIONAL      FILE-OPT
                   ASSIGN        TO "testfile"
                   ORGANIZATION  IS SEQUENTIAL
                   FILE STATUS   IS WSFS.
       DATA DIVISION.
       FILE SECTION.
       FD  FILE-OPT.
       01  FOREC             PIC X(80).
       WORKING-STORAGE SECTION.
       01  WSFS              PIC X(2).
       PROCEDURE DIVISION.
      *
      *>   DELETE FILE FILE-OPT
      *>    ON EXCEPTION
      *>     DISPLAY "STATUS DELETE FILE (missing) - EXCEPTION:" WSFS
      *>     END-DISPLAY
      *>    NOT ON EXCEPTION
      *>      IF WSFS NOT = "05"
      *>         DISPLAY "STATUS DELETE FILE (missing):" WSFS
      *>      END-IF
      *>   END-DELETE
           OPEN I-O FILE-OPT
           IF WSFS NOT = "05"
              DISPLAY "STATUS I-O, missing optional file:" WSFS.
           CLOSE FILE-OPT
           IF WSFS NOT = "00"
              DISPLAY "STATUS CLOSE:" WSFS.
           OPEN I-O FILE-OPT
           IF WSFS NOT = "00"
              DISPLAY "STATUS I-O, empty file:" WSFS.
           DELETE FILE FILE-OPT
      *>     ON EXCEPTION
              IF WSFS NOT = "41"
                 DISPLAY "STATUS DELETE FILE (OPENED):" WSFS
              END-IF
      *>    NOT ON EXCEPTION
      *>     DISPLAY "STATUS DELETE FILE (OPENED) - NO EXCEPTION:" WSFS
      *>   END-DELETE
           CLOSE FILE-OPT
           IF WSFS NOT = "00"
              DISPLAY "STATUS CLOSE #2:" WSFS.
           DELETE FILE FILE-OPT
      *>     ON EXCEPTION
      *>      DISPLAY "STATUS DELETE FILE (closed) - EXCEPTION:" WSFS
      *>      END-DISPLAY
      *>     NOT ON EXCEPTION
              IF WSFS NOT = "00"
                 DISPLAY "STATUS DELETE FILE (closed):" WSFS
              END-IF
      *>   END-DELETE
      *
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([OUTPUT on SEQUENTIAL file to missing directory])
AT_KEYWORDS([runfile OPEN ASSIGN])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT  FILE0 ASSIGN  TO "./nosubhere/MYFILE0"
                   ORGANIZATION  IS SEQUENTIAL
                   FILE STATUS   IS WSFS.
       DATA DIVISION.
       FILE SECTION.
       FD  FILE0.
       01  F0REC             PIC X(80).
       WORKING-STORAGE SECTION.
       01  WSFS              PIC X(2).
       PROCEDURE DIVISION.
      *
           OPEN OUTPUT FILE0
           IF WSFS NOT = "30"
              DISPLAY "STATUS OPENO " WSFS.
      *
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_DATA([nosubhere], [Test
])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([OPEN EXTEND and CLOSE, INDEXED])
AT_KEYWORDS([runfile empty CLOSE OPTIONAL WRITE READ])

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT  OPTIONAL      FILE-OPT
                   ASSIGN        TO "testfile"
                   ORGANIZATION  IS INDEXED
                   RECORD KEY    IS FOREC
                   FILE STATUS   IS WSFS.
           SELECT  FILE0         ASSIGN TO "testfile"
                   ORGANIZATION  IS INDEXED
                   RECORD KEY    IS F0REC
                   FILE STATUS   IS WSFS.
       DATA DIVISION.
       FILE SECTION.
       FD  FILE0.
       01  F0REC             PIC X(80).
       FD  FILE-OPT.
       01  FOREC             PIC X(80).
       WORKING-STORAGE SECTION.
       01  WSFS              PIC X(2).
       PROCEDURE DIVISION.
      *
           OPEN EXTEND FILE-OPT
           IF WSFS NOT = "05"
              DISPLAY "STATUS EXTEND, missing optional file:" WSFS.
           MOVE ALL "A" TO FOREC
           WRITE FOREC
           IF WSFS NOT = "00"
              DISPLAY "STATUS WRITE A:" WSFS.
           CLOSE FILE-OPT
           IF WSFS NOT = "00"
              DISPLAY "STATUS CLOSE:" WSFS.
           OPEN EXTEND FILE0
           IF WSFS NOT = "00"
              DISPLAY "STATUS EXTEND, empty file:" WSFS.
           MOVE ALL "B" TO F0REC
           WRITE F0REC
           IF WSFS NOT = "00"
              DISPLAY "STATUS WRITE B:" WSFS.
           CLOSE FILE0
      *
           OPEN INPUT FILE-OPT
           IF WSFS NOT = "00"
              DISPLAY "STATUS INPUT:" WSFS.
           MOVE ALL "A" TO FOREC
           READ FILE-OPT
           IF WSFS NOT = "00"
              DISPLAY "STATUS READ A:" WSFS.
           MOVE ALL "B" TO FOREC
           READ FILE-OPT
           IF WSFS NOT = "00"
              DISPLAY "STATUS READ B:" WSFS.
           CLOSE FILE-OPT
      *
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([DELETE FILE, INDEXED])
AT_KEYWORDS([runfile FILE OPEN I-O OPTIONAL])

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT  OPTIONAL      FILE-OPT
                   ASSIGN        TO "testfile"
                   ORGANIZATION  IS INDEXED
                   RECORD KEY    IS FOREC
                   FILE STATUS   IS WSFS.
       DATA DIVISION.
       FILE SECTION.
       FD  FILE-OPT.
       01  FOREC             PIC X(80).
       WORKING-STORAGE SECTION.
       01  WSFS              PIC X(2).
       PROCEDURE DIVISION.
      *
      *>   DELETE FILE FILE-OPT
      *>    ON EXCEPTION
      *>     DISPLAY "STATUS DELETE FILE (missing) - EXCEPTION: " WSFS
      *>     END-DISPLAY
      *>    NOT ON EXCEPTION
      *>      IF WSFS NOT = "05"
      *>         DISPLAY "STATUS DELETE FILE (missing): " WSFS
      *>      END-IF
      *>   END-DELETE
           OPEN I-O FILE-OPT
           IF WSFS NOT = "05"
              DISPLAY "STATUS I-O, missing optional file: " WSFS.
           CLOSE FILE-OPT
           IF WSFS NOT = "00"
              DISPLAY "STATUS CLOSE: " WSFS.
           OPEN I-O FILE-OPT
           IF WSFS NOT = "00"
              DISPLAY "STATUS I-O, empty file: " WSFS.
           DELETE FILE FILE-OPT
      *>     ON EXCEPTION
              IF WSFS NOT = "41"
                 DISPLAY "STATUS DELETE FILE (opened): " WSFS
              END-IF
      *>    NOT ON EXCEPTION
      *>     DISPLAY "STATUS DELETE FILE (opened) - NO EXCEPTION: " WSFS
      *>   END-DELETE
           CLOSE FILE-OPT
           IF WSFS NOT = "00"
              DISPLAY "STATUS CLOSE #2: " WSFS.
           DELETE FILE FILE-OPT
      *>     ON EXCEPTION
      *>      DISPLAY "STATUS DELETE FILE (closed) - EXCEPTION: " WSFS
      *>      END-DISPLAY
      *>     NOT ON EXCEPTION
              IF WSFS NOT = "00"
                 DISPLAY "STATUS DELETE FILE (closed): " WSFS
              END-IF
      *>   END-DELETE
      *
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([OUTPUT on INDEXED file to missing directory])
AT_KEYWORDS([runfile OPEN ASSIGN])

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT  FILE0 ASSIGN  TO "./nosubhere/MYFILE0"
                   ORGANIZATION  IS INDEXED
                   RECORD KEY    IS F0REC
                   FILE STATUS   IS WSFS.
       DATA DIVISION.
       FILE SECTION.
       FD  FILE0.
       01  F0REC             PIC X(80).
       WORKING-STORAGE SECTION.
       01  WSFS              PIC X(2).
       PROCEDURE DIVISION.
      *
           OPEN OUTPUT FILE0
           IF WSFS NOT = "30"
              DISPLAY "STATUS OPENO " WSFS.
      *
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_DATA([nosubhere], [Test
])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([READ INTO data item AT-END sequence])
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT TEST-FILE ASSIGN "./TEST-FILE".
       DATA             DIVISION.
       FILE             SECTION.
       FD  TEST-FILE.
       01  TEST-REC     PIC X(10).
       WORKING-STORAGE  SECTION.
       01  X            PIC X(10).
       PROCEDURE        DIVISION.
           OPEN  OUTPUT TEST-FILE.
           CLOSE TEST-FILE.
           OPEN  INPUT  TEST-FILE.
           READ  TEST-FILE INTO X
               AT END MOVE ALL ZERO TO X
           END-READ.
           CLOSE TEST-FILE.
           IF X NOT = "0000000000"
              DISPLAY "Expected zeros - Got " X
              END-DISPLAY
           END-IF.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([First READ on empty SEQUENTIAL INDEXED file])
AT_KEYWORDS([runfile])

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT TEST-FILE ASSIGN       "./TEST-FILE"
                        ORGANIZATION IS  INDEXED
                        ACCESS MODE  IS  SEQUENTIAL
                        RECORD KEY   IS  TEST-KEY.
       DATA             DIVISION.
       FILE             SECTION.
       FD TEST-FILE.
       01 TEST-KEY      PIC X(10).
       PROCEDURE        DIVISION.
           OPEN  OUTPUT TEST-FILE.
           CLOSE TEST-FILE.
           OPEN  INPUT  TEST-FILE.
           READ  TEST-FILE
                 AT END
                   CONTINUE
                 NOT AT END
                   DISPLAY "NOT OK"
                   END-DISPLAY
           END-READ.
           CLOSE TEST-FILE.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([READ NEXT without previous START])
AT_KEYWORDS([runfile WRITE indexed])

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT TEST-FILE ASSIGN       "./TEST-FILE"
                        ORGANIZATION IS  INDEXED
                        ACCESS MODE  IS  SEQUENTIAL
                        RECORD KEY   IS  TEST-KEY.
       DATA             DIVISION.
       FILE             SECTION.
       FD TEST-FILE.
       01 TEST-REC.
          05 TEST-KEY      PIC X(10).
          05 TEST-DATA     PIC X.
       PROCEDURE        DIVISION.
           OPEN  OUTPUT TEST-FILE
           MOVE  '1'    TO TEST-KEY
           MOVE  'A'    TO TEST-DATA
           WRITE TEST-REC
           MOVE  '3'    TO TEST-KEY
           MOVE  'B'    TO TEST-DATA
           WRITE TEST-REC
           CLOSE TEST-FILE
           OPEN  INPUT  TEST-FILE
           READ  TEST-FILE NEXT
                 AT END
                   DISPLAY "AT END FOR REC1"
                   END-DISPLAY
                   CLOSE TEST-FILE
                   STOP RUN
                 NOT AT END
                   CONTINUE
           END-READ
           IF TEST-DATA NOT = 'A'
              DISPLAY "WRONG REC1: '" TEST-REC "'"
              END-DISPLAY
           END-IF
           READ  TEST-FILE NEXT
                 AT END
                   DISPLAY "AT END FOR REC2"
                   END-DISPLAY
                   CLOSE TEST-FILE
                   STOP RUN
                 NOT AT END
                   CONTINUE
           END-READ.
           IF TEST-DATA NOT = 'B'
              DISPLAY "WRONG REC2: '" TEST-REC "'"
              END-DISPLAY
           END-IF
           READ  TEST-FILE NEXT
                 AT END
                   CONTINUE
                 NOT AT END
                   DISPLAY "NOT AT END AFTER REC2"
                   END-DISPLAY
           END-READ
           IF TEST-DATA NOT = 'B'
              DISPLAY "DATE CHANGED ON EOF: '" TEST-REC "'"
              END-DISPLAY
           END-IF
           CLOSE TEST-FILE
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([REWRITE a RELATIVE file with RANDOM access])
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT TEST-FILE ASSIGN       "./TEST-FILE"
                        ORGANIZATION IS RELATIVE
                        ACCESS MODE  IS RANDOM
                        RELATIVE KEY IS TEST-KEY.
       DATA             DIVISION.
       FILE             SECTION.
       FD TEST-FILE.
       01 TEST-REC      PIC X.
       WORKING-STORAGE  SECTION.
       01 TEST-KEY      PIC 9.
       PROCEDURE        DIVISION.
      *
           OPEN OUTPUT TEST-FILE.
           MOVE 1 TO TEST-KEY.
           MOVE "A" TO TEST-REC.
           WRITE TEST-REC
           END-WRITE.
           MOVE 2 TO TEST-KEY.
           MOVE "B" TO TEST-REC.
           WRITE TEST-REC
           END-WRITE.
           CLOSE TEST-FILE.
      *
           OPEN I-O TEST-FILE.
           MOVE 1 TO TEST-KEY.
           READ TEST-FILE
           END-READ.
           MOVE 2 TO TEST-KEY.
           MOVE "C" TO TEST-REC.
           REWRITE TEST-REC
           END-REWRITE.
           CLOSE TEST-FILE.
      *
           OPEN INPUT TEST-FILE.
           MOVE 1 TO TEST-KEY.
           READ TEST-FILE
           END-READ.
           IF TEST-REC NOT = "A"
              DISPLAY "Expected 'A' - Got " TEST-REC
              END-DISPLAY
           END-IF.
           MOVE 2 TO TEST-KEY.
           READ TEST-FILE
           END-READ.
           IF TEST-REC NOT = "C"
              DISPLAY "Expected 'C' - Got " TEST-REC
              END-DISPLAY
           END-IF.
           CLOSE TEST-FILE.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


## ASSIGN


AT_SETUP([ASSIGN DYNAMIC and EXTERNAL])
AT_KEYWORDS([extensions runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.

       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT f ASSIGN whatever
               ORGANIZATION LINE SEQUENTIAL.

       DATA DIVISION.
       FILE SECTION.
       FD  f.
       01  f-rec PIC XXX.

       WORKING-STORAGE SECTION.
       01  whatever PIC X(10) VALUE "out.txt".

       PROCEDURE DIVISION.
           OPEN OUTPUT f
           WRITE f-rec FROM "hi"
           CLOSE f
           .
])

AT_CHECK([$COMPILE -fassign-clause=external prog.cob], [0], [], [])
AT_CAPTURE_FILE([whatever])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_DATA([reference],
[hi
])
AT_CHECK([diff reference whatever], [0], [], [])

AT_CHECK([$COMPILE -fassign-clause=dynamic -fno-implicit-assign-dynamic-var prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([diff reference whatever], [0], [], [])

AT_CHECK([$COMPILE -fassign-clause=dynamic prog.cob], [0], [], [])
AT_CAPTURE_FILE([out.txt])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([diff reference out.txt], [0], [], [])

AT_CLEANUP


AT_SETUP([ASSIGN EXTERNAL parsing])
AT_KEYWORDS([extensions runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
           *> Labels should be removed from EXTERNAL name.
           SELECT TEST-FILE   ASSIGN DA-S-FILENAME.
           *> EXTERNAL name allowed to duplicate FD name.
           SELECT TESTFILE2 ASSIGN TESTFILE2.
       DATA             DIVISION.
       FILE             SECTION.
       FD TEST-FILE.
       01 TEST-REC      PIC X(4).
       FD TESTFILE2.
       01 TESTREC2      PIC X(4).
       PROCEDURE        DIVISION.
           OPEN OUTPUT TEST-FILE.
           CLOSE TEST-FILE.
           STOP RUN.
])

AT_CHECK([$COMPILE -fassign-clause=external prog.cob], [0], [],
[prog.cob:8: warning: ASSIGN DA-S-FILENAME interpreted as 'FILENAME'
])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([test -f FILENAME], [0], [], [])

AT_CLEANUP


AT_SETUP([ASSIGN directive])
AT_KEYWORDS([extensions runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.

       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT f ASSIGN whatever
               ORGANIZATION LINE SEQUENTIAL.
      $SET ASSIGN "EXTERNAL"
           SELECT g ASSIGN whatever
               ORGANIZATION LINE SEQUENTIAL.

       DATA DIVISION.
       FILE SECTION.
       FD  f.
       01  f-rec PIC XXX.
       FD  g.
       01  g-rec PIC XXX.

       PROCEDURE DIVISION.
           MOVE "out.txt" TO whatever

           OPEN OUTPUT f
           WRITE f-rec FROM "hi"
           CLOSE f

           OPEN OUTPUT g
           WRITE g-rec FROM "hi"
           CLOSE g
           .
       END PROGRAM prog.
])

AT_CHECK([$COMPILE -fassign-clause=dynamic prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([ASSIGN filename expansion])
AT_KEYWORDS([extensions runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT TEST-FILE ASSIGN "$DIR/FILENAME".
       DATA             DIVISION.
       FILE             SECTION.
       FD TEST-FILE.
       01 TEST-REC      PIC X(4).
       PROCEDURE        DIVISION.
           OPEN OUTPUT TEST-FILE.
           CLOSE TEST-FILE.
           STOP RUN.
])

AT_CHECK([$COMPILE -ffilename-mapping prog.cob], [0], [], [])
AT_CHECK([DIR="." $COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([test -f "./FILENAME" && rm -f "./FILENAME"], [0], [], [])

AT_CLEANUP


AT_SETUP([ASSIGN filename mapping])
AT_KEYWORDS([extensions runfile optional])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT TEST-FILE ASSIGN "FILENAME".
       DATA             DIVISION.
       FILE             SECTION.
       FD TEST-FILE.
       01 TEST-REC      PIC X(4).
       PROCEDURE        DIVISION.
           OPEN OUTPUT TEST-FILE.
           CLOSE TEST-FILE.
           STOP RUN.
])

AT_DATA([prog2.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog2.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT TEST-FILE ASSIGN "FILENAME2".
       DATA             DIVISION.
       FILE             SECTION.
       FD TEST-FILE.
       01 TEST-REC      PIC X(4).
       PROCEDURE        DIVISION.
           OPEN OUTPUT TEST-FILE.
           CLOSE TEST-FILE.
           STOP RUN.
])

AT_CHECK([$COMPILE -fno-filename-mapping prog.cob], [0], [], [])
AT_CHECK([DD_FILENAME="x" $COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([test -f "x"], [1])
AT_CHECK([test -f "FILENAME"], [0], [], [])

AT_CHECK([$COMPILE -ffilename-mapping prog2.cob], [0], [], [])
AT_CHECK([DD_FILENAME2="x" $COBCRUN_DIRECT ./prog2], [0], [], [])
AT_CHECK([test -f "FILENAME2"], [1])
AT_CHECK([test -f "x"], [0], [], [])
AT_CHECK([dd_FILENAME2="y" $COBCRUN_DIRECT ./prog2], [0], [], [])
AT_CHECK([test -f "y"], [0], [], [])
AT_CHECK([FILENAME2="z" $COBCRUN_DIRECT ./prog2], [0], [], [])
AT_CHECK([test -f "z"], [0], [], [])
AT_CHECK([FILENAME2="\"QUOTE\"" $COBCRUN_DIRECT ./prog2], [0], [], [])
AT_CHECK([test -f "QUOTE"], [0], [], [])
AT_CHECK([FILENAME2=\'APOST\' $COBCRUN_DIRECT ./prog2], [0], [], [])
AT_CHECK([test -f "APOST"], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog2], [0], [], [])
AT_CHECK([test -f "FILENAME2"], [0], [], [])

AT_DATA([prog3.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog3.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT OPTIONAL INFILE ASSIGN TO "MYFILE"
                ORGANIZATION IS RELATIVE
                ACCESS IS SEQUENTIAL
                FILE STATUS IS WSFS.
       DATA DIVISION.
       FILE SECTION.
       FD  INFILE.
       01  INREC             PIC X(80).
       WORKING-STORAGE SECTION.
       01  WSFS              PIC X(2).
       PROCEDURE DIVISION.
      *
      *    open missing file
           OPEN INPUT INFILE
           DISPLAY "STATUS OPENI " WSFS
           CLOSE INFILE
      *
      *    create missing file
           OPEN OUTPUT INFILE
           DISPLAY "STATUS OPENO " WSFS
           CLOSE INFILE
      *
           STOP RUN.
])

AT_CHECK([$COMPILE prog3.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog3], [0],
[STATUS OPENI 05
STATUS OPENO 00
], [])
AT_CHECK([test -f "MYFILE"], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog3], [0],
[STATUS OPENI 00
STATUS OPENO 00
], [])

AT_CHECK([MYFILE="TSTFILE" $COBCRUN_DIRECT ./prog3], [0],
[STATUS OPENI 05
STATUS OPENO 00
], [])
AT_CHECK([test -f "TSTFILE"], [0], [], [])

AT_CHECK([dd_MYFILE="TSTFILE2" $COBCRUN_DIRECT ./prog3], [0],
[STATUS OPENI 05
STATUS OPENO 00
], [])
AT_CHECK([test -f "TSTFILE2"], [0], [], [])

AT_CHECK([DD_MYFILE="TSTFILE3" $COBCRUN_DIRECT ./prog3], [0],
[STATUS OPENI 05
STATUS OPENO 00
], [])
AT_CHECK([test -f "TSTFILE3"], [0], [], [])

AT_CHECK([DD_MYFILE="./nosubhere/TSTFILE" $COBCRUN_DIRECT ./prog3], [0],
[STATUS OPENI 05
STATUS OPENO 30
], [])

AT_DATA([prog4.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog4.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT  FILE0 ASSIGN  TO "./nosubhere/MYFILE0"
                   ORGANIZATION  IS LINE SEQUENTIAL
                   FILE STATUS   IS WSFS.
           SELECT  FILE1 ASSIGN  TO "MYFILE1"
                   ORGANIZATION  IS LINE SEQUENTIAL
                   FILE STATUS   IS WSFS.
           SELECT  FILE2 ASSIGN  TO FILENAME
                   ORGANIZATION  IS LINE SEQUENTIAL
                   FILE STATUS   IS WSFS.
       DATA DIVISION.
       FILE SECTION.
       FD  FILE0.
       01  F0REC             PIC X(80).
       FD  FILE1.
       01  F1REC             PIC X(80).
       FD  FILE2.
       01  F2REC             PIC X(80).
       WORKING-STORAGE SECTION.
       77  FILENAME          PIC X(80) VALUE "MYFILE2".
       01  WSFS              PIC X(2).
       PROCEDURE DIVISION.
      *
           OPEN OUTPUT FILE0
           DISPLAY "STATUS OPENO 0 " WSFS
           OPEN OUTPUT FILE1
           DISPLAY "STATUS OPENO 1 " WSFS
           OPEN OUTPUT FILE2
           DISPLAY "STATUS OPENO 2 " WSFS
      *
           STOP RUN.
])

AT_CHECK([$COMPILE prog4.cob], [0], [], [])

AT_CHECK([DD_MYFILE1="./nosubhere/NOFILE1" DD_MYFILE2="./nosubhere/NOFILE2" \
$COBCRUN_DIRECT ./prog4], [0],
[STATUS OPENO 0 30
STATUS OPENO 1 30
STATUS OPENO 2 30
], [])

AT_CLEANUP


AT_SETUP([ASSIGN with COB_FILE_PATH])
AT_KEYWORDS([extensions runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT TEST-FILE ASSIGN "FILENAMEX".
       DATA             DIVISION.
       FILE             SECTION.
       FD TEST-FILE.
       01 TEST-REC      PIC X(4).
       PROCEDURE        DIVISION.
           OPEN OUTPUT TEST-FILE.
           CLOSE TEST-FILE.
           STOP RUN.
])

AT_CHECK([$COMPILE -ffilename-mapping prog.cob], [0], [], [])
AT_CHECK([rm -rf "tstdir" && mkdir "tstdir"], [0], [], [])
AT_CHECK([COB_FILE_PATH="tstdir" $COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([test -f "tstdir/FILENAMEX" && rm -f "tstdir/FILENAMEX"], [0], [], [])
AT_CHECK([COB_FILE_PATH="tstdir/" $COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([test -f "tstdir/FILENAMEX"], [0], [], [])

# FIXME: on OPEN we should also output the full filename (if any) leading to the error
AT_CHECK([COB_FILE_PATH="./nosubhere" $COBCRUN_DIRECT ./prog 2>prog.err], [1], [], [])
# workaround for testing windows-builds...
AT_CHECK([cat prog.err | tr '\\' '/'], [0],
[libcob: prog.cob:13: error: permanent file error (status = 30) for file TEST-FILE ('FILENAMEX' => ./nosubhere/FILENAMEX) on OPEN
], [])

AT_CLEANUP


AT_SETUP([ASSIGN DYNAMIC with LOCAL-STORAGE item])
AT_KEYWORDS([runfile])

AT_DATA([test.txt],
[hello
])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT test-file ASSIGN path
                        ORGANIZATION LINE SEQUENTIAL.
       DATA             DIVISION.
       FILE	            SECTION.
       FD  test-file.
       01  test-rec     PIC X(5).
       LOCAL-STORAGE    SECTION.
       01  path         PIC X(10) VALUE "test.txt".
       PROCEDURE        DIVISION.
           OPEN INPUT test-file
           READ test-file   END-READ
           IF test-rec NOT = "hello"
              DISPLAY test-rec END-DISPLAY
           END-IF
           CLOSE test-file
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([ASSIGN DYNAMIC with LOCAL-STORAGE item, INITIAL])
AT_KEYWORDS([runfile])

# Files are initialised in a different location in INITIAL program, hence the
# need for a separate test.

AT_DATA([test.txt],
[hello
])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog INITIAL.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT test-file ASSIGN path
                        ORGANIZATION LINE SEQUENTIAL.
       DATA             DIVISION.
       FILE	            SECTION.
       FD  test-file.
       01  test-rec     PIC X(5).
       LOCAL-STORAGE    SECTION.
       01  path         PIC X(10) VALUE "test.txt".
       PROCEDURE        DIVISION.
           OPEN INPUT test-file
           READ test-file   END-READ
           IF test-rec NOT = "hello"
              DISPLAY test-rec END-DISPLAY
           END-IF
           CLOSE test-file
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([ASSIGN DYNAMIC with BASED data item])
AT_KEYWORDS([runfile status])

AT_DATA([TEST-FILE],
[hello
])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT test-file ASSIGN path
                        ORGANIZATION LINE SEQUENTIAL.
       DATA             DIVISION.
       FILE	            SECTION.
       FD  test-file.
       01  test-rec     PIC X(5).
       WORKING-STORAGE  SECTION.
       01  path         BASED PIC X(10).
       01  x            PIC X.
       PROCEDURE        DIVISION CHAINING x.
           IF x NOT = SPACES
              ALLOCATE path
              MOVE "TEST-FILE" TO path
              OPEN INPUT test-file
              FREE path
           ELSE
              OPEN INPUT test-file
           END-IF
           READ test-file   END-READ
           IF test-rec NOT = "hello"
              DISPLAY test-rec END-DISPLAY
           END-IF
           CLOSE test-file
           STOP RUN.
])

AT_DATA([prog2.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog2.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT test-file ASSIGN path
                        ORGANIZATION LINE SEQUENTIAL
                        FILE STATUS TEST-STAT.
       DATA             DIVISION.
       FILE	            SECTION.
       FD  test-file.
       01  test-rec     PIC X(5).
       WORKING-STORAGE  SECTION.
       01  path         BASED PIC X(10).
       01  test-stat    PIC X(2) VALUE "XX".
       PROCEDURE        DIVISION.
           OPEN INPUT test-file
           IF TEST-STAT NOT = '31'
              DISPLAY 'BAD OPEN, STATUS "' test-stat '"' END-DISPLAY
           END-IF
           READ test-file   END-READ
           IF TEST-STAT NOT = '47'
              DISPLAY 'BAD READ, STATUS "' test-stat '"' END-DISPLAY
           END-IF
           CLOSE test-file
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob])
AT_CHECK([$COBCRUN_DIRECT ./prog X], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [1], [],
[libcob: prog.cob:23: error: inconsistent file name (status = 31) for file test-file ('field with NULL address') on OPEN
])
# Tested again without source location and checks
AT_CHECK([$COBC -x prog.cob])
AT_CHECK([$COBCRUN_DIRECT ./prog], [1], [],
[libcob: error: inconsistent file name (status = 31) for file test-file ('field with NULL address')
])


AT_CHECK([$COMPILE prog2.cob])
AT_CHECK([$COBCRUN_DIRECT ./prog2], [0], [], [])

AT_CLEANUP


AT_SETUP([ASSIGN DYNAMIC with data item in LINKAGE])
AT_KEYWORDS([runfile-CONTROL file status CALL])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.

       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01  f-path     PIC X(80) VALUE "fooasg.txt".
       01  x-path     PIC X(80) VALUE "foxasg.txt".
       01  y-path     PIC X(80) VALUE "foyasg.txt".
       01  REC1       PIC 9(4) VALUE 1.
       01  REC2       PIC 9(4) VALUE 2.
       01  CUST-STAT  PIC X(2) VALUE "XX".

       PROCEDURE DIVISION.
           CALL "TSTOPN"  USING OMITTED.
           CALL "TSTOPN"  USING y-path.
           CALL "TSTOPEN" USING f-path  REC1 CUST-STAT.
           CALL "TSTOPEN" USING x-path  REC1 CUST-STAT.
           CALL "TSTOPEN" USING OMITTED REC1 CUST-STAT.
           CALL "TSTOPEN" USING f-path  REC2 CUST-STAT.
           CALL "TSTOPEN" USING x-path  REC2 CUST-STAT.
           STOP RUN.
           END PROGRAM prog.

       IDENTIFICATION DIVISION.
       PROGRAM-ID. TSTOPEN.

       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT f ASSIGN s-path
           ORGANIZATION RELATIVE
           ACCESS IS RANDOM
           RELATIVE KEY IS REC-NUM
           FILE STATUS IS CUST-STAT.

       DATA DIVISION.
       FILE SECTION.
       FD  f.
       01  f-line PIC X(79).

       WORKING-STORAGE SECTION.
       01  z-path   PIC X(80) VALUE "foozzz.txt".

       LINKAGE SECTION.
       01  s-path     PIC X(80).
       01  REC-NUM    PIC 9(4).
       01  CUST-STAT  PIC X(2).

       PROCEDURE DIVISION USING OPTIONAL s-path, REC-NUM, CUST-STAT.
           IF ADDRESS OF s-path = NULL
              SET ADDRESS OF s-path TO ADDRESS OF z-path
           END-IF.
           IF REC-NUM > 1
              OPEN I-O f
              DISPLAY "Extend file: " s-path(1:10)
                   " - " CUST-STAT " #" REC-NUM "."
           ELSE
              OPEN OUTPUT f
              DISPLAY "Output file: " s-path(1:10)
                   " - " CUST-STAT " #" REC-NUM "."
           END-IF.
           IF CUST-STAT NOT = "00"
               DISPLAY "Opened error: " CUST-STAT "."
               GOBACK
           END-IF.
           MOVE "Hello World" TO f-line.
           MOVE REC-NUM       TO f-line (20:4).
           WRITE f-line.
           IF CUST-STAT NOT = "00"
               DISPLAY "WRITE error: " CUST-STAT "."
           END-IF.
           CLOSE f.
           GOBACK.
       END PROGRAM TSTOPEN.

       IDENTIFICATION DIVISION.
       PROGRAM-ID. TSTOPN.

       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT f ASSIGN s-path
           ORGANIZATION LINE SEQUENTIAL
           FILE STATUS IS IO-STS.

       DATA DIVISION.
       FILE SECTION.
       FD  f.
       01  f-line PIC X(80).

       WORKING-STORAGE SECTION.
       01  IO-STS   PIC X(2) VALUE "00".

       LINKAGE SECTION.
       01  s-path   PIC X(80).

       PROCEDURE DIVISION USING OPTIONAL s-path.
           OPEN OUTPUT f
           IF IO-STS NOT = "00"
               DISPLAY "Opened error: " IO-STS "."
               GOBACK
           END-IF.
           DISPLAY "Opened file: " s-path(1:10) ".".
           MOVE "Hello World" TO f-line.
           WRITE f-line.
           CLOSE f.
           GOBACK.
       END PROGRAM TSTOPN.
])

AT_DATA([prog2.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog2.

       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.

       PROCEDURE DIVISION.
           CALL "TSTOPEN" USING OMITTED.
           STOP RUN.
           END PROGRAM prog2.

       IDENTIFICATION DIVISION.
       PROGRAM-ID. TSTOPEN.

       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT f ASSIGN s-path
           ORGANIZATION SEQUENTIAL.

       DATA DIVISION.
       FILE SECTION.
       FD  f.
       01  f-line PIC X(79).

       LINKAGE SECTION.
       01  s-path     PIC X(80).

       PROCEDURE DIVISION USING OPTIONAL s-path.
           OPEN OUTPUT f
           GOBACK.
       END PROGRAM TSTOPEN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[Opened error: 31.
Opened file: foyasg.txt.
Output file: fooasg.txt - 00 #0001.
Output file: foxasg.txt - 00 #0001.
Output file: foozzz.txt - 00 #0001.
Extend file: fooasg.txt - 00 #0002.
Extend file: foxasg.txt - 00 #0002.
], [])

AT_CHECK([$COMPILE prog2.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog2], [1], [],
[libcob: prog2.cob:32: error: inconsistent file name (status = 31) for file f ('field with NULL address') on OPEN
])

AT_CLEANUP


AT_SETUP([ASSIGN DYNAMIC with empty data item])
AT_KEYWORDS([runfile status])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT test-file ASSIGN path
                        ORGANIZATION LINE SEQUENTIAL.
       DATA             DIVISION.
       FILE	            SECTION.
       FD  test-file.
       01  test-rec     PIC X(5).
       WORKING-STORAGE  SECTION.
       01  path         PIC X(10).
       01  x            PIC X.
       PROCEDURE        DIVISION CHAINING x.
           IF X = SPACE
              MOVE SPACES     TO path
           ELSE
              MOVE LOW-VALUES TO path
           END-IF
           OPEN INPUT test-file
           DISPLAY "Hello"
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [1], [],
[libcob: prog.cob:22: error: inconsistent file name (status = 31) for file test-file ('') on OPEN
])
AT_CHECK([$COBCRUN_DIRECT ./prog X], [1], [],
[libcob: prog.cob:22: error: inconsistent file name (status = 31) for file test-file ('') on OPEN
])

AT_CLEANUP


AT_SETUP([ASSIGN DYNAMIC with unset implicit data item])
AT_KEYWORDS([runfile status])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT test-file ASSIGN fpath
                        ORGANIZATION LINE SEQUENTIAL.
       DATA             DIVISION.
       FILE	            SECTION.
       FD  test-file.
       01  test-rec     PIC X(5).
       PROCEDURE        DIVISION.
           OPEN INPUT test-file
           DISPLAY "Hello"
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [1], [],
[libcob: prog.cob:14: error: file does not exist (status = 35) for file test-file ('fpath') on OPEN
])
AT_CHECK([fpath="not.there" $COBCRUN_DIRECT ./prog X], [1], [],
[libcob: prog.cob:14: error: file does not exist (status = 35) for file test-file ('fpath' => not.there) on OPEN
])

AT_CLEANUP


AT_SETUP([INDEXED file key-name])
AT_KEYWORDS([runfile split key])

# FIXME: separate both test parts

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. "test".
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT TEST-FILE ASSIGN "FILE"
               ORGANIZATION IS INDEXED
               ACCESS IS DYNAMIC
               RECORD KEY IS KEY01 = QQINDEX.
       DATA DIVISION.
       FILE SECTION.
       FD TEST-FILE.
       01 TEST-REC.
          03 QQDATA     PIC X(80).
          03 QQINDEX    PIC XXX9999.
          03 QQSEQUENCE PIC 9999.
       PROCEDURE DIVISION.
           OPEN OUTPUT TEST-FILE
           MOVE 'TEST DATA 1' TO QQDATA
           MOVE 'ABC0001'     TO QQINDEX
           WRITE TEST-REC
           MOVE 'TEST DATA 2' TO QQDATA
           MOVE 'ABC0002'     TO QQINDEX
           WRITE TEST-REC
           CLOSE TEST-FILE
           DISPLAY 'FINE' WITH NO ADVANCING
           GOBACK.
])
AT_CHECK([$COMPILE prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [FINE], [])
AT_CLEANUP


AT_SETUP([INDEXED file sparse/split keys])
AT_KEYWORDS([runfile split key sparse SUPPRESS])

# FIXME: separate both test parts

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.

       PROGRAM-ID. prog.

       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.

       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT TSPFILE
           ASSIGN TO "testisam"
           ORGANIZATION INDEXED ACCESS DYNAMIC
           RECORD KEY IS PRIME-KEY
           SOURCE IS CM-CUST-NUM, CM-COMPANY

           ALTERNATE RECORD KEY IS SPLIT-KEY2
           SOURCE IS CM-TELEPHONE,CM-MACHINE WITH DUPLICATES

           ALTERNATE RECORD KEY IS SPLIT-KEY3
           SOURCE IS CM-DISK,CM-TAPE WITH DUPLICATES
                SUPPRESS WHEN ALL "*"
           FILE STATUS IS CUST-STAT
           .

       DATA  DIVISION.
       FILE SECTION.
       FD  TSPFILE
           BLOCK CONTAINS 5 RECORDS.

       01  TSPFL-RECORD.
           05  TSPFL-REC.
           10  CM-CUST-NUM                     PICTURE X(8).
           10  CM-STATUS                       PICTURE X.
           10  CM-COMPANY                      PICTURE X(25).
           10  CM-ADDRESS-1                    PICTURE X(25).
           10  CM-ADDRESS-2                    PICTURE X(25).
           10  CM-ADDRESS-3                    PICTURE X(25).
           10  CM-TELEPHONE                    PICTURE 9(10).
           10  CM-DP-MGR                       PICTURE X(25).
           10  CM-MACHINE                      PICTURE X(8).
           10  CM-MEMORY                       PICTURE X(4).
           10  CM-DISK                         PICTURE X(8).
           10  CM-TAPE                         PICTURE X(8).
           10  CM-NO-TERMINALS                 PICTURE 9(5).

       WORKING-STORAGE SECTION.

       01  CUST-STAT.
           05  STAT-1 PICTURE 9(4) COMP SYNC.
           05  FILLER REDEFINES STAT-1.
               10  STAT-X1 PIC X COMP-X.
               10  STAT-X2 PIC X COMP-X.
       77  BYTE-1  PICTURE 9(3).
       77  BYTE-2  PICTURE 9(3).
       78  MAX-SUB           VALUE  16.

       01  TEST-DATA.

         02  DATA-CUST-NUM-TBL.

           05  FILLER PIC X(8) VALUE "ALP00000".
           05  FILLER PIC X(8) VALUE "BET00000".
           05  FILLER PIC X(8) VALUE "GAM00000".
           05  FILLER PIC X(8) VALUE "DEL00000".
           05  FILLER PIC X(8) VALUE "EPS00000".
           05  FILLER PIC X(8) VALUE "FOR00000".
           05  FILLER PIC X(8) VALUE "GIB00000".
           05  FILLER PIC X(8) VALUE "H&J00000".
           05  FILLER PIC X(8) VALUE "INC00000".
           05  FILLER PIC X(8) VALUE "JOH00000".
           05  FILLER PIC X(8) VALUE "KON00000".
           05  FILLER PIC X(8) VALUE "LEW00000".
           05  FILLER PIC X(8) VALUE "MOR00000".
           05  FILLER PIC X(8) VALUE "NEW00000".
           05  FILLER PIC X(8) VALUE "OLD00000".
           05  FILLER PIC X(8) VALUE "PRE00000".

         02  DATA-CUST-NUM REDEFINES DATA-CUST-NUM-TBL
                                       PIC X(8) OCCURS MAX-SUB.
         02  DATA-COMPANY-TBL.

           05  FILLER PIC X(25) VALUE "ALPHA ELECTRICAL CO. LTD.".
           05  FILLER PIC X(25) VALUE "BETA SHOE MFG. INC.      ".
           05  FILLER PIC X(25) VALUE "GAMMA X-RAY TECHNOLOGY   ".
           05  FILLER PIC X(25) VALUE "DELTA LUGGAGE REPAIRS    ".
           05  FILLER PIC X(25) VALUE "EPSILON EQUIPMENT SUPPLY ".
           05  FILLER PIC X(25) VALUE "FORTUNE COOKIE COMPANY   ".
           05  FILLER PIC X(25) VALUE "GIBRALTER LIFE INSURANCE ".
           05  FILLER PIC X(25) VALUE "H & J PLUMBING SUPPLIES  ".
           05  FILLER PIC X(25) VALUE "INCREMENTAL BACKUP CORP. ".
           05  FILLER PIC X(25) VALUE "JOHNSON BOATING SUPPLIES ".
           05  FILLER PIC X(25) VALUE "KONFLAB PLASTIC PRODUCTS.".
           05  FILLER PIC X(25) VALUE "LEWISTON GRAPHICS LTD.   ".
           05  FILLER PIC X(25) VALUE "MORNINGSIDE CARPENTRY.   ".
           05  FILLER PIC X(25) VALUE "NEW WAVE SURF SHOPS INC. ".
           05  FILLER PIC X(25) VALUE "OLD TYME PIZZA MFG. CO.  ".
           05  FILLER PIC X(25) VALUE "PRESTIGE OFFICE FURNITURE".

         02  DATA-COMPANY  REDEFINES DATA-COMPANY-TBL
                                       PIC X(25) OCCURS MAX-SUB.
         02  DATA-ADDRESS-1-TBL.

           05  FILLER PIC X(25) VALUE "123 MAIN STREET          ".
           05  FILLER PIC X(25) VALUE "1090 2ND AVE. WEST       ".
           05  FILLER PIC X(25) VALUE "1401 JEFFERSON BLVD.     ".
           05  FILLER PIC X(25) VALUE "1620 ARIZONA WAY         ".
           05  FILLER PIC X(25) VALUE "1184 EAST FIRST STREET   ".
           05  FILLER PIC X(25) VALUE "114 JOHN F. KENNEDY AVE. ".
           05  FILLER PIC X(25) VALUE "650 LIBERTY CRESCENT     ".
           05  FILLER PIC X(25) VALUE "77 SUNSET BLVD.          ".
           05  FILLER PIC X(25) VALUE "10908 SANTA MONICA BLVD. ".
           05  FILLER PIC X(25) VALUE "1134 PARIS ROAD          ".
           05  FILLER PIC X(25) VALUE "808 NORTHWEST MAIN ST.   ".
           05  FILLER PIC X(25) VALUE "9904 QUEEN STREET        ".
           05  FILLER PIC X(25) VALUE "1709 DUNDAS CRESCENT W.  ".
           05  FILLER PIC X(25) VALUE "3240 MARIS AVENUE        ".
           05  FILLER PIC X(25) VALUE "1705 WISCONSIN ROAD      ".
           05  FILLER PIC X(25) VALUE "114A MAPLE GROVE         ".

         02  DATA-ADDRESS-1 REDEFINES DATA-ADDRESS-1-TBL
                                       PIC X(25) OCCURS MAX-SUB.
         02  DATA-ADDRESS-2-TBL.

           05  FILLER PIC X(10) VALUE "NEW YORK  ".
           05  FILLER PIC X(10) VALUE "ATLANTA   ".
           05  FILLER PIC X(10) VALUE "WASHINGTON".
           05  FILLER PIC X(10) VALUE "TORONTO   ".
           05  FILLER PIC X(10) VALUE "CALGARY   ".
           05  FILLER PIC X(10) VALUE "SAN DIEGO ".
           05  FILLER PIC X(10) VALUE "LOS RIOS  ".
           05  FILLER PIC X(10) VALUE "MADISON   ".
           05  FILLER PIC X(10) VALUE "WILBUR    ".
           05  FILLER PIC X(10) VALUE "TOPEKA    ".
           05  FILLER PIC X(10) VALUE "SEATTLE   ".
           05  FILLER PIC X(10) VALUE "NEW JERSEY".
           05  FILLER PIC X(10) VALUE "FORT WAYNE".
           05  FILLER PIC X(10) VALUE "COLUMBUS  ".
           05  FILLER PIC X(10) VALUE "RICHMOND  ".
           05  FILLER PIC X(10) VALUE "WHITEPLAIN".

         02  DATA-ADDRESS-2 REDEFINES DATA-ADDRESS-2-TBL
                                       PIC X(10) OCCURS MAX-SUB.
         02  DATA-ADDRESS-3-TBL.

           05  FILLER PIC X(10) VALUE "N.Y.      ".
           05  FILLER PIC X(10) VALUE "GEORGIA   ".
           05  FILLER PIC X(10) VALUE "D.C.      ".
           05  FILLER PIC X(10) VALUE "CANADA    ".
           05  FILLER PIC X(10) VALUE "CANADA    ".
           05  FILLER PIC X(10) VALUE "CALIFORNIA".
           05  FILLER PIC X(10) VALUE "NEW MEXICO".
           05  FILLER PIC X(10) VALUE "WISCONSIN ".
           05  FILLER PIC X(10) VALUE "DELAWARE  ".
           05  FILLER PIC X(10) VALUE "KANSAS    ".
           05  FILLER PIC X(10) VALUE "WASHINGTON".
           05  FILLER PIC X(10) VALUE "N.J.      ".
           05  FILLER PIC X(10) VALUE "COLORADO  ".
           05  FILLER PIC X(10) VALUE "OHIO      ".
           05  FILLER PIC X(10) VALUE "VIRGINIA  ".
           05  FILLER PIC X(10) VALUE "N.Y.      ".

         02  DATA-ADDRESS-3 REDEFINES DATA-ADDRESS-3-TBL
                                       PIC X(10) OCCURS MAX-SUB.
         02  DATA-TELEPHONE-TBL.

           05  FILLER PIC 9(10) VALUE 3131234432.
           05  FILLER PIC 9(10) VALUE 4082938498.
           05  FILLER PIC 9(10) VALUE 8372487274.
           05  FILLER PIC 9(10) VALUE 4169898509.
           05  FILLER PIC 9(10) VALUE 5292398745.
           05  FILLER PIC 9(10) VALUE 8009329492.
           05  FILLER PIC 9(10) VALUE 6456445643.
           05  FILLER PIC 9(10) VALUE 6546456333.
           05  FILLER PIC 9(10) VALUE 3455445444.
           05  FILLER PIC 9(10) VALUE 6456445643.
           05  FILLER PIC 9(10) VALUE 7456434355.
           05  FILLER PIC 9(10) VALUE 6554456433.
           05  FILLER PIC 9(10) VALUE 4169898509.
           05  FILLER PIC 9(10) VALUE 7534587453.
           05  FILLER PIC 9(10) VALUE 8787458374.
           05  FILLER PIC 9(10) VALUE 4169898509.

         02  DATA-TELEPHONE REDEFINES DATA-TELEPHONE-TBL
                                       PIC 9(10) OCCURS MAX-SUB.
         02  DATA-DP-MGR-TBL.

           05  FILLER PIC X(20) VALUE "MR. DAVE HARRIS     ".
           05  FILLER PIC X(20) VALUE "MS. JANICE SILCOX   ".
           05  FILLER PIC X(20) VALUE "MR. ALLAN JONES     ".
           05  FILLER PIC X(20) VALUE "MR. PETER MACKAY    ".
           05  FILLER PIC X(20) VALUE "MRS. DONNA BREWER   ".
           05  FILLER PIC X(20) VALUE "MR. MICHAEL SMYTHE  ".
           05  FILLER PIC X(20) VALUE "MR. D.A. MORRISON   ".
           05  FILLER PIC X(20) VALUE "MR. BRIAN PATTERSON ".
           05  FILLER PIC X(20) VALUE "MR. DARRYL TOWNSEND ".
           05  FILLER PIC X(20) VALUE "MS. VALERIE HARPER  ".
           05  FILLER PIC X(20) VALUE "MR. FRED MILLER     ".
           05  FILLER PIC X(20) VALUE "MR. DONALD FISCHER  ".
           05  FILLER PIC X(20) VALUE "MR. STEVEN YOURDIN  ".
           05  FILLER PIC X(20) VALUE "MS. Goldie Hawn     ".
           05  FILLER PIC X(20) VALUE "MS. ALICE WINSTON   ".
           05  FILLER PIC X(20) VALUE "MR. THOMAS JEFFERSON".

         02  DATA-DP-MGR    REDEFINES DATA-DP-MGR-TBL
                                       PIC X(20) OCCURS MAX-SUB.
         02  DATA-MACHINE-TBL.

           05  FILLER PIC X(8) VALUE "UNI-9030".
           05  FILLER PIC X(8) VALUE "UNI-9040".
           05  FILLER PIC X(8) VALUE "UNI-80/3".
           05  FILLER PIC X(8) VALUE "UNI-80/5".
           05  FILLER PIC X(8) VALUE "UNI-80/6".
           05  FILLER PIC X(8) VALUE "UNI-80/6".
           05  FILLER PIC X(8) VALUE "UNI-80/6".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-9040".
           05  FILLER PIC X(8) VALUE "UNI-9040".

         02  DATA-MACHINE   REDEFINES DATA-MACHINE-TBL
                                       PIC X(8) OCCURS MAX-SUB.
         02  DATA-NO-TERMINALS-TBL.

           05  FILLER PIC 9(3) COMP-3 VALUE 85.
           05  FILLER PIC 9(3) COMP-3 VALUE 34.
           05  FILLER PIC 9(3) COMP-3 VALUE 75.
           05  FILLER PIC 9(3) COMP-3 VALUE 45.
           05  FILLER PIC 9(3) COMP-3 VALUE 90.
           05  FILLER PIC 9(3) COMP-3 VALUE 107.
           05  FILLER PIC 9(3) COMP-3 VALUE 67.
           05  FILLER PIC 9(3) COMP-3 VALUE 32.
           05  FILLER PIC 9(3) COMP-3 VALUE 16.
           05  FILLER PIC 9(3) COMP-3 VALUE 34.
           05  FILLER PIC 9(3) COMP-3 VALUE 128.
           05  FILLER PIC 9(3) COMP-3 VALUE 64.
           05  FILLER PIC 9(3) COMP-3 VALUE 110.
           05  FILLER PIC 9(3) COMP-3 VALUE 324.
           05  FILLER PIC 9(3) COMP-3 VALUE 124.
           05  FILLER PIC 9(3) COMP-3 VALUE 86.

         02  DATA-NO-TERMINALS REDEFINES DATA-NO-TERMINALS-TBL
                                       PIC 9(3) COMP-3 OCCURS MAX-SUB.

       78  REC-MAX                     VALUE 10.
       01  WORK-AREA.
           05  REC-NUM                 BINARY-SHORT UNSIGNED VALUE 0.
           05  SUB                     BINARY-SHORT UNSIGNED.
               88  ODD-RECORD          VALUE 1 3 5 7 9 10 11.
               88  NULL-KEY            VALUE 4 5 8 12 14.

           05  TSPFL-KEY               PICTURE X(8).

       PROCEDURE DIVISION.

       MAINFILE.
           PERFORM LOADFILE.
           PERFORM LISTFILE.
           STOP RUN.

       LOADFILE.
           DISPLAY "Loading sample data file."
                            UPON CONSOLE.

           OPEN OUTPUT TSPFILE
           IF CUST-STAT NOT = "00"
               DIVIDE STAT-1 BY 256 GIVING BYTE-1 REMAINDER BYTE-2
               DISPLAY "Error " CUST-STAT " " BYTE-1 " " BYTE-2
               " opening 'testisam' file"
                                UPON CONSOLE
               STOP RUN
           END-IF.

           PERFORM 1000-LOAD-RECORD
                        VARYING SUB FROM 1 BY 1
                          UNTIL SUB > MAX-SUB.

           DISPLAY "Sample data file load complete."
                            UPON CONSOLE.
           CLOSE TSPFILE.

      *---------------------------------------------------------------*
      *         LOAD A RECORD FROM DATA TABLES                        *
      *---------------------------------------------------------------*

       1000-LOAD-RECORD.

           MOVE SPACES                       TO TSPFL-RECORD.
           MOVE DATA-CUST-NUM      (SUB)     TO CM-CUST-NUM.
           MOVE CM-CUST-NUM                  TO TSPFL-KEY.
           MOVE DATA-COMPANY       (SUB)     TO CM-COMPANY.
           MOVE DATA-ADDRESS-1     (SUB)     TO CM-ADDRESS-1.
           MOVE DATA-ADDRESS-2     (SUB)     TO CM-ADDRESS-2.
           MOVE DATA-ADDRESS-3     (SUB)     TO CM-ADDRESS-3.
           MOVE DATA-TELEPHONE     (SUB)     TO CM-TELEPHONE.
           MOVE DATA-DP-MGR        (SUB)     TO CM-DP-MGR.
           MOVE DATA-MACHINE       (SUB)     TO CM-MACHINE.
           MOVE DATA-NO-TERMINALS  (SUB)     TO CM-NO-TERMINALS.

           IF  ODD-RECORD
               MOVE "8417"                   TO CM-DISK
               MOVE "1600 BPI"               TO CM-TAPE
               MOVE "1MEG"                   TO CM-MEMORY
           ELSE
               MOVE "8470"                   TO CM-DISK
               MOVE "6250 BPI"               TO CM-TAPE
               MOVE "3MEG"                   TO CM-MEMORY.
           IF  NULL-KEY
               MOVE ALL "*"                  TO CM-DISK
               MOVE ALL "*"                  TO CM-TAPE.

           WRITE TSPFL-RECORD.
           IF CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Key: " TSPFL-KEY ", Status: " CUST-STAT
                                 UPON CONSOLE.

       LISTFILE.
           DISPLAY "LIST SAMPLE FILE" UPON CONSOLE.
           MOVE ZERO TO REC-NUM
           OPEN INPUT TSPFILE
           IF CUST-STAT NOT = "00"
               DISPLAY "ERROR " CUST-STAT " OPENING INPUT FILE "
                                             UPON CONSOLE
               IF CUST-STAT (1:1) = "9"
                   DISPLAY "Sub Error " STAT-X2 UPON CONSOLE
               END-IF
               STOP RUN
           END-IF.
           MOVE SPACES                       TO TSPFL-RECORD.
           START TSPFILE KEY GREATER THAN PRIME-KEY
           IF CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " starting file"
                                UPON CONSOLE
               IF CUST-STAT (1:1) = "9"
                   DISPLAY "Sub Error " STAT-X2 UPON CONSOLE
               END-IF
               STOP RUN
           END-IF.
           READ  TSPFILE NEXT RECORD WITH NO LOCK
           IF CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " on 1st read of file"
                                UPON CONSOLE
               IF CUST-STAT (1:1) = "9"
                   DISPLAY "Sub Error " STAT-X2 UPON CONSOLE
               END-IF
               STOP RUN
           END-IF.
           PERFORM UNTIL CUST-STAT NOT = "00"
                      OR REC-NUM > REC-MAX
               DISPLAY "Key: " CM-CUST-NUM " is " CM-COMPANY
                        " Disk=" CM-DISK ":"
                         UPON CONSOLE
               READ TSPFILE NEXT RECORD
                    AT END
                        MOVE "99" TO CUST-STAT
                END-READ
                ADD 1 TO REC-NUM
           END-PERFORM
           IF CUST-STAT = "99"
               DISPLAY "Hit End of File" UPON CONSOLE
           END-IF.

           DISPLAY "LIST SAMPLE FILE DESCENDING" UPON CONSOLE.
           MOVE ZERO TO REC-NUM
           START TSPFILE KEY LESS THAN PRIME-KEY
           IF CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " starting file"
                                UPON CONSOLE
               STOP RUN
           END-IF.
           READ  TSPFILE PREVIOUS RECORD WITH NO LOCK
           IF CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " on 1st read of file"
                                UPON CONSOLE
               STOP RUN
           END-IF.
           PERFORM UNTIL CUST-STAT NOT = "00"
                      OR REC-NUM > REC-MAX
               DISPLAY "Key: " CM-CUST-NUM " is " CM-COMPANY
                        " Disk=" CM-DISK ":"
                         UPON CONSOLE
               READ TSPFILE PREVIOUS RECORD
                    AT END
                        MOVE "99" TO CUST-STAT
                END-READ
                ADD 1 TO REC-NUM
           END-PERFORM.

           DISPLAY "LIST SAMPLE FILE BY KEY3" UPON CONSOLE.
           MOVE ZERO                         TO REC-NUM
           MOVE SPACES                       TO TSPFL-RECORD.
           START TSPFILE KEY GREATER THAN OR EQUAL TO SPLIT-KEY3
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " starting file"
                                UPON CONSOLE
               STOP RUN
           END-IF.
           READ  TSPFILE NEXT RECORD WITH NO LOCK
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " on 1st read of file"
                                UPON CONSOLE
               STOP RUN
           END-IF.
           PERFORM UNTIL (CUST-STAT NOT = "00"
                      AND CUST-STAT NOT = "02")
                      OR REC-NUM > REC-MAX
               DISPLAY "Key: " CM-CUST-NUM " is " CM-COMPANY
                        " Disk=" CM-DISK ":"
                         UPON CONSOLE
               READ TSPFILE NEXT RECORD
                    AT END
                        MOVE "99" TO CUST-STAT
                END-READ
                ADD 1 TO REC-NUM
           END-PERFORM.
      *---- Some results may be different with VB-ISAM  ------*
           MOVE SPACES                       TO TSPFL-RECORD.
           MOVE DATA-CUST-NUM      (2)       TO CM-CUST-NUM.
           READ TSPFILE KEY IS PRIME-KEY
           IF  CUST-STAT NOT = "23"
               DISPLAY "Error " CUST-STAT " instead of 23"
                                UPON CONSOLE
           END-IF.
           MOVE DATA-COMPANY       (2)       TO CM-COMPANY.
           READ TSPFILE KEY IS PRIME-KEY
           IF  CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " on primary read "
                                UPON CONSOLE
           ELSE
               DISPLAY "Got: " CM-CUST-NUM " is " CM-COMPANY
                        " Disk=" CM-DISK ":"
                         UPON CONSOLE
           END-IF.
           READ TSPFILE NEXT RECORD
           IF  CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " on next read "
                                UPON CONSOLE
           ELSE
               DISPLAY "Nxt: " CM-CUST-NUM " is " CM-COMPANY
                        " Disk=" CM-DISK ":"
                         UPON CONSOLE
           END-IF.
           MOVE DATA-TELEPHONE     (7)       TO CM-TELEPHONE.
           MOVE DATA-MACHINE       (7)       TO CM-MACHINE.
           READ TSPFILE KEY IS SPLIT-KEY2
           IF  CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " instead of 23"
                                UPON CONSOLE
           ELSE
               DISPLAY "Ky2: " CM-CUST-NUM " is " CM-COMPANY
                        " Mach=" CM-MACHINE ":"
                         UPON CONSOLE
           END-IF.
           CLOSE TSPFILE.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[Loading sample data file.
Sample data file load complete.
LIST SAMPLE FILE
Key: ALP00000 is ALPHA ELECTRICAL CO. LTD. Disk=8417    :
Key: BET00000 is BETA SHOE MFG. INC.       Disk=8470    :
Key: DEL00000 is DELTA LUGGAGE REPAIRS     Disk=********:
Key: EPS00000 is EPSILON EQUIPMENT SUPPLY  Disk=********:
Key: FOR00000 is FORTUNE COOKIE COMPANY    Disk=8470    :
Key: GAM00000 is GAMMA X-RAY TECHNOLOGY    Disk=8417    :
Key: GIB00000 is GIBRALTER LIFE INSURANCE  Disk=8417    :
Key: H&J00000 is H & J PLUMBING SUPPLIES   Disk=********:
Key: INC00000 is INCREMENTAL BACKUP CORP.  Disk=8417    :
Key: JOH00000 is JOHNSON BOATING SUPPLIES  Disk=8417    :
Key: KON00000 is KONFLAB PLASTIC PRODUCTS. Disk=8417    :
LIST SAMPLE FILE DESCENDING
Key: KON00000 is KONFLAB PLASTIC PRODUCTS. Disk=8417    :
Key: JOH00000 is JOHNSON BOATING SUPPLIES  Disk=8417    :
Key: INC00000 is INCREMENTAL BACKUP CORP.  Disk=8417    :
Key: H&J00000 is H & J PLUMBING SUPPLIES   Disk=********:
Key: GIB00000 is GIBRALTER LIFE INSURANCE  Disk=8417    :
Key: GAM00000 is GAMMA X-RAY TECHNOLOGY    Disk=8417    :
Key: FOR00000 is FORTUNE COOKIE COMPANY    Disk=8470    :
Key: EPS00000 is EPSILON EQUIPMENT SUPPLY  Disk=********:
Key: DEL00000 is DELTA LUGGAGE REPAIRS     Disk=********:
Key: BET00000 is BETA SHOE MFG. INC.       Disk=8470    :
Key: ALP00000 is ALPHA ELECTRICAL CO. LTD. Disk=8417    :
LIST SAMPLE FILE BY KEY3
Key: ALP00000 is ALPHA ELECTRICAL CO. LTD. Disk=8417    :
Key: GAM00000 is GAMMA X-RAY TECHNOLOGY    Disk=8417    :
Key: GIB00000 is GIBRALTER LIFE INSURANCE  Disk=8417    :
Key: INC00000 is INCREMENTAL BACKUP CORP.  Disk=8417    :
Key: JOH00000 is JOHNSON BOATING SUPPLIES  Disk=8417    :
Key: KON00000 is KONFLAB PLASTIC PRODUCTS. Disk=8417    :
Key: BET00000 is BETA SHOE MFG. INC.       Disk=8470    :
Key: FOR00000 is FORTUNE COOKIE COMPANY    Disk=8470    :
Key: MOR00000 is MORNINGSIDE CARPENTRY.    Disk=8470    :
Key: OLD00000 is OLD TYME PIZZA MFG. CO.   Disk=8470    :
Key: PRE00000 is PRESTIGE OFFICE FURNITURE Disk=8470    :
Got: BET00000 is BETA SHOE MFG. INC.       Disk=8470    :
Nxt: DEL00000 is DELTA LUGGAGE REPAIRS     Disk=********:
Ky2: GIB00000 is GIBRALTER LIFE INSURANCE  Mach=UNI-80/6:
], [])

AT_CLEANUP


AT_SETUP([INDEXED file split keys WITH DUPLICATES])
AT_KEYWORDS([runfile key EXTFH])

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

## Note: The order in which secondary records with duplicate keys
##       are returnded is not guaranteed.

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.

       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
           SELECT test-file
               ASSIGN        "TESTFILE"
               ACCESS        DYNAMIC
               ORGANIZATION  INDEXED
               RECORD KEY           test-key-1 SOURCE IS test-key-p1
               ALTERNATE RECORD KEY test-key-2 SOURCE IS test-key-p2,
                                                         test-key-p3
               WITH DUPLICATES
           .

       DATA             DIVISION.
       FILE             SECTION.
       FD  test-file.
       01  test-rec.
           03  test-key-p1 PIC X(4).
           03  test-key-p2 PIC 9(4).
           03  test-data   PIC X(4).
           03  test-key-p3 PIC X(4).

       WORKING-STORAGE SECTION.
       01  found        PIC X(03).

       PROCEDURE        DIVISION.
           OPEN OUTPUT test-file
           WRITE test-rec FROM "BBBB0001dat1aaaa"
           WRITE test-rec FROM "AAAA0001dat2aaaa"
           WRITE test-rec FROM "CCCC0002dat3aaaa"
           WRITE test-rec FROM "DDDD0002dat4bbbb"
           WRITE test-rec FROM "EEEE0002dat5bbbb"
           CLOSE test-file

           OPEN INPUT test-file

           MOVE "CCCC" TO test-key-p1
           READ test-file KEY IS test-key-1
               INVALID KEY
                   DISPLAY "READ with CCCC found no record"
               NOT INVALID KEY
                   IF test-data NOT = "dat3"
                       DISPLAY "READ with wrong result: "
                           test-rec
           END-READ

           MOVE SPACES   TO found

           MOVE 0001     TO test-key-p2
           MOVE "aaaa"   TO test-key-p3
           START test-file KEY >= test-key-2
               INVALID KEY
                   DISPLAY "START >= 0001/aaaa found no record"
               NOT INVALID KEY
                   READ  test-file NEXT
                       AT END
                           DISPLAY "READ NEXT (1) found no record"
                       NOT AT END
                           EVALUATE test-data
                              WHEN "dat1"
                                 MOVE 'X' TO found (1:1)
                              WHEN "dat2"
                                 MOVE 'X' TO found (2:1)
                              WHEN OTHER
                                 DISPLAY "READ NEXT (1) "
                                     "with wrong result: "
                                     test-data
                   END-READ
                   READ  test-file NEXT
                       AT END
                           DISPLAY "READ NEXT (2) found no record"
                       NOT AT END
                           EVALUATE test-data
                              WHEN "dat1"
                                 MOVE 'X' TO found (1:1)
                              WHEN "dat2"
                                 MOVE 'X' TO found (2:1)
                              WHEN OTHER
                                 DISPLAY "READ NEXT (2) "
                                     "with wrong result: "
                                     test-data
                   END-READ
                   IF found NOT = 'XX '
                      DISPLAY "START >= + READ NEXT * 2 "
                          "with wrong result: " found
           END-START
           MOVE 0001      TO test-key-p2
           MOVE "aaaa"    TO test-key-p3
           START test-file KEY > test-key-2
               INVALID KEY
                   DISPLAY "START > 0001/aaaa found no record"
               NOT INVALID KEY
                   READ  test-file NEXT
                       AT END
                           DISPLAY "READ NEXT (3) found no record"
                       NOT AT END
                           IF test-data NOT = "dat3"
                               DISPLAY "READ NEXT (3) "
                                   "with wrong result: "
                                   test-data
                   END-READ
           END-START

           MOVE 0002      TO test-key-p2
           MOVE ALL "z"   TO test-key-p3
           START test-file KEY IS < test-key-2
               INVALID KEY
                   DISPLAY "START < 0002/zzzz found no record"
               NOT INVALID KEY
                   READ  test-file PREVIOUS
                       AT END
                           DISPLAY "READ PREVIOUS (1) found no record"
                       NOT AT END
                           IF test-data NOT = "dat5"
                              DISPLAY "READ PREVIOUS (1) "
                                  "with wrong result: "
                                  test-data
                   END-READ
                   READ  test-file PREVIOUS
                       AT END
                           DISPLAY "READ PREVIOUS (2) found no record"
                       NOT AT END
                           IF test-data NOT = "dat4"
                              DISPLAY "READ PREVIOUS (2) "
                                  "with wrong result: "
                                  test-data
                   END-READ
                   READ  test-file PREVIOUS
                       AT END
                           DISPLAY "READ PREVIOUS (3) found no record"
                       NOT AT END
                           IF test-data NOT = "dat3"
                              DISPLAY "READ PREVIOUS (3) "
                                  "with wrong result: "
                                  test-data
                   END-READ
           END-START

           CLOSE test-file
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

# verify that all of this works with wrapping to EXTFH calls and
# back to our own EXTFH entry point

AT_CHECK([$COMPILE -fcallfh=EXTFH -o extfh prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./extfh], [0], [], [])

AT_CLEANUP


AT_SETUP([INDEXED file variable length record])
AT_KEYWORDS([runfile OPTIONAL SUPPRESS WRITE START READ])

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog.cob], [
       Identification division.
       Program-id. prog.
      *
       Environment division.

       Input-output section.
       File-control.
      *
           Select optional tbw
               assign to path-tbw
               organization is indexed
               access mode is dynamic
               record key is tbw-key
               alternate record key is tbw-alt
                   suppress when space
               sharing with no other
               file status is fs-file-status.
      *
       I-o-control.
      *
       Data division.
       File section.
      *
       FD  tbw
           record is varying in size
               from 107 to 362 characters
               depending on end-tbw-record
	       .
       01  tbw-record.
           02 tbw-key                        pic x(100).
           02 tbw-alt.
               03 tbw-alt-1                  pic 9(02).
               03 tbw-alt-2                  pic 9(04).
           02 tbw-f1                         pic x(01).
           02 tbw-f2                         pic x(255).
      *
       Working-storage section.

       01  fs-file-status                 pic x(02).

       01  end-tbw-record                 pic 9(09) binary.

       01  flag-tbw                       pic x(01) value low-value.
           88 flag-tbw-open   value high-value.
           88 flag-tbw-closed value low-value.

       01  path-tbw                       pic x(255) value space.

       Procedure division.

      * Prepare.
           Move "tbw" to path-tbw.

      * First test.
           Perform tbw-delete-file thru tbw-exit.

           Perform tbw-open-i-o    thru tbw-exit.

           Move low-values to tbw-key.
           Perform tbw-start-primary-greater thru tbw-exit.

           Perform tbw-read-next thru tbw-exit.

           Move 122 to end-tbw-record.
           Move "aaaaa" to tbw-key.
           Move spaces to tbw-alt
                          tbw-f1
                          tbw-f2.
           Perform tbw-write thru tbw-exit.

           Move low-values to tbw-alt.
           Perform tbw-start-alternate thru tbw-exit.

           Move low-values to tbw-key.
           Perform tbw-start-primary-greater thru tbw-exit.

           Perform tbw-read-next thru tbw-exit.

           Perform tbw-read-next thru tbw-exit.

           Perform tbw-close thru tbw-exit.

      * Second test.

           Perform tbw-delete-file thru tbw-exit.

           Perform tbw-open-i-o thru tbw-exit.

           Move low-values to tbw-key.
           Perform tbw-start-primary-greater thru tbw-exit.

           Perform tbw-read-next thru tbw-exit.

           Move 163 to end-tbw-record.
           Move "aaaaa" to tbw-key.
           Move 1 to tbw-alt-1
                     tbw-alt-2.
           Move spaces to tbw-f1
                          tbw-f2.
           Perform tbw-write thru tbw-exit.

           Move 122 to end-tbw-record.
           Move "aaaab" to tbw-key.
           Move spaces to tbw-alt
                          tbw-f1
                          tbw-f2.
           Perform tbw-write thru tbw-exit.

           Move low-values to tbw-alt.
           Perform tbw-start-alternate thru tbw-exit.

           Perform tbw-read-next thru tbw-exit.

           Move spaces to tbw-alt.
           Perform tbw-rewrite thru tbw-exit.

      *>   note: should not have status 02 as it a suppressed alternate key
      *>         therefore duplicate checks must be skipped

      * Finish.
           Perform tbw-close thru tbw-exit.
           Display "Test completed".
           Stop run.

      * I/O.
       tbw-Open-I-O.
           If flag-tbw-open
               Perform tbw-Close thru tbw-Close-exit.
           Display "open".
           Open i-o tbw.
           Display "open done".
           If fs-file-status is less than "10"
               Set flag-tbw-open to true.
           Go to tbw-exit.
      *
       tbw-Start-Primary-Greater.
           Display "start > tbw-key".
           Start tbw
               key is greater than tbw-key
               invalid key
                 Display "start > tbw-key inv"
                 Go to tbw-exit
               not invalid
                 Display "start > tbw-key done"
                 Go to tbw-exit.
           Display "start > tbw-key "  fs-file-status
           Go to tbw-exit.
      *
       tbw-Start-Alternate.
           Display "start >= tbw-alt".
           Start tbw
               key is not less than tbw-alt
               invalid key
      *>Inspect! Display "start >= tbw-alt inv"
                 Display "start >= tbw-alt done"
                 Go to tbw-exit
               not invalid
                 Display "start >= tbw-alt done"
                 Go to tbw-exit.
           Display "start >= tbw-alt "  fs-file-status
           Go to tbw-exit.
      *
       tbw-Read-Next.
           Display "read next".
           Read tbw
               next record
               at end
                 Display "read next end"
                 Go to tbw-exit
               not at end
                 Display "read next done"
                 Go to tbw-exit.
           Display "read next "  fs-file-status
           Go to tbw-exit.
      *
       tbw-Write.
           Display "write".
           Write tbw-record
               invalid key
                 Display "write inv"
                 Go to tbw-exit
               not invalid
                 Display "write done"
                 Go to tbw-exit.
           Display "write "  fs-file-status
           Go to tbw-exit.
      *
       tbw-Rewrite.
           Display "rewrite".
           Rewrite tbw-record
               invalid key
                 Display "rewrite inv "  fs-file-status
                 Go to tbw-exit
               not invalid
                 Display "rewrite done " fs-file-status
                 Go to tbw-exit.
           Display "rewrite "  fs-file-status
           Go to tbw-exit.
      *
       tbw-Delete-File.
           If flag-tbw-open
               Perform tbw-Close thru tbw-Close-exit.
           Move "xx" to fs-file-status.
           Display "delete file".
           Delete file tbw.
           Display "delete file done".
           Go to tbw-exit.
      *
       tbw-Close.
           If flag-tbw-open
               Display "close"
               Close tbw
               Display "close done"
               Set flag-tbw-closed to true
           end-if.
       tbw-Close-exit.
           Exit.
       tbw-exit.
           Exit.
])

AT_CHECK([$COMPILE prog.cob ], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[delete file
delete file done
open
open done
start > tbw-key
start > tbw-key inv
read next
read next 46
write
write done
start >= tbw-alt
start >= tbw-alt done
start > tbw-key
start > tbw-key done
read next
read next done
read next
read next end
close
close done
delete file
delete file done
open
open done
start > tbw-key
start > tbw-key inv
read next
read next 46
write
write done
write
write done
start >= tbw-alt
start >= tbw-alt done
read next
read next done
rewrite
rewrite done 00
close
close done
Test completed
], [])

AT_CLEANUP


AT_SETUP([INDEXED sample])
AT_KEYWORDS([runfile optional file status READ WRITE DUPLICATES START UNLOCK COB_SYNC])

# modified version of GC-FAQ: indexing example
# Author: Brian Tiffin, Date:   17-Feb-2009, 28-Jan-2014

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog.cob], [

       identification division.
       program-id. linage.

       environment division.
       configuration section.

       input-output section.
       file-control.
          select optional indexed-file
          assign to "indexed-file.dat"
          status is indexing-status-code
          organization is indexed
          access mode is dynamic
          record key is keyfield of indexing-record
          alternate record key is altkey of indexing-record
              with duplicates
          .

       data division.
       file section.
       fd indexed-file.
       01 indexing-record.
          03 keyfield          pic x(8).
          03 filler            pic x.
          03 altkey.
             05 first-part     pic 99.
             05 middle-part    pic x.
             05 last-part      pic 99.
          03 filler            pic x.
          03 data-part         pic x(18).

       working-storage section.
       01 indexing-status-code pic xx.
       01 indexing-status redefines indexing-status-code pic 99.
          88 indexing-ok       values 0 thru 10.

       78 line-separator       value
           '-----------------------------------------'.
       01 display-record.
          03 filler            pic x(4)  value spaces.
          03 keyfield          pic x(8).
          03 filler            pic xx    value spaces.
          03 altkey.
             05 first-part     pic 99.
             05 filler         pic x     value space.
             05 middle-part    pic x.
             05 filler         pic x     value space.
             05 last-part      pic 99.
          03 filler            pic xx    value ", ".
          03 data-part         pic x(18).
       77 safety-net           pic 99.

      *> control break
       01 oldkey               pic 99x99.

      *> read control fields
       01 duplicate-flag       pic x.
          88 no-more-duplicates          value high-value
             when set to false                 low-value.
       01 record-flag          pic x.
          88 no-more-records             value high-value
             when set to false                 low-value.

      *> ***************************************************************
       procedure division.
       main.
      *> Populate a sample database, create or overwrite keys
           perform populate-sample

      *> clear the record space for this example
           move spaces to indexing-record

      *> open the data file again
           open i-o indexed-file
           perform indexing-check
           if not indexing-ok
             stop run returning 1
           end-if

      *> read all the duplicate 00b02 keys
           move 00 to first-part of indexing-record
           move "b" to middle-part of indexing-record
           move 02 to last-part of indexing-record

      *> using read key and then next key / last key compare
           set no-more-duplicates to false

           display "Read all 00b02 keys sequentially" end-display
           perform read-indexing-record
           perform read-next-record
      *>       this is only here for safety...
               varying safety-net from 1 by 1
               until no-more-duplicates
      *>         s a f e  against broken indexed i/o
                  or safety-net > 40
           if safety-net > 40
               display "Safety kicked in!" end-display
           end-if
           display line-separator end-display

      *> read by key of reference ... the cool stuff
           move 00 to first-part of indexing-record
           move "a" to middle-part of indexing-record
           move 02 to last-part of indexing-record
           set no-more-records to false

      *> using start and read next
           display "Read all alternate keys greater than 00a02"
           end-display
           perform start-at-key
           perform read-next-by-key
      *>       this is only here for safety...
               varying safety-net from 1 by 1
               until no-more-records
      *>         s a f e  against broken indexed i/o
                  or safety-net > 40
           if safety-net > 40
               display "Safety kicked in!" end-display
           end-if
           display line-separator end-display

      *> read by primary key of reference
           move "87654321" to keyfield of indexing-record
           set no-more-records to false

      *> using start and previous by key
           display
               "Read all primary keys less than "
               function trim (keyfield of indexing-record)
           end-display
           perform start-prime-key
           perform read-previous-by-key
      *>       this is only here for safety...
               varying safety-net from 1 by 1
               until no-more-records
      *>         s a f e  against broken indexed i/o
                  or safety-net > 40
           if safety-net > 40
             display "Safety kicked in!" end-display
           end-if
           display line-separator end-display

      *> explicit early file unlock, see bug #533
           unlock indexed-file

      *> and with that we are done with indexing sample
           close indexed-file

           goback
           .
      *> ***************************************************************

      *> ***************************************************************
      *><* read by alternate key paragraph
       read-indexing-record.
           display "Reading: " altkey of indexing-record end-display
           read indexed-file key is altkey of indexing-record
               invalid key
                   display
                       "bad read key: "
                       function trim (altkey of indexing-record)
                       upon syserr
                   end-display
               set no-more-duplicates to true
           end-read
           perform indexing-check
           .

      *><* read next sequential paragraph
       read-next-record.
           move corresponding indexing-record to display-record
           display display-record end-display
           move altkey of indexing-record to oldkey

           read indexed-file next record
               at end set no-more-duplicates to true
               not at end
                   if oldkey not equal altkey of indexing-record
                       set no-more-duplicates to true
                   end-if
           end-read
           perform indexing-check
           .

      *><* start primary key of reference paragraph
       start-prime-key.
           display "Prime < " keyfield of indexing-record end-display
           start indexed-file
              key is less than
                  keyfield of indexing-record
              invalid key
                  display
                      "bad start: "
                      function trim (keyfield of indexing-record)
                      upon syserr
                  end-display
                  set no-more-records to true
              not invalid key
                  read indexed-file previous record
                      at end set no-more-records to true
                  end-read
           end-start
           perform indexing-check
           .

      *><* read previous by key of reference paragraph
       read-previous-by-key.
           move corresponding indexing-record to display-record
           display display-record end-display

           read indexed-file previous record
               at end set no-more-records to true
           end-read
           perform indexing-check
           .
      *><* start alternate key of reference paragraph
       start-at-key.
           display "Seeking >= " altkey of indexing-record end-display
           start indexed-file
              key is greater than or equal to
                  altkey of indexing-record
              invalid key
                  display
                      "bad start: "
                      function trim (altkey of indexing-record)
                      upon syserr
                  end-display
                  set no-more-records to true
              not invalid key
                  read indexed-file next record
                      at end set no-more-records to true
                  end-read
           end-start
           perform indexing-check
           .

      *><* read next by key of reference paragraph
       read-next-by-key.
           move corresponding indexing-record to display-record
           display display-record end-display

           read indexed-file next record
               at end set no-more-records to true
           end-read
           perform indexing-check
           .

      *><* populate a sample database
       populate-sample.

      *> Open optional index file for read write
           open i-o indexed-file
           perform indexing-check

           move "12345678 00a01 some 12345678 data" to indexing-record
           perform write-indexing-record
           move "87654321 00a01 some 87654321 data" to indexing-record
           perform write-indexing-record
           move "12348765 00a01 some 12348765 data" to indexing-record
           perform write-indexing-record
           move "87651234 00a01 some 87651234 data" to indexing-record
           perform write-indexing-record

           move "12345679 00b02 some 12345679 data" to indexing-record
           perform write-indexing-record
           move "97654321 00b02 some 97654321 data" to indexing-record
           perform write-indexing-record
           move "12349765 00b02 some 12349765 data" to indexing-record
           perform write-indexing-record
           move "97651234 00b02 some 97651234 data" to indexing-record
           perform write-indexing-record

           move "12345689 00c13 some 12345689 data" to indexing-record
           perform write-indexing-record
           move "98654321 00c13 some 98654321 data" to indexing-record
           perform write-indexing-record
           move "12349865 00c13 some 12349865 data" to indexing-record
           perform write-indexing-record
           move "98651234 00c13 some 98651234 data" to indexing-record
           perform write-indexing-record

      *> close it ... not necessary, but for the example we will
           close indexed-file
           perform indexing-check
           .

      *><* Write paragraph
       write-indexing-record.
           write indexing-record
               invalid key
                   display
                       "rewriting key: "
                       function trim (keyfield of indexing-record)
                       upon syserr
                   end-display
                   rewrite indexing-record
                       invalid key
                           display
                               "really bad key: "
                             function trim (keyfield of indexing-record)
                               upon syserr
                           end-display
                   end-rewrite
           end-write
           .

      *><* file status quick check.  For this sample, keep running
       indexing-check.
           if not indexing-ok then
               display
                   "isam file io problem: " indexing-status
                   upon syserr
               end-display
           end-if
           .
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([rm -f "indexed-file.*"], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[Read all 00b02 keys sequentially
Reading: 00b02
    12345679  00 b 02, some 12345679 data
    97654321  00 b 02, some 97654321 data
    12349765  00 b 02, some 12349765 data
    97651234  00 b 02, some 97651234 data
-----------------------------------------
Read all alternate keys greater than 00a02
Seeking >= 00a02
    12345679  00 b 02, some 12345679 data
    97654321  00 b 02, some 97654321 data
    12349765  00 b 02, some 12349765 data
    97651234  00 b 02, some 97651234 data
    12345689  00 c 13, some 12345689 data
    98654321  00 c 13, some 98654321 data
    12349865  00 c 13, some 12349865 data
    98651234  00 c 13, some 98651234 data
-----------------------------------------
Read all primary keys less than 87654321
Prime < 87654321
    87651234  00 a 01, some 87651234 data
    12349865  00 c 13, some 12349865 data
    12349765  00 b 02, some 12349765 data
    12348765  00 a 01, some 12348765 data
    12345689  00 c 13, some 12345689 data
    12345679  00 b 02, some 12345679 data
    12345678  00 a 01, some 12345678 data
-----------------------------------------
], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[Read all 00b02 keys sequentially
Reading: 00b02
    12345679  00 b 02, some 12345679 data
    97654321  00 b 02, some 97654321 data
    12349765  00 b 02, some 12349765 data
    97651234  00 b 02, some 97651234 data
-----------------------------------------
Read all alternate keys greater than 00a02
Seeking >= 00a02
    12345679  00 b 02, some 12345679 data
    97654321  00 b 02, some 97654321 data
    12349765  00 b 02, some 12349765 data
    97651234  00 b 02, some 97651234 data
    12345689  00 c 13, some 12345689 data
    98654321  00 c 13, some 98654321 data
    12349865  00 c 13, some 12349865 data
    98651234  00 c 13, some 98651234 data
-----------------------------------------
Read all primary keys less than 87654321
Prime < 87654321
    87651234  00 a 01, some 87651234 data
    12349865  00 c 13, some 12349865 data
    12349765  00 b 02, some 12349765 data
    12348765  00 a 01, some 12348765 data
    12345689  00 c 13, some 12345689 data
    12345679  00 b 02, some 12345679 data
    12345678  00 a 01, some 12345678 data
-----------------------------------------
],
[rewriting key: 12345678
rewriting key: 87654321
rewriting key: 12348765
rewriting key: 87651234
rewriting key: 12345679
rewriting key: 97654321
rewriting key: 12349765
rewriting key: 97651234
rewriting key: 12345689
rewriting key: 98654321
rewriting key: 12349865
rewriting key: 98651234
])

# recheck with COB_SYNC to cover additional code paths - see bug # 753
AT_CHECK([COB_SYNC=Y $COBCRUN_DIRECT ./prog], [0],
[Read all 00b02 keys sequentially
Reading: 00b02
    12345679  00 b 02, some 12345679 data
    97654321  00 b 02, some 97654321 data
    12349765  00 b 02, some 12349765 data
    97651234  00 b 02, some 97651234 data
-----------------------------------------
Read all alternate keys greater than 00a02
Seeking >= 00a02
    12345679  00 b 02, some 12345679 data
    97654321  00 b 02, some 97654321 data
    12349765  00 b 02, some 12349765 data
    97651234  00 b 02, some 97651234 data
    12345689  00 c 13, some 12345689 data
    98654321  00 c 13, some 98654321 data
    12349865  00 c 13, some 12349865 data
    98651234  00 c 13, some 98651234 data
-----------------------------------------
Read all primary keys less than 87654321
Prime < 87654321
    87651234  00 a 01, some 87651234 data
    12349865  00 c 13, some 12349865 data
    12349765  00 b 02, some 12349765 data
    12348765  00 a 01, some 12348765 data
    12345689  00 c 13, some 12345689 data
    12345679  00 b 02, some 12345679 data
    12345678  00 a 01, some 12345678 data
-----------------------------------------
],
[rewriting key: 12345678
rewriting key: 87654321
rewriting key: 12348765
rewriting key: 87651234
rewriting key: 12345679
rewriting key: 97654321
rewriting key: 12349765
rewriting key: 97651234
rewriting key: 12345689
rewriting key: 98654321
rewriting key: 12349865
rewriting key: 98651234
])

AT_CHECK([test "$COB_HAS_ISAM" = "db"], [0], [], [],
# Previous test "failed" --> other ISAM, no need for more checks
[AT_CHECK([true], [0])],

# Previous test "passed" --> using BDB, recheck with DB_HOME set
[AT_CHECK([DB_HOME=. $COBCRUN_DIRECT ./prog], [0],
[Read all 00b02 keys sequentially
Reading: 00b02
    12345679  00 b 02, some 12345679 data
    97654321  00 b 02, some 97654321 data
    12349765  00 b 02, some 12349765 data
    97651234  00 b 02, some 97651234 data
-----------------------------------------
Read all alternate keys greater than 00a02
Seeking >= 00a02
    12345679  00 b 02, some 12345679 data
    97654321  00 b 02, some 97654321 data
    12349765  00 b 02, some 12349765 data
    97651234  00 b 02, some 97651234 data
    12345689  00 c 13, some 12345689 data
    98654321  00 c 13, some 98654321 data
    12349865  00 c 13, some 12349865 data
    98651234  00 c 13, some 98651234 data
-----------------------------------------
Read all primary keys less than 87654321
Prime < 87654321
    87651234  00 a 01, some 87651234 data
    12349865  00 c 13, some 12349865 data
    12349765  00 b 02, some 12349765 data
    12348765  00 a 01, some 12348765 data
    12345689  00 c 13, some 12345689 data
    12345679  00 b 02, some 12345679 data
    12345678  00 a 01, some 12345678 data
-----------------------------------------
],
[rewriting key: 12345678
rewriting key: 87654321
rewriting key: 12348765
rewriting key: 87651234
rewriting key: 12345679
rewriting key: 97654321
rewriting key: 12349765
rewriting key: 97651234
rewriting key: 12345689
rewriting key: 98654321
rewriting key: 12349865
rewriting key: 98651234
])]
)

AT_CLEANUP


AT_SETUP([WRITE + REWRITE FILE name])
AT_KEYWORDS([runfile RELATIVE COB_SYNC])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.

       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT FLATFILE ASSIGN EXTERNAL RELFIX
           ORGANIZATION RELATIVE
           ACCESS IS SEQUENTIAL RELATIVE KEY IS REC-NUM
           FILE STATUS IS CUST-STAT.

           SELECT FLATFILE2 ASSIGN EXTERNAL RELFIX
           ORGANIZATION RELATIVE
           ACCESS IS RANDOM RELATIVE KEY IS REC-NUM
           FILE STATUS IS CUST-STAT.

       DATA  DIVISION.
       FILE SECTION.
       FD  FLATFILE
           BLOCK CONTAINS 5 RECORDS.

       01  TSPFL-RECORD.
           10  CM-CUST-NUM                     PICTURE X(8).
           10  CM-COMPANY                      PICTURE X(25).
           10  CM-DISK                         PICTURE X(8).
           10  CM-NO-TERMINALS                 PICTURE 9(4).

       FD  FLATFILE2
           BLOCK CONTAINS 5 RECORDS.

       01  TSP2-RECORD.
           10  C2-CUST-NUM                     PICTURE X(8).
           10  C2-COMPANY                      PICTURE X(25).
           10  C2-DISK                         PICTURE X(8).
           10  C2-NO-TERMINALS                 PICTURE 9(4).

       WORKING-STORAGE SECTION.

       78  MAX-SUB           VALUE  6.
       77  CUST-STAT                           PICTURE X(2).
       77  REC-NUM           VALUE  1          BINARY-SHORT UNSIGNED.

       01  TEST-DATA.

         02  DATA-CUST-NUM-TBL.

           05  FILLER PIC X(8) VALUE "ALP00000".
           05  FILLER PIC X(8) VALUE "BET00000".
           05  FILLER PIC X(8) VALUE "DEL00000".
           05  FILLER PIC X(8) VALUE "EPS00000".
           05  FILLER PIC X(8) VALUE "FOR00000".
           05  FILLER PIC X(8) VALUE "GAM00000".

         02  DATA-CUST-NUM REDEFINES DATA-CUST-NUM-TBL
                                       PIC X(8) OCCURS MAX-SUB.
         02  DATA-COMPANY-TBL.

           05  FILLER PIC X(25) VALUE "ALPHA ELECTRICAL CO. LTD.".
           05  FILLER PIC X(25) VALUE "BETA SHOE MFG. INC.      ".
           05  FILLER PIC X(25) VALUE "DELTA LUGGAGE REPAIRS    ".
           05  FILLER PIC X(25) VALUE "EPSILON EQUIPMENT SUPPLY ".
           05  FILLER PIC X(25) VALUE "FORTUNE COOKIE COMPANY   ".
           05  FILLER PIC X(25) VALUE "GAMMA X-RAY TECHNOLOGY   ".
         02  DATA-COMPANY  REDEFINES DATA-COMPANY-TBL
                                       PIC X(25) OCCURS MAX-SUB.
         02  DATA-ADDRESS-2-TBL.

           05  FILLER PIC X(10) VALUE "ATLANTA   ".
           05  FILLER PIC X(10) VALUE "CALGARY   ".
           05  FILLER PIC X(10) VALUE "NEW YORK  ".
           05  FILLER PIC X(10) VALUE "TORONTO   ".
           05  FILLER PIC X(10) VALUE "WASHINGTON".
           05  FILLER PIC X(10) VALUE "WHITEPLAIN".
         02  DATA-ADDRESS   REDEFINES DATA-ADDRESS-2-TBL
                                       PIC X(10) OCCURS MAX-SUB.

         02  DATA-NO-TERMINALS-TBL.

           05  FILLER PIC 9(3) COMP-3 VALUE 10.
           05  FILLER PIC 9(3) COMP-3 VALUE 13.
           05  FILLER PIC 9(3) COMP-3 VALUE 75.
           05  FILLER PIC 9(3) COMP-3 VALUE 10.
           05  FILLER PIC 9(3) COMP-3 VALUE 90.
           05  FILLER PIC 9(3) COMP-3 VALUE 254.

         02  DATA-NO-TERMINALS REDEFINES DATA-NO-TERMINALS-TBL
                                       PIC 9(3) COMP-3 OCCURS MAX-SUB.
       01  WORK-AREA.
           05  SUB                             BINARY-SHORT UNSIGNED.
               88  ODD-RECORD                  VALUE 1 3 5.


       PROCEDURE DIVISION.

           PERFORM LOADFILE.

           OPEN I-O FLATFILE2.
           MOVE 2 TO REC-NUM
           READ FLATFILE2
           DISPLAY "Read    " C2-CUST-NUM " Sts:" CUST-STAT
                   " Trms:" C2-NO-TERMINALS.
           ADD 1 TO C2-NO-TERMINALS
           REWRITE FILE FLATFILE2 FROM TSP2-RECORD
           READ FLATFILE2
           DISPLAY "REWROTE " C2-CUST-NUM " Sts:" CUST-STAT
                   " Trms:" C2-NO-TERMINALS.
           CLOSE FLATFILE2.
           STOP RUN.

       LOADFILE.
           DISPLAY "Loading sample program data file."
                            UPON CONSOLE.

           OPEN OUTPUT FLATFILE.

           PERFORM LOAD-RECORD
                        VARYING SUB FROM 1 BY 1
                          UNTIL SUB > MAX-SUB.

           DISPLAY "Sample program data file load complete."
                            UPON CONSOLE.
           CLOSE FLATFILE.

       LOAD-RECORD.

           MOVE SPACES                       TO TSPFL-RECORD.
           MOVE DATA-CUST-NUM      (SUB)     TO CM-CUST-NUM.
           MOVE DATA-COMPANY       (SUB)     TO CM-COMPANY.
           MOVE DATA-NO-TERMINALS  (SUB)     TO CM-NO-TERMINALS.
           IF  ODD-RECORD
               MOVE "8417"                   TO CM-DISK
           ELSE
               MOVE "8470"                   TO CM-DISK.
           WRITE FILE FLATFILE FROM TSPFL-RECORD.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[Loading sample program data file.
Sample program data file load complete.
Read    BET00000 Sts:00 Trms:0013
REWROTE BET00000 Sts:00 Trms:0014
], [])

# recheck with COB_SYNC to cover additional code paths
AT_CHECK([COB_SYNC=Y $COBCRUN_DIRECT ./prog], [0],
[Loading sample program data file.
Sample program data file load complete.
Read    BET00000 Sts:00 Trms:0013
REWROTE BET00000 Sts:00 Trms:0014
], [])

AT_CLEANUP


AT_SETUP([START RELATIVE (1)])
AT_KEYWORDS([fundamental runfile DELETE FILE])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT OPTIONAL TEST-FILE
              ASSIGN      "TESTFILE"
              ACCESS       DYNAMIC
              ORGANIZATION RELATIVE
              STATUS       TESTSTAT
              RELATIVE KEY TESTKEY
       .
       DATA             DIVISION.
       FILE             SECTION.
       FD  TEST-FILE.
       01  TEST-REC     PIC X(4).
       WORKING-STORAGE  SECTION.
       01  TESTKEY      USAGE BINARY-LONG UNSIGNED.
       01  TESTSTAT     PIC XX.
           88  V-OK     VALUE "00" "05".
       PROCEDURE        DIVISION.
           DELETE FILE TEST-FILE.
           OPEN  I-O   TEST-FILE.
           IF NOT V-OK
              DISPLAY "OPEN " TESTSTAT
              END-DISPLAY
              GOBACK
           END-IF.
           MOVE 99 TO TESTKEY.
           START TEST-FILE KEY < TESTKEY
           END-START.
           IF TESTSTAT NOT = "23"
              DISPLAY "START " TESTSTAT
              END-DISPLAY
           END-IF.
           CLOSE TEST-FILE.
       END PROGRAM prog.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([START RELATIVE (2)])
AT_KEYWORDS([fundamental runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT OPTIONAL TEST-FILE
              ASSIGN      "TESTFILE"
              ACCESS       DYNAMIC
              ORGANIZATION RELATIVE
              STATUS       TESTSTAT
              RELATIVE KEY TESTKEY
       .
       DATA             DIVISION.
       FILE             SECTION.
       FD  TEST-FILE.
       01  TEST-REC     PIC X(4).
       WORKING-STORAGE  SECTION.
       01  TESTKEY      USAGE BINARY-LONG UNSIGNED.
       01  TESTSTAT     PIC XX.
           88  V-OK     VALUE "00" "05".
           88  V-ZERO   VALUE "00".
       PROCEDURE        DIVISION.
           OPEN  I-O   TEST-FILE.
           IF NOT V-OK
              DISPLAY "OPEN " TESTSTAT
              END-DISPLAY
              GOBACK
           END-IF.
           MOVE 3 TO TESTKEY.
           MOVE "0003" TO TEST-REC.
           WRITE TEST-REC INVALID KEY
                 DISPLAY "WRITE " TESTSTAT
                 END-DISPLAY
           END-WRITE.
           MOVE 2 TO TESTKEY.
           MOVE "0002" TO TEST-REC.
           WRITE TEST-REC INVALID KEY
                 DISPLAY "WRITE " TESTSTAT
                 END-DISPLAY
           END-WRITE.
           MOVE 99 TO TESTKEY.
           START TEST-FILE KEY < TESTKEY
           END-START.
           IF NOT V-ZERO
              DISPLAY "START " TESTSTAT
              END-DISPLAY
           END-IF.
           IF TESTKEY NOT = 99
              DISPLAY "TESTKEY " TESTKEY
              END-DISPLAY
           END-IF.
           MOVE  SPACE TO TEST-REC.
           READ  TEST-FILE NEXT
           END-READ.
           IF NOT V-ZERO
              DISPLAY "READ " TESTSTAT
              END-DISPLAY
           END-IF.
           IF TEST-REC NOT = "0003"
              DISPLAY "READ RECORD " TEST-REC
              END-DISPLAY
           END-IF.
           CLOSE TEST-FILE.
       END PROGRAM prog.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([START RELATIVE (3)])
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
       SELECT file1 ASSIGN TO DISK
                    ORGANIZATION RELATIVE
                    ACCESS DYNAMIC RELATIVE KEY file1-key.
       DATA DIVISION.
       FILE SECTION.
       FD file1.
       1  file1-rec pic 999.
       WORKING-STORAGE SECTION.
       77  file1-key pic 9(6).
       PROCEDURE DIVISION.
          OPEN OUTPUT file1.
          CLOSE file1.
          OPEN I-O file1.
          MOVE 10 TO file1-key file1-rec.
          WRITE file1-rec.
          MOVE 11 TO file1-key file1-rec.
          WRITE file1-rec.
          MOVE 12 TO file1-key file1-rec.
          WRITE file1-rec.
          MOVE 13 TO file1-key file1-rec.
          WRITE file1-rec.
      *
          MOVE 0 TO file1-key.
          START file1 KEY > file1-key.
          READ file1 NEXT.
          IF (file1-rec <> 10)
             DISPLAY "FAILED: START key > 0".
      *
          MOVE 99 TO file1-key.
          START file1 KEY < file1-key.
          READ file1 NEXT.
          IF (file1-rec <> 13)
             DISPLAY "FAILED: START key < 99".
      *
          MOVE 0 TO file1-key.
          START file1 FIRST.
          READ file1 NEXT.
          IF (file1-rec <> 10)
             DISPLAY "FAILED: START key FIRST".
      *
          MOVE 0 TO file1-key.
          START file1 LAST.
          READ file1 NEXT.
          IF (file1-rec <> 13)
             DISPLAY "FAILED: START key LAST".
      *
          MOVE 0 TO file1-key.
          START file1 KEY >= file1-key.
          READ file1 NEXT.
          IF (file1-rec <> 10)
             DISPLAY "FAILED: START key >= 0".
      *
          MOVE 99 TO file1-key.
          START file1 KEY <= file1-key.
          READ file1 NEXT.
          IF (file1-rec <> 13)
             DISPLAY "FAILED: START key <= 99".
      *
          CLOSE file1.
          STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_CLEANUP


AT_SETUP([READ on OPTIONAL missing RELATIVE / SEQUENTIAL])
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT OPTIONAL INFILE  ASSIGN TO
                "missing.txt"
                ORGANIZATION IS RELATIVE
                ACCESS IS SEQUENTIAL
                FILE STATUS IS WSFS.
           SELECT OPTIONAL INFILES ASSIGN TO
                "missings.txt"
                ORGANIZATION IS SEQUENTIAL
                ACCESS IS SEQUENTIAL
                FILE STATUS IS WSFS.
       DATA DIVISION.
       FILE SECTION.
       FD  INFILE.
       01  INREC             PIC X(80).
       FD  INFILES.
       01  INRECS            PIC X(80).
       WORKING-STORAGE SECTION.
       01  WSFS           PIC X(2).
           88  RECORDFOUND VALUE "00".
       01  WSINREC         PIC X(80).
       PROCEDURE DIVISION.
       MAIN-PROCEDURE.
      *    Open missing file
           OPEN INPUT INFILE
           DISPLAY "R: OPEN INPUT on missing optional file = " WSFS " "
                    NO ADVANCING
           IF WSFS = '05'
              DISPLAY "OK"
           ELSE
              DISPLAY "Bad"
           END-IF.
           OPEN INPUT INFILES
           DISPLAY "S: OPEN INPUT on missing optional file = " WSFS " "
                    NO ADVANCING
           IF WSFS = '05'
              DISPLAY "OK"
           ELSE
              DISPLAY "Bad"
           END-IF.
      *    First read, raise a FS 10 (AT END) which is expected
           READ INFILE INTO WSINREC
           DISPLAY "R: 1st READ on missing optional file = " WSFS " "
                    NO ADVANCING
           IF WSFS = '10'
              DISPLAY "OK"
           ELSE
              DISPLAY "Bad"
           END-IF.
           READ INFILES INTO WSINREC
           DISPLAY "S: 1st READ on missing optional file = " WSFS " "
                    NO ADVANCING
           IF WSFS = '10'
              DISPLAY "OK"
           ELSE
              DISPLAY "Bad"
           END-IF.

      *    Second read, should raise a FS 46 (READ AFTER AT END).
           READ INFILE INTO WSINREC
           DISPLAY "R: 2nd READ on missing optional file = " WSFS " "
                    NO ADVANCING
           IF WSFS = '46'
              DISPLAY "OK"
           ELSE
              DISPLAY "Bad"
           END-IF.
           READ INFILES INTO WSINREC
           DISPLAY "S: 2nd READ on missing optional file = " WSFS " "
                    NO ADVANCING
           IF WSFS = '46'
              DISPLAY "OK"
           ELSE
              DISPLAY "Bad"
           END-IF.
           READ INFILE
           DISPLAY "R: 3rd READ on missing optional file = " WSFS " "
                    NO ADVANCING
           IF WSFS = '46'
              DISPLAY "OK"
           ELSE
              DISPLAY "Bad"
           END-IF.
           READ INFILES
           DISPLAY "S: 3rd READ on missing optional file = " WSFS " "
                    NO ADVANCING
           IF WSFS = '46'
              DISPLAY "OK"
           ELSE
              DISPLAY "Bad"
           END-IF.

           CLOSE INFILE
           CLOSE INFILES
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[R: OPEN INPUT on missing optional file = 05 OK
S: OPEN INPUT on missing optional file = 05 OK
R: 1st READ on missing optional file = 10 OK
S: 1st READ on missing optional file = 10 OK
R: 2nd READ on missing optional file = 46 OK
S: 2nd READ on missing optional file = 46 OK
R: 3rd READ on missing optional file = 46 OK
S: 3rd READ on missing optional file = 46 OK
], [])

AT_CLEANUP


AT_SETUP([READ on OPTIONAL missing INDEXED file])
AT_KEYWORDS([runfile])

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.

       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT OPTIONAL file1 ASSIGN "fileX"
               ORGANIZATION IS INDEXED
               RECORD KEY IS file1-key
               STATUS f-status.

       DATA DIVISION.
       FILE SECTION.
       FD  file1.
       01  file1-key PIC X.

       WORKING-STORAGE SECTION.
       01  f-status PIC XX.

       PROCEDURE DIVISION.
           DELETE FILE file1.
           OPEN INPUT file1.
           IF (f-status <> "05")
               DISPLAY "FAILED OPEN: fs=" f-status
           END-IF
           READ file1
               AT END
                   IF (f-status <> "10")
                       DISPLAY "FAILED READ AT END: fs=" f-status
                   END-IF

               NOT AT END
                   DISPLAY "FAILED READ NO AT END: status " f-status
           END-READ
           CLOSE file1
           .
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([EXTERNAL RELATIVE file])
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.

       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT my-file
               ASSIGN TO "somefile"
               ORGANIZATION IS RELATIVE
               RELATIVE KEY IS my-key.

       DATA DIVISION.
       FILE SECTION.
       FD my-file EXTERNAL.
       01 my-record.
           03 my-record-data PIC X(80).

       WORKING-STORAGE SECTION.
       01  my-key PIC 9.

       PROCEDURE DIVISION.
           OPEN OUTPUT my-file
           MOVE 'testme' TO my-record
           CALL 'prog2'
           CLOSE my-file
           GOBACK.
])

AT_DATA([prog2.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog2.

       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT my-file
               ASSIGN TO "somefile"
               ORGANIZATION IS RELATIVE
               RELATIVE KEY IS my-key.

       DATA DIVISION.
       FILE SECTION.
       FD my-file EXTERNAL.
       01 two-record    PIC X(80).

       WORKING-STORAGE SECTION.
       01  my-key PIC 9.

       PROCEDURE DIVISION.
           WRITE two-record
           GOBACK.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COMPILE_MODULE prog2.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([DECLARATIVES procedure referencing])
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT TEST-FILE ASSIGN "./TEST-FILE".
       DATA             DIVISION.
       FILE             SECTION.
       FD TEST-FILE.
       01 TEST-REC      PIC X(10).
       WORKING-STORAGE  SECTION.
       01 Z             USAGE BINARY-LONG VALUE 0.
       PROCEDURE        DIVISION.
       DECLARATIVES.
       P01 SECTION.
           USE AFTER ERROR PROCEDURE ON TEST-FILE.
       P0101.
           ADD 1 TO Z.
       END DECLARATIVES.
      * some comments here
      * to mimic real world programs
       MP01 SECTION.
       MP0101.
           OPEN INPUT TEST-FILE.
           PERFORM P0101.
           IF Z NOT = 2
              DISPLAY Z.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([DECLARATIVES procedure referencing (multiple)])
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT TEST-FILE ASSIGN "./TEST-FILE".
       DATA             DIVISION.
       FILE             SECTION.
       FD TEST-FILE.
       01 TEST-REC      PIC X(10).
       WORKING-STORAGE  SECTION.
       01 Z             USAGE BINARY-LONG VALUE 0.
       PROCEDURE        DIVISION.
       DECLARATIVES.
       P01 SECTION.
           USE AFTER ERROR PROCEDURE ON TEST-FILE.
       P0101.
           ADD 1 TO Z.
       P02 SECTION.
           USE AFTER ERROR PROCEDURE ON OUTPUT.
       P0201.
           ADD 1 TO Z.
       END DECLARATIVES.
       MP01 SECTION.
       MP0101.
           OPEN  INPUT  TEST-FILE.
           PERFORM P01 THRU P02.
           IF Z NOT = 3
              DISPLAY Z.
           GOBACK.
])

# disabling the check for "something leaves the section" - as this is
# guaranteed to happen with this PERFORM THROUGH
AT_CHECK([$COMPILE -fno-section-exit-check prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([System routines for directories (1)])
AT_KEYWORDS([extensions runfile CBL_CREATE_DIR CBL_CHANGE_DIR CBL_DELETE_DIR])

AT_DATA([prog.cob], [
        IDENTIFICATION DIVISION.
        PROGRAM-ID. prog.
        DATA DIVISION.
        WORKING-STORAGE SECTION.
        01 DIR PIC X(4) VALUE 'ABCD'.

        PROCEDURE DIVISION.
        CALL 'CBL_CREATE_DIR' USING DIR END-CALL
        IF RETURN-CODE NOT = 0
            DISPLAY 'error creating dir ...' END-DISPLAY
        END-IF

        CALL 'CBL_CHANGE_DIR' USING DIR END-CALL
        IF RETURN-CODE NOT = 0
            DISPLAY 'error changing dir ...' END-DISPLAY
        END-IF

        CALL 'CBL_CHANGE_DIR' USING '..' END-CALL
        IF RETURN-CODE NOT = 0
            DISPLAY 'error changing dir up ...' END-DISPLAY
        END-IF

        CALL 'CBL_DELETE_DIR' USING DIR END-CALL
        IF RETURN-CODE NOT = 0
            DISPLAY 'error deleting dir' END-DISPLAY
        END-IF

        STOP RUN.
])


AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([test -e abcd], [1], [], [])

AT_CLEANUP


AT_SETUP([System routines for directories (2)])
AT_KEYWORDS([runfile extensions
CBL_CREATE_DIR CBL_CREATE_FILE CBL_CLOSE_FILE CBL_CHECK_FILE_EXIST
CBL_DELETE_DIR CBL_PURGE_DIR])

AT_DATA([prog.cob], [
       IDENTIFICATION      DIVISION.
       PROGRAM-ID.         prog.

       DATA                DIVISION.
       WORKING-STORAGE     SECTION.
       01  fh              PIC X(4) COMP-5.
       01  rb              PIC X(8) COMP-X.
       01  cb-bfr          PIC X(4) COMP-X VALUE 16.
       01  w-dirname-1     PIC X(4) VALUE "tmp1".
       01  w-dirname-2     PIC X(9) VALUE "tmp1/tmp2".
       01  w-dirname-3     PIC X(14) VALUE "tmp1/tmp2/tmp3".
       01  w-filename      PIC X(20) VALUE "tmp1/tmp2/tmp3/file1".
       01  w-finfo         PIC X(16).

       PROCEDURE DIVISION.
           CALL "CBL_CREATE_DIR" USING w-dirname-1.
           IF RETURN-CODE <> 0
              DISPLAY "FAILED 1: CBL_CREATE_DIR (res=" RETURN-CODE ")"
           END-IF

           CALL "CBL_CREATE_DIR" USING w-dirname-2.
           IF RETURN-CODE <> 0
              DISPLAY "FAILED 2: CBL_CREATE_DIR (res=" RETURN-CODE ")"
           END-IF

      *    Should fail because directory does NOT exists yet.
           CALL "CBL_CREATE_FILE"
              USING w-filename, 1, 0, 0, fh.
           IF RETURN-CODE <> 35
              DISPLAY "FAILED 3: CBL_CREATE_FILE expected fail (res="
                      RETURN-CODE ")"
              IF RETURN-CODE = ZERO
                 CALL "CBL_CLOSE_FILE" USING fh
              END-IF
           END-IF

           CALL "CBL_CREATE_DIR" USING w-dirname-3.
           IF RETURN-CODE <> 0
              DISPLAY "FAILED 4: CBL_CREATE_DIR (res=" RETURN-CODE ")"
           END-IF

           CALL "CBL_CREATE_FILE"
              USING w-filename, 1, 0, 0, fh.
           IF RETURN-CODE <> 0
              DISPLAY "FAILED 5: CBL_CREATE_FILE (res="
                      RETURN-CODE ")"
           END-IF

           CALL "CBL_CLOSE_FILE" USING fh.
           IF RETURN-CODE <> 0
              DISPLAY "FAILED 6: CBL_CLOSE_FILE (res="
                      RETURN-CODE ")"
           END-IF

           CALL "CBL_CHECK_FILE_EXIST" USING w-filename, w-finfo.
           IF RETURN-CODE <> 0
              DISPLAY "FAILED 7: CBL_CHECK_FILE_EXIST (res="
                      RETURN-CODE ")"
           END-IF


      *    Should fail because directory is NOT empty.
           CALL "CBL_DELETE_DIR" USING w-dirname-1.
           IF RETURN-CODE = 0
              DISPLAY "FAILED 8: CBL_DELETE_DIR EXPECTED TO FAIL"
           END-IF
      ***********************
      * TO-DO: IMPLEMENT CBL_PURGE_DIR? NOT IN MF OR ACU.
      ***********************
      *    Remove all files (including sub-directories) in tmp1
      *    CALL "CBL_PURGE_DIR" USING w-dirname-1.
      *    IF RETURN-CODE <> 0
      *        DISPLAY "FAILED 9: CBL_PURGE_DIR (res=" RETURN-CODE ")"
      *  END-IF
      *
      *     Should succeed because directory is NOW empty.
      *     CALL "CBL_DELETE_DIR" USING w-dirname-1.
      *     IF RETURN-CODE <> 0
      *         DISPLAY "FAILED 10: CBL_DELETE_DIR (res=" RETURN-CODE ")"
      *     END-IF

           STOP RUN NORMAL
           .
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([System routines for files])
AT_KEYWORDS([extensions runfile CBL_CREATE_FILE CBL_WRITE_FILE CBL_FLUSH_FILE
CBL_OPEN_FILE CBL_READ_FILE CBL_CLOSE_FILE CBL_RENAME_FILE CBL_DELETE_FILE
C$DELETE])

AT_DATA([file1], [
dummy
])
AT_DATA([file2], [
test
])
AT_DATA([file3], [
data
])

AT_DATA([prog.cob], [
        IDENTIFICATION DIVISION.
        PROGRAM-ID.     prog.
        DATA DIVISION.
        WORKING-STORAGE SECTION.
        01 FNAME        PIC X(256) VALUE 'testtext.txt'.
        01 ACCESS-MODE  PIC X      USAGE COMP-X VALUE 2.
        01 FHANDLE      PIC X(4)   USAGE COMP-X.

        01 OFFSET       PIC X(8)   USAGE COMP-X.
        01 NBYTES       PIC X(4)   USAGE COMP-X.
        01 WRITE-BUFFER PIC X(20).

        PROCEDURE DIVISION.
        CALL 'CBL_CREATE_FILE' USING FNAME 55 11 22 FHANDLE
        END-CALL
        IF RETURN-CODE NOT = -1
           DISPLAY 'Wrong return codes ...' END-DISPLAY
        END-IF
        MOVE 0 TO RETURN-CODE

        CALL 'CBL_CREATE_FILE' USING
        FNAME ACCESS-MODE 0 0 FHANDLE
        END-CALL
        IF RETURN-CODE NOT = 0
           DISPLAY 'error creating file ...' END-DISPLAY
           MOVE 0 TO RETURN-CODE
        END-IF

        MOVE 'TestText.ABCD' TO WRITE-BUFFER.
        MOVE 0 TO OFFSET.
        MOVE 9 TO NBYTES.

        CALL 'CBL_WRITE_FILE' USING
        FHANDLE OFFSET NBYTES '0' WRITE-BUFFER
        END-CALL
        IF RETURN-CODE NOT = 0
           DISPLAY 'error writing file ...' END-DISPLAY
           MOVE 0 TO RETURN-CODE
        END-IF

        CALL 'CBL_FLUSH_FILE' USING FHANDLE END-CALL
        IF RETURN-CODE NOT = 0
           DISPLAY 'error flushing file ...' END-DISPLAY
           MOVE 0 TO RETURN-CODE
        END-IF

        CALL 'CBL_CLOSE_FILE' USING FHANDLE END-CALL
        IF RETURN-CODE NOT = 0
           DISPLAY 'error closing file ...' END-DISPLAY
           MOVE 0 TO RETURN-CODE
        END-IF

        STOP RUN.
])

AT_DATA([prog2.cob], [
        IDENTIFICATION DIVISION.
        PROGRAM-ID.     prog2.
        DATA DIVISION.
        WORKING-STORAGE SECTION.
        01 FNAME        PIC X(256) VALUE 'testtext.txt'.
        01 RET          PIC -9.
        01 FHANDLE      PIC X(4)   USAGE COMP-X.

        01 OFFSET       PIC X(8)   USAGE COMP-X.
        01 NBYTES       PIC X(4)   USAGE COMP-X.
        01 READ-BUFFER  PIC X(10).

        PROCEDURE DIVISION.
        CALL 'CBL_OPEN_FILE' USING FNAME 1 0 0 FHANDLE
        END-CALL
        IF RETURN-CODE NOT = 0
           DISPLAY 'error opening file ...' END-DISPLAY
           GOBACK
        END-IF

        CALL 'CBL_READ_FILE' USING
        FHANDLE OFFSET NBYTES 128 READ-BUFFER
        END-CALL
        IF RETURN-CODE NOT = 0
           DISPLAY 'error getting file size...'
                   return-code
           END-DISPLAY
           MOVE 0 TO RETURN-CODE
        END-IF
        IF OFFSET NOT = 9 *> size written in the first test
           DISPLAY 'Wrong size: ' offset END-DISPLAY
           *> still go on with the explicit size
        ELSE
           *> recheck with unexpected parms:
           MOVE 'baddy' to offset(1:)
           CALL 'CBL_READ_FILE' USING
           FHANDLE OFFSET 0 128 NULL
           END-CALL
           IF RETURN-CODE NOT = 0 or OFFSET NOT = 9
              DISPLAY 'bad handling bad parms '
                      'size: ' offset  ' return: ' return-code
              END-DISPLAY
              MOVE 0 TO RETURN-CODE
           END-IF
        END-IF

        MOVE SPACES TO READ-BUFFER.
        MOVE 2 TO OFFSET.
        MOVE 9 TO NBYTES.

        CALL 'CBL_READ_FILE' USING
        FHANDLE OFFSET NBYTES 0 READ-BUFFER
        END-CALL
        IF RETURN-CODE NOT = 0
           DISPLAY 'error reading file ...'
                   return-code
           END-DISPLAY
           MOVE 0 TO RETURN-CODE
        END-IF
        IF READ-BUFFER NOT = 'stText.' *> text from first test
           DISPLAY 'Wrong readbuffer ...' END-DISPLAY
        END-IF

        CALL 'CBL_CLOSE_FILE' USING FHANDLE END-CALL
        IF RETURN-CODE NOT = 0
           DISPLAY 'error closing file ...'
                   return-code
           END-DISPLAY
           MOVE 0 TO RETURN-CODE
        END-IF

        CALL 'CBL_RENAME_FILE' USING FNAME 'foo.txt' END-CALL
        IF RETURN-CODE NOT = 0
           DISPLAY 'error renaming file ...'
                   return-code
           END-DISPLAY
           MOVE 0 TO RETURN-CODE
        END-IF

        CALL 'CBL_DELETE_FILE' USING 'file1' END-CALL
        IF RETURN-CODE NOT = 0
           DISPLAY 'error deleting file1 ...'
                   return-code
           END-DISPLAY
           MOVE 0 TO RETURN-CODE
        END-IF
        CALL 'CBL_DELETE_FILE' USING 'file1' END-CALL
        IF RETURN-CODE = 0
           DISPLAY 'no error on deleting file1 for the second time...'
                   return-code
           END-DISPLAY
        END-IF
        MOVE 0 TO RETURN-CODE

        CALL 'C$DELETE' USING 'file2' 'S' END-CALL
        IF RETURN-CODE NOT = 0
           DISPLAY 'error deleting file2 ...'
                   return-code
           END-DISPLAY
           MOVE 0 TO RETURN-CODE
        END-IF
        CALL 'CBL_DELETE_FILE' USING 'file2' END-CALL
        IF RETURN-CODE = 0   *> note: should only return 0 or 1 when in ACUCOBOL mode
           DISPLAY 'no error on deleting file2 for the second time...'
                   return-code
           END-DISPLAY
        END-IF
        MOVE 0 TO RETURN-CODE

        STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [],
[libcob: prog.cob:15: warning: call to CBL_CREATE_FILE with wrong file_lock: 11
libcob: prog.cob:15: warning: call to CBL_CREATE_FILE with wrong file_dev: 22
libcob: prog.cob:15: warning: call to CBL_OPEN_FILE with wrong access mode: 55
])

AT_CHECK([$COMPILE prog2.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog2], [0], [], [])

AT_CLEANUP


AT_SETUP([System routines for files - filename mapping])
AT_KEYWORDS([extensions runfile CBL_OPEN_FILE CBL_CLOSE_FILE])

AT_DATA([prog.cob], [
        IDENTIFICATION DIVISION.
        PROGRAM-ID.     prog.
        DATA DIVISION.
        WORKING-STORAGE SECTION.
        01 FNAME        PIC X(256).
        01 RET          PIC -9.
        01 FHANDLE      PIC X(4)   USAGE COMP-X.

        01 OFFSET       PIC X(8)   USAGE COMP-X.
        01 NBYTES       PIC X(4)   USAGE COMP-X.
        01 READ-BUFFER  PIC X(10).

        PROCEDURE DIVISION CHAINING FNAME.
        DISPLAY 'RUN WITH ' FUNCTION TRIM (FNAME TRAILING).
        CALL 'CBL_OPEN_FILE' USING FNAME 1 0 0 FHANDLE.
        IF RETURN-CODE NOT = 0
           DISPLAY 'error opening file ...'
           MOVE 0 TO RETURN-CODE
           STOP RUN.

        CALL 'CBL_CLOSE_FILE' USING FHANDLE.
        IF RETURN-CODE NOT = 0
           DISPLAY 'error closing file ...'
                   return-code
           MOVE 0 TO RETURN-CODE.

        STOP RUN.
])

AT_CHECK([mkdir -p sub], [0], [], [])
AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog notthere], [0],
[RUN WITH notthere
error opening file ...
], [])
AT_CHECK([$COBCRUN_DIRECT ./prog prog.cob], [0],
[RUN WITH prog.cob
], [])
AT_CHECK([$COBCRUN_DIRECT ./prog ./prog.cob], [0],
[RUN WITH ./prog.cob
], [])
# the first part is resolved by DD_var and dd_var
AT_CHECK([DD_dot="." dd_dot="A" dot="B"  $COBCRUN_DIRECT ./prog 'dot/prog.cob'], [0],
[RUN WITH dot/prog.cob
], [])
# MinGW and other Win32 builds would fail this - because "getenv is not case sensitive"
# note: does not apply to cygwin; "AAA" wins over "aaa"
if test "$PATHSEP" != ";"; then
   AT_CHECK([DD_dot="" dd_dot="." dot="A"  $COBCRUN_DIRECT ./prog 'dot/prog.cob'], [0],
   [RUN WITH dot/prog.cob
], [])
fi
# MF would say (ignore for now as this conflicts with ACUCOBOL) don't resolve by $
# as it does not start with $:
#AT_CHECK([DD_dot="" dd_dot="" dot="." $COBCRUN_DIRECT ./prog 'dot/prog.cob'], [0],
#[RUN WITH dot/prog.cob
#error opening file ...
#], [])
AT_CHECK([DD_dot="" dd_dot="" dot="." $COBCRUN_DIRECT ./prog 'dot/prog.cob'], [0],
[RUN WITH dot/prog.cob
], [])
AT_CHECK([DD_dot="" dd_dot="" dot="" $COBCRUN_DIRECT ./prog 'dot/prog.cob'], [0],
[RUN WITH dot/prog.cob
error opening file ...
], [])
# the first part with $  is resolved by DD_var and dd_var and var
AT_CHECK([DD_dot="." dd_dot="" dot=""  $COBCRUN_DIRECT ./prog '$dot/prog.cob'], [0],
[RUN WITH $dot/prog.cob
], [])
# MinGW and other Win32 builds would fail this - because "getenv is not case sensitive"
# note: does not apply to cygwin; "AAA" wins over "aaa"
if test "$PATHSEP" != ";"; then
   AT_CHECK([DD_dot="" dd_dot="." dot=""  $COBCRUN_DIRECT ./prog '$dot/prog.cob'], [0],
   [RUN WITH $dot/prog.cob
], [])
fi
AT_CHECK([DD_dot="" dd_dot="" dot="."  $COBCRUN_DIRECT ./prog '$dot/prog.cob'], [0],
[RUN WITH $dot/prog.cob
], [])
# if a _leading_ $ does not exist it is removed, together with the following slash
# --> should ignore the variable and the first slash
AT_CHECK([DD_dot="" dd_dot="" dot=""  $COBCRUN_DIRECT ./prog '$dot/prog.cob'], [0],
[RUN WITH $dot/prog.cob
], [])
# would _possibly_ fail with MF (their docs do not match their behaviour in any case...)
# but this is by GnuCOBOL design here:
AT_CHECK([DD_dot="" dd_dot="" dot=""  $COBCRUN_DIRECT ./prog '$dot/$dotter/prog.cob'], [0],
[RUN WITH $dot/$dotter/prog.cob
], [])
AT_CHECK([DD_dot="" dd_dot="" dot="dot"  $COBCRUN_DIRECT ./prog '$dot/prog.cob'], [0],
[RUN WITH $dot/prog.cob
error opening file ...
], [])
# should try './prog'
AT_CHECK([DD_prog="A" dd_prog="B" prog="C"  $COBCRUN_DIRECT ./prog './prog.cob'], [0],
[RUN WITH ./prog.cob
], [])
# should try './$prog'
AT_CHECK([DD_prog="" dd_prog="" prog=""  $COBCRUN_DIRECT ./prog './$prog.cob'], [0],
[RUN WITH ./$prog.cob
error opening file ...
], [])
AT_CHECK([$COBCRUN_DIRECT ./prog ../prog.cob], [0],
[RUN WITH ../prog.cob
error opening file ...
], [])
AT_CHECK([$COBCRUN_DIRECT ./prog sub/../prog.cob], [0],
[RUN WITH sub/../prog.cob
], [])

AT_CLEANUP


AT_SETUP([System routine CBL_COPY_FILE])
AT_KEYWORDS([extensions runfile])

AT_DATA([prog.cob], [
        IDENTIFICATION DIVISION.
        PROGRAM-ID. prog.
        DATA DIVISION.
        WORKING-STORAGE SECTION.
        PROCEDURE DIVISION.
        DISPLAY "test" END-DISPLAY
        STOP RUN.
])

AT_DATA([prog2.cob], [
        IDENTIFICATION DIVISION.
        PROGRAM-ID. prog2.
        DATA DIVISION.
        WORKING-STORAGE SECTION.
        01 FILE1 PIC X(8) VALUE 'prog.cob'.
        01 FILE2 PIC X(9) VALUE 'prog3.cob'.

        PROCEDURE DIVISION.
        CALL 'CBL_COPY_FILE' USING
        FILE1 FILE2
        END-CALL
        STOP RUN.
])

AT_CHECK([$COMPILE prog2.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog2], [0], [], [])
AT_CHECK([diff prog.cob prog3.cob], [0], [], [])

AT_CLEANUP


AT_SETUP([Default file external name])
AT_KEYWORDS([runfile])

AT_DATA([fexists_signed.c], [

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <libcob.h>

/*
 * Check file is present and correct by comparing
 * its content to a given signature.
 */
COB_EXT_EXPORT int
fexists_signed (char *fid, char *signature, int signature_size)
{
	char *bfr;
	FILE *f;
	int res = -1;

	f = fopen (fid, "r");
	if (f != NULL) {
		 bfr = (char *) cob_malloc (signature_size);
		 if (1 == fread (bfr, signature_size, 1, f)) {
				if (!memcmp (signature, bfr, signature_size)) {
					 res = 0;
				}
		 }
		 free (bfr);
	}
	return res;
}
])
AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
       SELECT file1 ASSIGN DISK.
       DATA DIVISION.
       FILE SECTION.
       FD file1.
       1  file1-rec.
          2  file1-date pic x(8).
          2  file1-time pic x(8).
       WORKING-STORAGE SECTION.
       77 erc      BINARY-LONG.
       77 rec-size BINARY-LONG VALUE 16.
       PROCEDURE DIVISION.
           ACCEPT file1-date FROM DATE YYYYMMDD.
           ACCEPT file1-time FROM TIME.
           OPEN OUTPUT file1.
           WRITE file1-rec.
           CLOSE file1.
           CALL "fexists_signed" USING
                BY REFERENCE "./file1" file1-rec
                BY VALUE rec-size
                RETURNING erc.
           IF (erc <> 0)
              DISPLAY "FAILED file1".
           STOP RUN.
])

AT_CHECK([$COMPILE_MODULE fexists_signed.c], [0], [], [])
AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([unset COB_FILE_PATH ; ./prog], [0], [], [])

AT_CLEANUP


### TO-DO: Move "ASSIGN expansion" test here.

AT_SETUP([SEQUENTIAL basic I/O])
AT_KEYWORDS([runfile READ WRITE REWRITE COB_SYNC])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
       SELECT file1 ASSIGN DISK ORGANIZATION SEQUENTIAL.
       DATA DIVISION.
       FILE SECTION.
       FD file1.
       1  file1-rec pic x.
       PROCEDURE DIVISION.
           DELETE FILE file1.
           OPEN OUTPUT file1.
           MOVE "A" TO file1-rec.
           WRITE file1-rec.
           CLOSE file1.
           OPEN I-O file1.
           READ file1.
           IF file1-rec <> "A"
              display "FIRST READ FAILED"
           ELSE
              MOVE "X" TO file1-rec
              REWRITE file1-rec.
           CLOSE file1.
           IF file1-rec NOT = "X"
              STOP RUN.
           OPEN INPUT file1.
           READ file1.
           IF file1-rec <> "X"
              display "SECOND READ FAILED".
           CLOSE file1.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
# recheck with COB_SYNC to cover additional code paths
AT_CHECK([COB_SYNC=Y $COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


## LINE SEQUENTIAL


AT_SETUP([LINE SEQUENTIAL basic I/O])
AT_KEYWORDS([runfile READ WRITE REWRITE])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
       SELECT file1 ASSIGN DISK ORGANIZATION LINE SEQUENTIAL.
       SELECT file2 ASSIGN DISK ORGANIZATION LINE SEQUENTIAL.
       DATA DIVISION.
       FILE SECTION.
       FD file1.
       1  file1-rec pic x.
       FD file2.
       1  file2-rec pic xx.
       PROCEDURE DIVISION.
           DELETE FILE file1, file2
           OPEN OUTPUT file1, file2
           MOVE "A" TO file1-rec, file2-rec
           WRITE file1-rec
           WRITE file2-rec
           MOVE " " TO file1-rec, file2-rec
           WRITE file1-rec
           WRITE file2-rec
           WRITE file1-rec FROM "A"
           WRITE file2-rec FROM "AA"
           WRITE file1-rec FROM " "
           WRITE file2-rec FROM " A"
           CLOSE file1, file2
           OPEN INPUT file1, file2
           READ file1
           IF file1-rec NOT = "A"
              display "FAILED 1 file1 - '" file1-rec "'".
           READ file2
           IF file2-rec NOT = "A"
              display "FAILED 1 file2 - '" file2-rec "'".
           READ file1
           IF file1-rec NOT = SPACE
              display "FAILED 2 file1 - '" file1-rec "'".
           READ file2
           IF file2-rec NOT = SPACES
              display "FAILED 2 file2 - '" file2-rec "'".
           READ file1
           IF file1-rec NOT = "A"
              display "FAILED 3 file1 - '" file1-rec "'".
           READ file2
           IF file2-rec NOT = "AA"
              display "FAILED 3 file2 - '" file2-rec "'".
           READ file1
           IF file1-rec NOT = SPACE
              display "FAILED 4 file1 - '" file1-rec "'".
           READ file2
           IF file2-rec NOT = " A"
              display "FAILED 4 file2 - '" file2-rec "'".
           CLOSE file1, file2.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([LINE SEQUENTIAL WRITE AFTER])
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT TEST-FILE ASSIGN       "./TEST-FILE"
                        ORGANIZATION IS LINE SEQUENTIAL.
       DATA             DIVISION.
       FILE             SECTION.
       FD TEST-FILE.
       01 TEST-REC      PIC X(4).
       PROCEDURE        DIVISION.
           OPEN OUTPUT TEST-FILE.
           MOVE "a"    TO TEST-REC.
           WRITE TEST-REC
           END-WRITE.
           MOVE "ab"   TO TEST-REC.
           WRITE TEST-REC AFTER 1 LINES
           END-WRITE.
           MOVE "abc"  TO TEST-REC.
           WRITE TEST-REC BEFORE 2 LINES
           END-WRITE.
           MOVE "abcd" TO TEST-REC.
           WRITE TEST-REC
           END-WRITE.
           CLOSE TEST-FILE.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog])
AT_CHECK([cat TEST-FILE], [0],
[a

ababc

abcd
])

AT_CLEANUP


AT_SETUP([LINE SEQUENTIAL record truncation (1)])
AT_KEYWORDS([runfile extensions READ configuration COB_LS_SPLIT split])

AT_DATA([TEST-FILE],
[a
ab
abc
abcd
abcde
abcdef
])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT TEST-FILE ASSIGN       "./TEST-FILE"
                        ORGANIZATION IS LINE SEQUENTIAL.
       DATA             DIVISION.
       FILE             SECTION.
       FD TEST-FILE.
       01 TEST-REC      PIC X(4).
       PROCEDURE        DIVISION.
           OPEN INPUT TEST-FILE
           PERFORM UNTIL EXIT
              READ TEST-FILE
                  AT END EXIT PERFORM
              END-READ
              DISPLAY "(" TEST-REC ")"
              END-DISPLAY
           END-PERFORM.
           CLOSE TEST-FILE.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[(a   )
(ab  )
(abc )
(abcd)
(abcd)
(e   )
(abcd)
(ef  )
])

AT_DATA([prog2.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog2.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT TEST-FILE ASSIGN       "./TEST-FILE"
                        ORGANIZATION IS LINE SEQUENTIAL
                        STATUS IS    TEST-STATUS.
       DATA             DIVISION.
       FILE             SECTION.
       FD TEST-FILE.
       01 TEST-REC      PIC X(4).
       WORKING-STORAGE  SECTION.
       77 TEST-STATUS   PIC XX.
       PROCEDURE        DIVISION.
           OPEN INPUT TEST-FILE
           PERFORM UNTIL TEST-STATUS (1:1) NOT = '0'
              READ TEST-FILE
              END-READ
              DISPLAY "(" TEST-REC ") " TEST-STATUS
              END-DISPLAY
           END-PERFORM.
           CLOSE TEST-FILE.
           STOP RUN.
])

AT_CHECK([$COMPILE prog2.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog2], [0],
[(a   ) 00
(ab  ) 00
(abc ) 00
(abcd) 00
(abcd) 06
(e   ) 00
(abcd) 06
(ef  ) 00
(ef  ) 10
])

# this one is the actual extension (old OpenCOBOL/GnuCOBOL behaviour)
AT_CHECK([COB_LS_SPLIT=FALSE \
$COBCRUN_DIRECT ./prog2], [0],
[(a   ) 00
(ab  ) 00
(abc ) 00
(abcd) 00
(abcd) 04
(abcd) 04
(abcd) 10
])

AT_CLEANUP


AT_SETUP([LINE SEQUENTIAL record truncation (2)])
AT_KEYWORDS([runfile extensions READ WRITE configuration COB_LS_SPLIT split])

AT_DATA([inp_data],
[Record 1................................X.......
Record 2.....................X
Record 3................................X...
])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT INFILE     ASSIGN TO EXTERNAL INFILE
                ORGANIZATION IS LINE SEQUENTIAL
                FILE STATUS  IS INPUT-STATUS .

           SELECT OUTFILE   ASSIGN TO EXTERNAL OUTFILE
                ORGANIZATION IS LINE SEQUENTIAL
                FILE STATUS  IS INPUT-STATUS .

       DATA DIVISION.
       FILE SECTION.
       FD INFILE
             RECORD IS VARYING IN SIZE FROM 18 TO 40 CHARACTERS
             DEPENDING ON INPUT-LEN
            .
       01  INPUT-REC           PIC X(40).

       FD OUTFILE
             RECORD IS VARYING IN SIZE FROM 18 TO 40 CHARACTERS
             DEPENDING ON INPUT-LEN
            .
       01  OUTPUT-REC          PIC X(40).

       WORKING-STORAGE SECTION.

       01  OUTPUT-FILE         PIC X(19)     VALUE 'TEST-FILE'.
       01  INPUT-FILE          PIC X(19)     VALUE 'TEST-INP'.
       01  INPUT-STATUS        PIC XX.
       01  INPUT-LEN           PIC 999  VALUE 18 .

       PROCEDURE DIVISION.
       A000-BEGIN.
           OPEN INPUT INFILE.
           READ INFILE
           DISPLAY " Read 1: STATUS IS " INPUT-STATUS
                   " LENGTH IS " INPUT-LEN
           DISPLAY "       :" INPUT-REC ":"
           READ INFILE
           DISPLAY " Read 2: STATUS IS " INPUT-STATUS
                   " LENGTH IS " INPUT-LEN
           DISPLAY "       :" INPUT-REC ":"
           MOVE 0 TO INPUT-LEN
           READ INFILE
           DISPLAY " Read 3: STATUS IS " INPUT-STATUS
                   " LENGTH IS " INPUT-LEN
           DISPLAY "       :" INPUT-REC ":"
           MOVE SPACES TO INPUT-REC
           MOVE 0 TO INPUT-LEN
           READ INFILE
           DISPLAY " Read 4: STATUS IS " INPUT-STATUS
                   " LENGTH IS " INPUT-LEN
           IF INPUT-STATUS (1:1) = "0"
               DISPLAY "       :" INPUT-REC ":"
           END-IF
           CLOSE INFILE

           OPEN OUTPUT OUTFILE
           MOVE 9 TO INPUT-LEN
           MOVE "Record 1............." TO OUTPUT-REC
           WRITE OUTPUT-REC
           DISPLAY "Write 1: STATUS IS " INPUT-STATUS
                   " LENGTH IS " INPUT-LEN
                             UPON CONSOLE
           MOVE 64 TO INPUT-LEN
           MOVE ALL '.' TO OUTPUT-REC
           MOVE "Record 2" TO OUTPUT-REC (1:8)
           WRITE OUTPUT-REC
           DISPLAY "Write 2: STATUS IS " INPUT-STATUS
                   " LENGTH IS " INPUT-LEN
                             UPON CONSOLE
           CLOSE OUTFILE
           STOP RUN.
])


AT_CAPTURE_FILE([TEST-FILE])

AT_DATA([reference],
[Record 1.
Record 2................................
])

# normal compile, switched via runtime option
AT_CHECK([$COMPILE prog.cob], [0], [], [])

AT_CHECK([COB_LS_SPLIT=FALSE DD_INFILE=./inp_data OUTFILE=TEST-FILE \
$COBCRUN_DIRECT ./prog], [0],
[ Read 1: STATUS IS 04 LENGTH IS 040
       :Record 1................................:
 Read 2: STATUS IS 00 LENGTH IS 030
       :Record 2.....................X          :
 Read 3: STATUS IS 04 LENGTH IS 040
       :Record 3................................:
 Read 4: STATUS IS 10 LENGTH IS 000
Write 1: STATUS IS 00 LENGTH IS 009
Write 2: STATUS IS 00 LENGTH IS 064
], [])

AT_CHECK([diff reference TEST-FILE], [0], [], [])

# same check with dialect option (4.x feature)
# AT_CHECK([$COMPILE -std=gc31 prog.cob], [0], [], [])
#
# same result, but status 00
# AT_CHECK([DD_INFILE=./inp_data OUTFILE=TEST-FILE \
# $COBCRUN_DIRECT ./prog], [0],
# [ Read 1: STATUS IS 00 LENGTH IS 040
#        :Record 1................................:
#  Read 2: STATUS IS 00 LENGTH IS 030
#        :Record 2.....................X          :
#  Read 3: STATUS IS 00 LENGTH IS 040
#        :Record 3................................:
#  Read 4: STATUS IS 10 LENGTH IS 000
# Write 1: STATUS IS 00 LENGTH IS 009
# Write 2: STATUS IS 00 LENGTH IS 064
# ], [])
#
# AT_CHECK([diff reference TEST-FILE], [0], [], [])

AT_CLEANUP


AT_SETUP([LINE SEQUENTIAL standard record overflow])
AT_KEYWORDS([runfile READ WRITE configuration COB_LS_SPLIT split])

AT_DATA([inp_data],
[Record 1................................X.......
Record 2.....................X
Record 3................................X...
])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT INFILE     ASSIGN TO EXTERNAL INFILE
                ORGANIZATION IS LINE SEQUENTIAL
                FILE STATUS  IS INPUT-STATUS .

           SELECT OUTFILE   ASSIGN TO EXTERNAL OUTFILE
                ORGANIZATION IS LINE SEQUENTIAL
                FILE STATUS  IS INPUT-STATUS .

       DATA DIVISION.
       FILE SECTION.
       FD INFILE
             RECORD IS VARYING IN SIZE FROM 18 TO 40 CHARACTERS
             DEPENDING ON INPUT-LEN
            .
       01  INPUT-REC           PIC X(40).

       FD OUTFILE
             RECORD IS VARYING IN SIZE FROM 18 TO 40 CHARACTERS
             DEPENDING ON INPUT-LEN
            .
       01  OUTPUT-REC          PIC X(40).

       WORKING-STORAGE SECTION.

       01  OUTPUT-FILE         PIC X(19)     VALUE 'TEST-FILE'.
       01  INPUT-FILE          PIC X(19)     VALUE 'TEST-INP'.
       01  INPUT-STATUS        PIC XX.
       01  INPUT-LEN           PIC 999  VALUE 18 .

       PROCEDURE DIVISION.
       A000-BEGIN.
           OPEN INPUT INFILE.
           READ INFILE
           DISPLAY " Read 1: STATUS IS " INPUT-STATUS
                   " LENGTH IS " INPUT-LEN
           DISPLAY "       :" INPUT-REC ":"
           READ INFILE
           DISPLAY " Read 2: STATUS IS " INPUT-STATUS
                   " LENGTH IS " INPUT-LEN
           DISPLAY "       :" INPUT-REC ":"
           MOVE 0 TO INPUT-LEN
           READ INFILE
           DISPLAY " Read 3: STATUS IS " INPUT-STATUS
                   " LENGTH IS " INPUT-LEN
           DISPLAY "       :" INPUT-REC ":"
           MOVE SPACES TO INPUT-REC
           MOVE 0 TO INPUT-LEN
           READ INFILE
           DISPLAY " Read 4: STATUS IS " INPUT-STATUS
                   " LENGTH IS " INPUT-LEN
           IF INPUT-STATUS (1:1) = "0"
               DISPLAY "       :" INPUT-REC ":"
           END-IF
           CLOSE INFILE

           OPEN OUTPUT OUTFILE
           MOVE 9 TO INPUT-LEN
           MOVE "Record 1............." TO OUTPUT-REC
           WRITE OUTPUT-REC
           DISPLAY "Write 1: STATUS IS " INPUT-STATUS
                   " LENGTH IS " INPUT-LEN
                             UPON CONSOLE
           MOVE 64 TO INPUT-LEN
           MOVE ALL '.' TO OUTPUT-REC
           MOVE "Record 2" TO OUTPUT-REC (1:8)
           WRITE OUTPUT-REC
           DISPLAY "Write 2: STATUS IS " INPUT-STATUS
                   " LENGTH IS " INPUT-LEN
                             UPON CONSOLE
           CLOSE OUTFILE
           STOP RUN.
])

AT_CAPTURE_FILE([TEST-FILE])

AT_CHECK([$COMPILE prog.cob], [0], [], [])

AT_CHECK([DD_INFILE=./inp_data OUTFILE=TEST-FILE \
$COBCRUN_DIRECT ./prog], [0],
[ Read 1: STATUS IS 06 LENGTH IS 040
       :Record 1................................:
 Read 2: STATUS IS 00 LENGTH IS 008
       :X.......                                :
 Read 3: STATUS IS 00 LENGTH IS 030
       :Record 2.....................X          :
 Read 4: STATUS IS 06 LENGTH IS 040
       :Record 3................................:
Write 1: STATUS IS 00 LENGTH IS 009
Write 2: STATUS IS 00 LENGTH IS 064
], [])

AT_DATA([reference],
[Record 1.
Record 2................................
])

AT_CHECK([diff reference TEST-FILE], [0], [], [])

# same check with dialect option (4.x feature)
# AT_CHECK([$COMPILE -std=gc31 prog.cob], [0], [], [])
#
# same result because of configuration, but status 00
# AT_CHECK([COB_LS_SPLIT=TRUE DD_INFILE=./inp_data OUTFILE=TEST-FILE \
# $COBCRUN_DIRECT ./prog], [0],
# [ Read 1: STATUS IS 00 LENGTH IS 040
#        :Record 1................................:
#  Read 2: STATUS IS 00 LENGTH IS 008
#        :X.......                                :
#  Read 3: STATUS IS 00 LENGTH IS 030
#        :Record 2.....................X          :
#  Read 4: STATUS IS 00 LENGTH IS 040
#        :Record 3................................:
# Write 1: STATUS IS 00 LENGTH IS 009
# Write 2: STATUS IS 00 LENGTH IS 064
# ], [])
#
# AT_CHECK([diff reference TEST-FILE], [0], [], [])

AT_CLEANUP


AT_SETUP([LINAGE and LINAGE-COUNTER sample])
AT_KEYWORDS([runfile OPTIONAL FILE STATUS READ WRITE END-OF-PAGE LINE SEQUENTIAL
configuration COB_CURRENT_DATE date])

# modified version of GC-FAQ: Example of LINAGE File Descriptor
# Author: Brian Tiffin, Date:   10-July-2008

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           select optional data-file assign to 'prog.cob'
               organization is line sequential
               file status is data-file-status.
           select mini-report assign to "mini-report".

       DATA DIVISION.
       FILE SECTION.
       FD  data-file.
       01  data-record.
           88 endofdata        value high-values.
           02 data-line        pic x(80).
       FD  mini-report
           linage is 16 lines
               with footing at 15
               lines at top 2
               lines at bottom 2.
       01  report-line         pic x(80).

       WORKING-STORAGE SECTION.
       01  command-arguments   pic x(1024).
       01  file-name           pic x(160).
       01  data-file-status    pic xx.
       01  lc                  pic 99.
       01  report-line-blank.
           02 filler           pic x(18) value all "*".
           02 filler           pic x(05) value spaces.
           02 filler           pic x(34)
               VALUE "THIS PAGE INTENTIONALLY LEFT BLANK".
           02 filler           pic x(05) value spaces.
           02 filler           pic x(18) value all "*".
       01  report-line-data.
           02 body-tag         pic 9(6).
           02 line-3           pic x(74).
       01  report-line-header.
           02 filler           pic x(6) VALUE "PAGE: ".
           02 page-no          pic 9999.
           02 filler           pic x(24).
           02 filler           pic x(5) VALUE " LC: ".
           02 header-tag       pic 9(6).
           02 filler           pic x(23).
           02 filler           pic x(6) VALUE "DATE: ".
           02 page-date        pic x(6).

       01  page-count          pic 9999.

       PROCEDURE DIVISION.
       main.
           open input data-file.
           read data-file
               at end
                   display "File open error: " data-file-status
                   stop run
           end-read.

           open output mini-report.

           write report-line
               from report-line-blank
           end-write.

           move 1 to page-count.
           accept page-date from date end-accept.
           move page-count to page-no.
           write report-line
               from report-line-header
               after advancing page
           end-write.

           perform readwrite-loop until endofdata.

           display
               "Normal termination, ending status: "
               data-file-status
           close mini-report.

           close data-file.
           stop run.

      ****************************************************************
       readwrite-loop.
           move data-record to report-line-data
           move linage-counter to body-tag
           write report-line from report-line-data
               end-of-page
                   add 1 to page-count end-add
                   move page-count to page-no
                   move linage-counter to header-tag
                   write report-line from report-line-header
                       after advancing page
                   end-write
           end-write
           read data-file
               at end set endofdata to true
           end-read
           .
])

AT_CAPTURE_FILE([mini-report])
AT_DATA([reference-report], [

******************     THIS PAGE INTENTIONALLY LEFT BLANK     ******************


















PAGE: 0001                         LC: 000000                       DATE: 150206
000001
000002 IDENTIFICATION DIVISION.
000003 PROGRAM-ID. prog.
000004 ENVIRONMENT DIVISION.
000005 INPUT-OUTPUT SECTION.
000006 FILE-CONTROL.
000007     select optional data-file assign to 'prog.cob'
000008         organization is line sequential
000009         file status is data-file-status.
000010     select mini-report assign to "mini-report".
000011
000012 DATA DIVISION.
000013 FILE SECTION.
000014 FD  data-file.





PAGE: 0002                         LC: 000015                       DATE: 150206
000001 01  data-record.
000002     88 endofdata        value high-values.
000003     02 data-line        pic x(80).
000004 FD  mini-report
000005     linage is 16 lines
000006         with footing at 15
000007         lines at top 2
000008         lines at bottom 2.
000009 01  report-line         pic x(80).
000010
000011 WORKING-STORAGE SECTION.
000012 01  command-arguments   pic x(1024).
000013 01  file-name           pic x(160).
000014 01  data-file-status    pic xx.





PAGE: 0003                         LC: 000015                       DATE: 150206
000001 01  lc                  pic 99.
000002 01  report-line-blank.
000003     02 filler           pic x(18) value all "*".
000004     02 filler           pic x(05) value spaces.
000005     02 filler           pic x(34)
000006         VALUE "THIS PAGE INTENTIONALLY LEFT BLANK".
000007     02 filler           pic x(05) value spaces.
000008     02 filler           pic x(18) value all "*".
000009 01  report-line-data.
000010     02 body-tag         pic 9(6).
000011     02 line-3           pic x(74).
000012 01  report-line-header.
000013     02 filler           pic x(6) VALUE "PAGE: ".
000014     02 page-no          pic 9999.





PAGE: 0004                         LC: 000015                       DATE: 150206
000001     02 filler           pic x(24).
000002     02 filler           pic x(5) VALUE " LC: ".
000003     02 header-tag       pic 9(6).
000004     02 filler           pic x(23).
000005     02 filler           pic x(6) VALUE "DATE: ".
000006     02 page-date        pic x(6).
000007
000008 01  page-count          pic 9999.
000009
000010 PROCEDURE DIVISION.
000011 main.
000012     open input data-file.
000013     read data-file
000014         at end





PAGE: 0005                         LC: 000015                       DATE: 150206
000001             display "File open error: " data-file-status
000002             stop run
000003     end-read.
000004
000005     open output mini-report.
000006
000007     write report-line
000008         from report-line-blank
000009     end-write.
000010
000011     move 1 to page-count.
000012     accept page-date from date end-accept.
000013     move page-count to page-no.
000014     write report-line





PAGE: 0006                         LC: 000015                       DATE: 150206
000001         from report-line-header
000002         after advancing page
000003     end-write.
000004
000005     perform readwrite-loop until endofdata.
000006
000007     display
000008         "Normal termination, ending status: "
000009         data-file-status
000010     close mini-report.
000011
000012     close data-file.
000013     stop run.
000014





PAGE: 0007                         LC: 000015                       DATE: 150206
000001****************************************************************
000002 readwrite-loop.
000003     move data-record to report-line-data
000004     move linage-counter to body-tag
000005     write report-line from report-line-data
000006         end-of-page
000007             add 1 to page-count end-add
000008             move page-count to page-no
000009             move linage-counter to header-tag
000010             write report-line from report-line-header
000011                 after advancing page
000012             end-write
000013     end-write
000014     read data-file





PAGE: 0008                         LC: 000015                       DATE: 150206
000001         at end set endofdata to true
000002     end-read
000003     .
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([COB_CURRENT_DATE="2015/02/06 16:40:52" $COBCRUN_DIRECT ./prog], [0],
[Normal termination, ending status: 10
], [])
AT_CHECK([diff mini-report reference-report], [0], [], [])

AT_CLEANUP


AT_SETUP([EXTFH: LINAGE and LINAGE-COUNTER sample])
AT_KEYWORDS([runfile EXTFH OPTIONAL FILE STATUS READ WRITE END-OF-PAGE LINE SEQUENTIAL])

# modified version of the test above

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           select optional data-file assign to 'prog.cob'
               organization is line sequential
               file status is data-file-status.
           select mini-report assign to "mini-report".

       DATA DIVISION.
       FILE SECTION.
       FD  data-file.
       01  data-record.
           88 endofdata        value high-values.
           02 data-line        pic x(80).
       FD  mini-report
           linage is 16 lines
               with footing at 15
               lines at top 2
               lines at bottom 2.
       01  report-line         pic x(80).

       WORKING-STORAGE SECTION.
       01  command-arguments   pic x(1024).
       01  file-name           pic x(160).
       01  data-file-status    pic xx.
       01  lc                  pic 99.
       01  report-line-blank.
           02 filler           pic x(18) value all "*".
           02 filler           pic x(05) value spaces.
           02 filler           pic x(34)
               VALUE "THIS PAGE INTENTIONALLY LEFT BLANK".
           02 filler           pic x(05) value spaces.
           02 filler           pic x(18) value all "*".
       01  report-line-data.
           02 body-tag         pic 9(6).
           02 line-3           pic x(74).
       01  report-line-header.
           02 filler           pic x(6) VALUE "PAGE: ".
           02 page-no          pic 9999.
           02 filler           pic x(24).
           02 filler           pic x(5) VALUE " LC: ".
           02 header-tag       pic 9(6).




       01  page-count          pic 9999.

       PROCEDURE DIVISION.
       main.
           open input data-file.
           read data-file
               at end
                   display "File open error: " data-file-status
                   stop run
           end-read.

           open output mini-report.

           write report-line
               from report-line-blank
           end-write.

           move 1 to page-count.
           move page-count to page-no.
           write report-line
               from report-line-header
               after advancing page
           end-write.

           perform readwrite-loop until endofdata.

           display
               "Normal termination, ending status: "
               data-file-status
           close mini-report.

           close data-file.
           stop run.

      ****************************************************************
       readwrite-loop.
           move data-record to report-line-data
           move linage-counter to body-tag
           write report-line from report-line-data
               end-of-page
                   add 1 to page-count end-add
                   move page-count to page-no
                   move linage-counter to header-tag
                   write report-line from report-line-header
                       after advancing page
                   end-write
           end-write
           read data-file
               at end set endofdata to true
           end-read
           .
])

AT_CAPTURE_FILE([mini-report])
AT_DATA([reference-report], [

******************     THIS PAGE INTENTIONALLY LEFT BLANK     ******************


















PAGE: 0001                         LC: 000000
000001
000002 IDENTIFICATION DIVISION.
000003 PROGRAM-ID. prog.
000004 ENVIRONMENT DIVISION.
000005 INPUT-OUTPUT SECTION.
000006 FILE-CONTROL.
000007     select optional data-file assign to 'prog.cob'
000008         organization is line sequential
000009         file status is data-file-status.
000010     select mini-report assign to "mini-report".
000011
000012 DATA DIVISION.
000013 FILE SECTION.
000014 FD  data-file.





PAGE: 0002                         LC: 000015
000001 01  data-record.
000002     88 endofdata        value high-values.
000003     02 data-line        pic x(80).
000004 FD  mini-report
000005     linage is 16 lines
000006         with footing at 15
000007         lines at top 2
000008         lines at bottom 2.
000009 01  report-line         pic x(80).
000010
000011 WORKING-STORAGE SECTION.
000012 01  command-arguments   pic x(1024).
000013 01  file-name           pic x(160).
000014 01  data-file-status    pic xx.





PAGE: 0003                         LC: 000015
000001 01  lc                  pic 99.
000002 01  report-line-blank.
000003     02 filler           pic x(18) value all "*".
000004     02 filler           pic x(05) value spaces.
000005     02 filler           pic x(34)
000006         VALUE "THIS PAGE INTENTIONALLY LEFT BLANK".
000007     02 filler           pic x(05) value spaces.
000008     02 filler           pic x(18) value all "*".
000009 01  report-line-data.
000010     02 body-tag         pic 9(6).
000011     02 line-3           pic x(74).
000012 01  report-line-header.
000013     02 filler           pic x(6) VALUE "PAGE: ".
000014     02 page-no          pic 9999.





PAGE: 0004                         LC: 000015
000001     02 filler           pic x(24).
000002     02 filler           pic x(5) VALUE " LC: ".
000003     02 header-tag       pic 9(6).
000004
000005
000006
000007
000008 01  page-count          pic 9999.
000009
000010 PROCEDURE DIVISION.
000011 main.
000012     open input data-file.
000013     read data-file
000014         at end





PAGE: 0005                         LC: 000015
000001             display "File open error: " data-file-status
000002             stop run
000003     end-read.
000004
000005     open output mini-report.
000006
000007     write report-line
000008         from report-line-blank
000009     end-write.
000010
000011     move 1 to page-count.
000012     accept page-date from date end-accept.
000013     move page-count to page-no.
000014     write report-line





PAGE: 0006                         LC: 000015
000001         from report-line-header
000002         after advancing page
000003     end-write.
000004
000005     perform readwrite-loop until endofdata.
000006
000007     display
000008         "Normal termination, ending status: "
000009         data-file-status
000010     close mini-report.
000011
000012     close data-file.
000013     stop run.
000014





PAGE: 0007                         LC: 000015
000001****************************************************************
000002 readwrite-loop.
000003     move data-record to report-line-data
000004     move linage-counter to body-tag
000005     write report-line from report-line-data
000006         end-of-page
000007             add 1 to page-count end-add
000008             move page-count to page-no
000009             move linage-counter to header-tag
000010             write report-line from report-line-header
000011                 after advancing page
000012             end-write
000013     end-write
000014     read data-file





PAGE: 0008                         LC: 000015
000001         at end set endofdata to true
000002     end-read
000003     .
])

AT_CHECK([$COMPILE -fcallfh=EXTFH prog.cob], [0], [], [])

# currently does not generate the expected report, as LINAGE options
# are not passed via FCD and the internal part works only "partial"

AT_XFAIL_IF([true])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[Normal termination, ending status: 10
], [])
AT_CHECK([diff mini-report reference-report], [0], [], [])

AT_CLEANUP


AT_SETUP([SEQUENTIAL file I/O with variable records])
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.

       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT f ASSIGN DISK.

       DATA DIVISION.
       FILE SECTION.
       FD  f RECORD VARYING FROM 10 TO 20 DEPENDING rec-size.
       01  f-rec.
           02  f-x OCCURS 20 PIC X.

       WORKING-STORAGE SECTION.
       01  rec-size PIC 99.
       01  i PIC 99.
       01  1-template VALUE "+12345678++12345678+".
           02  1-x OCCURS 20 PIC X.

       PROCEDURE DIVISION.
           OPEN OUTPUT f
           PERFORM VARYING rec-size FROM 20 BY -1 UNTIL rec-size < 10
               WRITE f-rec FROM 1-template
           END-PERFORM
           CLOSE f

           OPEN INPUT f
      *    rec-size should not influence READ
           MOVE 15 TO rec-size
           PERFORM VARYING i FROM 20 BY -1 UNTIL i < 10
               READ f
                   AT END
                       DISPLAY "Failed: EOF"
                       STOP RUN ERROR
               END-READ

      *        Note the characters f-rec (rec-size + 1:) are all undefined,
      *        hence the refmod (1:rec-size).
               DISPLAY rec-size ": >" f-rec (1:rec-size) "<"
               IF rec-size NOT = i
                   DISPLAY "Failed: bad record size"
                   STOP RUN ERROR
               END-IF
               IF f-x (rec-size) NOT = 1-x (rec-size)
                   DISPLAY "Failed: bad data"
                   STOP RUN ERROR
               END-IF
           END-PERFORM
           CLOSE f
           .
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[20: >+12345678++12345678+<
19: >+12345678++12345678<
18: >+12345678++1234567<
17: >+12345678++123456<
16: >+12345678++12345<
15: >+12345678++1234<
14: >+12345678++123<
13: >+12345678++12<
12: >+12345678++1<
11: >+12345678++<
10: >+12345678+<
])

AT_CLEANUP


AT_SETUP([LINE SEQUENTIAL file I/O with variable records])
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.

       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT f ASSIGN DISK
               LINE SEQUENTIAL.

       DATA DIVISION.
       FILE SECTION.
       FD  f RECORD VARYING FROM 10 TO 20 DEPENDING rec-size.
       01  f-rec.
           02  f-x OCCURS 20 PIC X.

       WORKING-STORAGE SECTION.
       01  rec-size PIC 99.
       01  i PIC 99.
       01  1-template VALUE "+12345678++12345678+".
           02  1-x OCCURS 20 PIC X.

       PROCEDURE DIVISION.
           OPEN OUTPUT f
           PERFORM VARYING rec-size FROM 20 BY -1 UNTIL rec-size < 10
               WRITE f-rec FROM 1-template
           END-PERFORM
           CLOSE f

           OPEN INPUT f
      *    rec-size should not influence READ
           MOVE 15 TO rec-size
           PERFORM VARYING i FROM 20 BY -1 UNTIL i < 10
               READ f
                   AT END
                       DISPLAY "Failed: EOF"
                       STOP RUN ERROR
               END-READ

               DISPLAY rec-size ": >" f-rec (1:rec-size) "<"
               IF rec-size NOT = i
                   DISPLAY "Failed: bad record size"
                   STOP RUN ERROR
               END-IF
               IF f-x (rec-size) NOT = 1-x (rec-size)
                   DISPLAY "Failed: bad data"
                   STOP RUN ERROR
               END-IF
           END-PERFORM
           CLOSE f
           .
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[20: >+12345678++12345678+<
19: >+12345678++12345678<
18: >+12345678++1234567<
17: >+12345678++123456<
16: >+12345678++12345<
15: >+12345678++1234<
14: >+12345678++123<
13: >+12345678++12<
12: >+12345678++1<
11: >+12345678++<
10: >+12345678+<
])

AT_CLEANUP


AT_SETUP([SEQUENTIAL file REWRITE])
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID.  prog.

       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT file1 ASSIGN DISK.

       DATA DIVISION.
       FILE SECTION.
       FD  file1.
       01  file1-rec.
           02  file1-serial-1 PIC 9(6).
           02  file1-xseen PIC 9(4).
           02  file1-serial-2 PIC 9(6).

       WORKING-STORAGE SECTION.
       01  w-count PIC 9(6) VALUE 0.
       01  w-eof PIC 9 VALUE 0.
           88  eof VALUE 1 FALSE 0.
       01  w-abort PIC 9 VALUE 0.
           88  abort VALUE 1 FALSE 0.

       PROCEDURE DIVISION.
           OPEN OUTPUT file1
           PERFORM VARYING w-count FROM 1 BY 1
                   UNTIL w-count > 20
               MOVE w-count TO file1-serial-1
               MOVE 0 TO file1-xseen
               ADD 100 w-count GIVING file1-serial-2
               WRITE file1-rec
           END-PERFORM
           CLOSE file1

           OPEN I-O file1
           SET eof TO FALSE
           PERFORM VARYING w-count FROM 1 BY 1
                   UNTIL eof OR abort
               READ file1
                   AT END
                       SET eof TO TRUE

                   NOT AT END
                       IF (file1-serial-1 <> w-count)
                           DISPLAY "FAIL 1: " w-count " :: "
                               file1-serial-1
                           SET abort TO TRUE
                       ELSE IF (file1-serial-2 <> (100 + w-count))
                           DISPLAY "FAIL 2: " w-count " :: "
                               file1-serial-2
                           SET abort TO TRUE
                       ELSE IF (file1-xseen <> 0)
                           DISPLAY "FAIL 3: " w-count " :: " file1-xseen
                           SET abort TO TRUE
                       ELSE IF (w-count = 5 OR 10 OR 15 OR 20)
                           ADD 1000 w-count GIVING file1-serial-2
                           ADD 1 TO file1-xseen
                           REWRITE file1-rec
                       END-IF
               END-READ
           END-PERFORM
           IF NOT ((w-count = 22) AND eof)
               DISPLAY "FAIL 4"
           END-IF
           CLOSE file1

           OPEN INPUT file1
           SET eof TO FALSE
           SET abort TO FALSE
           PERFORM VARYING w-count FROM 1 BY 1
                   UNTIL eof OR abort
               READ file1
                   AT END
                       SET eof TO TRUE

                   NOT AT END
                       IF (file1-serial-1 <> w-count)
                           DISPLAY "FAIL 5"
                           SET abort TO TRUE
                       ELSE IF (w-count = 5 OR 10 OR 15 OR 20)
                           IF NOT ((file1-serial-2 = (1000 + w-count))
                                   AND (file1-xseen = 1))
                               DISPLAY "FAIL 6"
                               SET abort TO TRUE
                           END-IF
                       ELSE
                           IF NOT ((file1-serial-2 = (100 + w-count))
                                   AND (file1-xseen = 0))
                               DISPLAY "FAIL 7"
                               SET abort TO TRUE
                           END-IF
                       END-IF
               END-READ
           END-PERFORM
           CLOSE file1
           .
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP

##
## FIXME: All the SEQUENTIAL file locking tests pass in reportwriter.
##

AT_SETUP([SEQUENTIAL file with LOCK MODE EXCLUSIVE])
AT_KEYWORDS([runfile])

AT_XFAIL_IF([true])

AT_DATA([prog1.cob], [
       identification division.
       program-id. prog1.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk
           lock mode is exclusive
           status is fs.
       data division.
       file section.
       fd file1.
       1    file1-rec pic x.
       working-storage section.
       1    fs pic xx.
       1    os-check   pic x(7).
         88 os-is-windows-or-dos values 'WINDOWS' 'FREEDOS'.
       78  callee       value "./prog2".
       78  callee-wdos  value ".\prog2".
       procedure division.
           open output file1.
           close file1.
           open input file1.
           accept os-check from environment "COB_ON_CYGWIN".
           if os-check = spaces
             accept os-check from environment "OS".
           if os-check = spaces
             accept os-check from environment "OS_NAME".
           inspect os-check converting "werfdosin" to "WERFDOSIN".
           if os-is-windows-or-dos
             call "SYSTEM" using callee-wdos
           else
             call "SYSTEM" using callee.
           close file1.
           stop run.
])
AT_DATA([prog2.cob], [
       identification division.
       program-id. prog2.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk status is fs.
       data division.
       file section.
       fd file1.
       1    file1-rec pic x.
       working-storage section.
       1    fs pic xx.
       procedure division.
           open input file1.
           if fs not = "61"
              display "FAILED: " fs
              close file1
           end-if.
           stop run.
])

AT_CHECK([$COMPILE prog1.cob], [0], [], [])
AT_CHECK([$COMPILE prog2.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog1], [0], [], [])

AT_CLEANUP


AT_SETUP([SEQUENTIAL file with OPEN WITH LOCK])
AT_KEYWORDS([runfile])

AT_XFAIL_IF([true])

AT_DATA([prog1.cob], [
       identification division.
       program-id. prog1.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk status is fs.
       data division.
       file section.
       fd file1.
       1    file1-rec pic x.
       working-storage section.
       1    fs pic xx.
       1    os-check   pic x(7).
         88 os-is-windows-or-dos values 'WINDOWS' 'FREEDOS'.
       78  callee       value "./prog2".
       78  callee-wdos  value ".\prog2".
       procedure division.
           open output file1.
           close file1.
           open input file1 with lock.
           accept os-check from environment "COB_ON_CYGWIN".
           if os-check = spaces
             accept os-check from environment "OS".
           if os-check = spaces
             accept os-check from environment "OS_NAME".
           inspect os-check converting "werfdosin" to "WERFDOSIN".
           if os-is-windows-or-dos
             call "SYSTEM" using callee-wdos
           else
             call "SYSTEM" using callee.
           close file1.
           stop run.
])
AT_DATA([prog2.cob], [
       identification division.
       program-id. prog2.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk status is fs.
       data division.
       file section.
       fd file1.
       1    file1-rec pic x.
       working-storage section.
       1    fs pic xx.
       procedure division.
           open input file1.
           if fs not = "61"
              display "FAILED: " fs
              close file1
           end-if.
           stop run.
])

AT_CHECK([$COMPILE prog1.cob], [0], [], [])
AT_CHECK([$COMPILE prog2.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog1], [0], [], [])

AT_CLEANUP


AT_SETUP([SEQUENTIAL file with SHARING NO])
AT_KEYWORDS([runfile])

AT_XFAIL_IF([true])

AT_DATA([prog1.cob], [
       identification division.
       program-id. prog1.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk
           sharing no
           status is fs.
       data division.
       file section.
       fd file1.
       1    file1-rec pic x.
       working-storage section.
       1    fs pic xx.
       1    os-check   pic x(7).
         88 os-is-windows-or-dos values 'WINDOWS' 'FREEDOS'.
       78  callee       value "./prog2".
       78  callee-wdos  value ".\prog2".
       procedure division.
           open output file1.
           close file1.
           open input file1.
           accept os-check from environment "COB_ON_CYGWIN".
           if os-check = spaces
             accept os-check from environment "OS".
           if os-check = spaces
             accept os-check from environment "OS_NAME".
           inspect os-check converting "werfdosin" to "WERFDOSIN".
           if os-is-windows-or-dos
             call "SYSTEM" using callee-wdos
           else
             call "SYSTEM" using callee.
           close file1.
           stop run.
])
AT_DATA([prog2.cob], [
       identification division.
       program-id. prog2.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk status is fs.
       data division.
       file section.
       fd file1.
       1    file1-rec pic x.
       working-storage section.
       1    fs pic xx.
       procedure division.
           open input file1.
           if fs not = "61"
              display "FAILED: " fs
              close file1
           end-if.
           stop run.
])

AT_CHECK([$COMPILE prog1.cob], [0], [], [])
AT_CHECK([$COMPILE prog2.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog1], [0], [], [])

AT_CLEANUP


AT_SETUP([SEQUENTIAL file with SHARING READ ONLY])
AT_KEYWORDS([runfile])

AT_DATA([prog1.cob], [
       identification division.
       program-id. prog1.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk
           sharing read only
           status is fs.
       data division.
       file section.
       fd file1.
       1    file1-rec pic x.
       working-storage section.
       1    fs pic xx.
       1    os-check   pic x(7).
         88 os-is-windows-or-dos values 'WINDOWS' 'FREEDOS'.
       78  callee       value "./prog2".
       78  callee-wdos  value ".\prog2".
       procedure division.
           open output file1.
           close file1.
           open input file1.
           accept os-check from environment "COB_ON_CYGWIN".
           if os-check = spaces
             accept os-check from environment "OS".
           if os-check = spaces
             accept os-check from environment "OS_NAME".
           inspect os-check converting "werfdosin" to "WERFDOSIN".
           if os-is-windows-or-dos
             call "SYSTEM" using callee-wdos
           else
             call "SYSTEM" using callee.
           close file1.
           stop run.
])
AT_DATA([prog2.cob], [
       identification division.
       program-id. prog2.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk status is fs.
       data division.
       file section.
       fd file1.
       1    file1-rec pic x.
       working-storage section.
       1    fs pic xx.
       procedure division.
           open i-o file1.
           if fs not = "61"
              display "FAILED 1: " fs
              close file1
           end-if.
           open input file1.
           if fs not = "00"
              display "FAILED 2: " fs
           else
              close file1
           end-if.
           stop run.
])

AT_CHECK([$COMPILE prog1.cob], [0], [], [])
AT_CHECK([$COMPILE prog2.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog1], [0], [], [])

AT_CLEANUP


## Check successor is blocked from exclusive open on file already open.
AT_SETUP([SEQUENTIAL file with blocked lock])
AT_KEYWORDS([runfile])

AT_XFAIL_IF([true])

AT_DATA([prog1.cob], [
       identification division.
       program-id. prog1.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk.
       data division.
       file section.
       fd file1.
       1    file1-rec pic x.
       working-storage section.
       1    os-check   pic x(7).
         88 os-is-windows-or-dos values 'WINDOWS' 'FREEDOS'.
       78  callee       value "./prog2".
       78  callee-wdos  value ".\prog2".
       procedure division.
           open output file1.
           close file1.
           open input file1.
           accept os-check from environment "COB_ON_CYGWIN".
           if os-check = spaces
             accept os-check from environment "OS".
           if os-check = spaces
             accept os-check from environment "OS_NAME".
           inspect os-check converting "werfdosin" to "WERFDOSIN".
           if os-is-windows-or-dos
             call "SYSTEM" using callee-wdos
           else
             call "SYSTEM" using callee.
           close file1.
           stop run.
])
AT_DATA([prog2.cob], [
       identification division.
       program-id. prog2.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk status is fs.
       data division.
       file section.
       fd file1.
       1    file1-rec pic x.
       working-storage section.
       1    fs pic xx.
       procedure division.
           open input file1.
           if fs not = "00"
              display "FAILED: " fs
              stop run
           end-if.
           close file1
           open input file1 with lock.
           if fs not = "61"
              display "FAILED: " fs
              close file1
           end-if.
           stop run.
])

AT_CHECK([$COMPILE prog1.cob], [0], [], [])
AT_CHECK([$COMPILE prog2.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog1], [0], [], [])

AT_CLEANUP


AT_SETUP([RELATIVE SEQUENTIAL basic I/O])
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
       SELECT file1 ASSIGN DISK ORGANIZATION RELATIVE.
       DATA DIVISION.
       FILE SECTION.
       FD file1.
       1  file1-rec pic x.
       PROCEDURE DIVISION.
           DELETE FILE file1.
           OPEN OUTPUT file1.
           MOVE "A" TO file1-rec.
           WRITE file1-rec.
           CLOSE file1.
           OPEN INPUT file1.
           READ file1.
           IF (file1-rec <> "A")
              display "FAILED".
           CLOSE file1.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([RELATIVE RANDOM basic I/O])
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
       SELECT file1 ASSIGN DISK
          ORGANIZATION RELATIVE
          ACCESS RANDOM RELATIVE KEY file1-key.
       DATA DIVISION.
       FILE SECTION.
       FD file1.
       1  file1-rec pic x.
       WORKING-STORAGE SECTION.
       77  file1-key pic 99.
       PROCEDURE DIVISION.
           DELETE FILE file1.
           OPEN OUTPUT file1.
           MOVE 1 to file1-key.
           MOVE "A" TO file1-rec.
           WRITE file1-rec.
           MOVE 2 to file1-key.
           MOVE "B" TO file1-rec.
           WRITE file1-rec.
           MOVE 3 to file1-key.
           MOVE "C" TO file1-rec.
           WRITE file1-rec.
           CLOSE file1.
           OPEN INPUT file1.
           MOVE 2 to file1-key.
           READ file1.
           IF (file1-rec <> "B")
              display "FAILED".
           MOVE 1 to file1-key.
           READ file1.
           IF (file1-rec <> "A")
              display "FAILED".
           CLOSE file1.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([RELATIVE SEQUENTIAL with variable records])
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.

       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT f ASSIGN DISK
               ORGANIZATION RELATIVE.

       DATA DIVISION.
       FILE SECTION.
       FD  f RECORD VARYING FROM 10 TO 20 DEPENDING rec-size.
       01  f-rec.
           02  f-x OCCURS 20 PIC X.

       WORKING-STORAGE SECTION.
       01  rec-size PIC 99.
       01  i PIC 99.
       01  1-template VALUE "+12345678++12345678+".
           02  1-x OCCURS 20 PIC X.

       PROCEDURE DIVISION.
           OPEN OUTPUT f
           PERFORM VARYING rec-size FROM 20 BY -1 UNTIL rec-size < 10
               WRITE f-rec FROM 1-template
           END-PERFORM
           CLOSE f

           OPEN INPUT f
      *    rec-size should not influence READ
           MOVE 15 TO rec-size
           PERFORM VARYING i FROM 20 BY -1 UNTIL i < 10
               READ f
                   AT END
                       DISPLAY "Failed: EOF"
                       STOP RUN ERROR
               END-READ

               DISPLAY rec-size ": >" f-rec (1:rec-size) "<"
               IF rec-size NOT = i
                   DISPLAY "Failed: bad record size"
                   STOP RUN ERROR
               END-IF
               IF f-x (rec-size) NOT = 1-x (rec-size)
                   DISPLAY "Failed: bad data"
                   STOP RUN ERROR
               END-IF
           END-PERFORM
           CLOSE f
           .
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[20: >+12345678++12345678+<
19: >+12345678++12345678<
18: >+12345678++1234567<
17: >+12345678++123456<
16: >+12345678++12345<
15: >+12345678++1234<
14: >+12345678++123<
13: >+12345678++12<
12: >+12345678++1<
11: >+12345678++<
10: >+12345678+<
])

AT_CLEANUP


AT_SETUP([INDEXED SEQUENTIAL basic I/O])
AT_KEYWORDS([runfile])

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
       SELECT fileX ASSIGN DISK ORGANIZATION INDEXED
           RECORD KEY fileX-key.
       DATA DIVISION.
       FILE SECTION.
       FD fileX.
       1  fileX-rec.
          2 fileX-key pic x(6).
          2 fileX-data pic x(10).
       PROCEDURE DIVISION.
           OPEN OUTPUT fileX.
           MOVE ALL "A" TO fileX-rec.
           WRITE fileX-rec.
           CLOSE fileX.
           OPEN INPUT fileX.
           READ fileX.
           IF (fileX-rec <> ALL "A")
              display "FAILED".
           CLOSE fileX.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([INDEXED SEQUENTIAL with variable records])
AT_KEYWORDS([runfile])

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.

       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT f ASSIGN DISK
               INDEXED
               RECORD KEY f-key
               ACCESS RANDOM.

       DATA DIVISION.
       FILE SECTION.
       FD  f RECORD VARYING FROM 12 TO 22 DEPENDING rec-size.
       01  f-rec.
           02  f-key PIC 99.
           02  f-data.
               03  f-x OCCURS 20 PIC X.

       WORKING-STORAGE SECTION.
       01  rec-size PIC 99.
       01  1-template VALUE "+12345678++12345678+".
           02  1-x OCCURS 20 PIC X.

       PROCEDURE DIVISION.
           OPEN OUTPUT f
           MOVE 1 TO f-key
           PERFORM VARYING rec-size FROM 22 BY -1 UNTIL rec-size < 12
               MOVE 1-template TO f-data
               WRITE f-rec
               ADD 1 TO f-key
           END-PERFORM
           CLOSE f

           OPEN INPUT f
      *    rec-size should not influence READ
           MOVE 15 TO rec-size
           PERFORM VARYING f-key FROM 1 BY 1 UNTIL f-key > 11
               READ f
                   AT END
                       DISPLAY "Failed: EOF"
                       STOP RUN ERROR
               END-READ

               DISPLAY rec-size ": >" f-rec (3:rec-size - 2) "<"
               IF rec-size NOT = (22 - f-key) + 1
                   DISPLAY "Failed: bad record size - " rec-size
                   STOP RUN ERROR
               END-IF
               IF f-x (rec-size - 2) NOT = 1-x (rec-size - 2)
                   DISPLAY "Failed: bad data - " f-data
                   STOP RUN ERROR
               END-IF
           END-PERFORM
           CLOSE f
           .
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[22: >+12345678++12345678+<
21: >+12345678++12345678<
20: >+12345678++1234567<
19: >+12345678++123456<
18: >+12345678++12345<
17: >+12345678++1234<
16: >+12345678++123<
15: >+12345678++12<
14: >+12345678++1<
13: >+12345678++<
12: >+12345678+<
])

AT_CLEANUP


AT_SETUP([INDEXED file with LOCK MODE EXCLUSIVE])
AT_KEYWORDS([runfile])

## TO-DO: Support INDEXED file sharing/locking.
AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])
AT_XFAIL_IF([true])

AT_DATA([prog1.cob], [
       identification division.
       program-id. prog1.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk
           organization indexed
           record key file1-key
           lock mode is exclusive
           status is fs.
       data division.
       file section.
       fd file1.
       1    file1-rec.
        2   file1-key pic x.
       working-storage section.
       1    fs pic xx.
       1    os-check   pic x(7).
         88 os-is-windows-or-dos values 'WINDOWS' 'FREEDOS'.
       78  callee       value "./prog2".
       78  callee-wdos  value ".\prog2".
       procedure division.
           open output file1.
           close file1.
           open input file1.
           accept os-check from environment "COB_ON_CYGWIN".
           if os-check = spaces
             accept os-check from environment "OS".
           if os-check = spaces
             accept os-check from environment "OS_NAME".
           inspect os-check converting "werfdosin" to "WERFDOSIN".
           if os-is-windows-or-dos
             call "SYSTEM" using callee-wdos
           else
             call "SYSTEM" using callee.
           close file1.
           stop run.
])
AT_DATA([prog2.cob], [
       identification division.
       program-id. prog2.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk
           organization indexed
           record key file1-key
           status is fs.
       data division.
       file section.
       fd file1.
       1    file1-rec.
        2   file1-key pic x.
       working-storage section.
       1    fs pic xx.
       procedure division.
           open input file1.
           if fs not = "61"
              display "FAILED: " fs
              close file1
           end-if.
           stop run.
])

AT_CHECK([$COMPILE prog1.cob], [0], [], [])
AT_CHECK([$COMPILE prog2.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog1], [0], [], [])

AT_CLEANUP


AT_SETUP([INDEXED file with OPEN WITH LOCK])
AT_KEYWORDS([runfile])

## TO-DO: Support INDEXED file sharing/locking.
AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])
AT_XFAIL_IF([true])

AT_DATA([prog1.cob], [
       identification division.
       program-id. prog1.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk
           organization indexed
           record key file1-key
           status is fs.
       data division.
       file section.
       fd file1.
       1    file1-rec.
        2   file1-key pic x.
       working-storage section.
       1    fs pic xx.
       1    os-check   pic x(7).
         88 os-is-windows-or-dos values 'WINDOWS' 'FREEDOS'.
       78  callee       value "./prog2".
       78  callee-wdos  value ".\prog2".
       procedure division.
           open output file1.
           close file1.
           open input file1 with lock.
           accept os-check from environment "COB_ON_CYGWIN".
           if os-check = spaces
             accept os-check from environment "OS".
           if os-check = spaces
             accept os-check from environment "OS_NAME".
           inspect os-check converting "werfdosin" to "WERFDOSIN".
           if os-is-windows-or-dos
             call "SYSTEM" using callee-wdos
           else
             call "SYSTEM" using callee.
           close file1.
           stop run.
])
AT_DATA([prog2.cob], [
       identification division.
       program-id. prog2.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk
           organization indexed
           record key file1-key
           status is fs.
       data division.
       file section.
       fd file1.
       1    file1-rec.
        2   file1-key pic x.
       working-storage section.
       1    fs pic xx.
       procedure division.
           open input file1.
           if fs not = "61"
              display "FAILED: " fs
              close file1
           end-if.
           stop run.
])

AT_CHECK([$COMPILE prog1.cob], [0], [], [])
AT_CHECK([$COMPILE prog2.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog1], [0], [], [])

AT_CLEANUP


AT_SETUP([INDEXED file with SHARING NO])
AT_KEYWORDS([runfile])

## TO-DO: Support INDEXED file sharing/locking.
AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])
AT_XFAIL_IF([true])

AT_DATA([prog1.cob], [
       identification division.
       program-id. prog1.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk
           organization indexed
           record key file1-key
           sharing no
           status is fs.
       data division.
       file section.
       fd file1.
       1    file1-rec.
        2   file1-key pic x.
       working-storage section.
       1    fs pic xx.
       1    os-check   pic x(7).
         88 os-is-windows-or-dos values 'WINDOWS' 'FREEDOS'.
       78  callee       value "./prog2".
       78  callee-wdos  value ".\prog2".
       procedure division.
           open output file1.
           close file1.
           open input file1.
           accept os-check from environment "COB_ON_CYGWIN".
           if os-check = spaces
             accept os-check from environment "OS".
           if os-check = spaces
             accept os-check from environment "OS_NAME".
           inspect os-check converting "werfdosin" to "WERFDOSIN".
           if os-is-windows-or-dos
             call "SYSTEM" using callee-wdos
           else
             call "SYSTEM" using callee.
           close file1.
           stop run.
])
AT_DATA([prog2.cob], [
       identification division.
       program-id. prog2.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk
           organization indexed
           record key file1-key
           status is fs.
       data division.
       file section.
       fd file1.
       1    file1-rec.
        2   file1-key pic x.
       working-storage section.
       1    fs pic xx.
       procedure division.
           open input file1.
           if fs not = "61"
              display "FAILED: " fs
              close file1
           end-if.
           stop run.
])

AT_CHECK([$COMPILE prog1.cob], [0], [], [])
AT_CHECK([$COMPILE prog2.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog1], [0], [], [])

AT_CLEANUP


AT_SETUP([INDEXED file with SHARING READ ONLY])
AT_KEYWORDS([runfile])

## TO-DO: Support INDEXED file sharing/locking.
AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])
AT_XFAIL_IF([true])

AT_DATA([prog1.cob], [
       identification division.
       program-id. prog1.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk
           organization indexed
           record key file1-key
           sharing read only
           status is fs.
       data division.
       file section.
       fd file1.
       1    file1-rec.
        2   file1-key pic x.
       working-storage section.
       1    fs pic xx.
       1    os-check   pic x(7).
         88 os-is-windows-or-dos values 'WINDOWS' 'FREEDOS'.
       78  callee       value "./prog2".
       78  callee-wdos  value ".\prog2".
       procedure division.
           open output file1.
           close file1.
           open input file1.
           accept os-check from environment "COB_ON_CYGWIN".
           if os-check = spaces
             accept os-check from environment "OS".
           if os-check = spaces
             accept os-check from environment "OS_NAME".
           inspect os-check converting "werfdosin" to "WERFDOSIN".
           if os-is-windows-or-dos
             call "SYSTEM" using callee-wdos
           else
             call "SYSTEM" using callee.
           close file1.
           stop run.
])
AT_DATA([prog2.cob], [
       identification division.
       program-id. prog2.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk
           organization indexed
           record key file1-key
           status is fs.
       data division.
       file section.
       fd file1.
       1    file1-rec.
        2   file1-key pic x.
       working-storage section.
       1    fs pic xx.
       procedure division.
           open i-o file1.
           if fs not = "61"
              display "FAILED: " fs
              close file1
           end-if.
           open input file1.
           if fs not = "00"
              display "FAILED: " fs
           else
              close file1
           end-if.
           stop run.
])

AT_CHECK([$COMPILE prog1.cob], [0], [], [])
AT_CHECK([$COMPILE prog2.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog1], [0], [], [])

AT_CLEANUP


## Check successor is blocked from exclusive open on file already open.
AT_SETUP([INDEXED file with blocked lock])
AT_KEYWORDS([runfile])

## TO-DO: Support INDEXED file sharing/locking.
AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])
AT_XFAIL_IF([true])

AT_DATA([prog1.cob], [
       identification division.
       program-id. prog1.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk
           organization indexed
           record key file1-key.
       data division.
       file section.
       fd file1.
       1    file1-rec.
        2   file1-key pic x.
       working-storage section.
       1    os-check   pic x(7).
         88 os-is-windows-or-dos values 'WINDOWS' 'FREEDOS'.
       78  callee       value "./prog2".
       78  callee-wdos  value ".\prog2".
       procedure division.
           open output file1.
           close file1.
           open input file1.
           accept os-check from environment "COB_ON_CYGWIN".
           if os-check = spaces
             accept os-check from environment "OS".
           if os-check = spaces
             accept os-check from environment "OS_NAME".
           inspect os-check converting "werfdosin" to "WERFDOSIN".
           if os-is-windows-or-dos
             call "SYSTEM" using callee-wdos
           else
             call "SYSTEM" using callee.
           close file1.
           stop run.
])
AT_DATA([prog2.cob], [
       identification division.
       program-id. prog2.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk
           organization indexed
           record key file1-key
           status is fs.
       data division.
       file section.
       fd file1.
       1    file1-rec.
        2   file1-key pic x.
       working-storage section.
       1    fs pic xx.
       procedure division.
           open input file1.
           if fs not = "00"
              display "FAILED: " fs
              stop run
           end-if.
           close file1
           open input file1 with lock.
           if fs not = "61"
              display "FAILED: " fs
              close file1
           end-if.
           stop run.
])

AT_CHECK([$COMPILE prog1.cob], [0], [], [])
AT_CHECK([$COMPILE prog2.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog1], [0], [], [])

AT_CLEANUP

## Try to read locked record
AT_SETUP([INDEXED file with LOCK AUTOMATIC (1)])
AT_KEYWORDS([runfile])

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])
AT_XFAIL_IF([true])

AT_DATA([prog1.cob], [
       identification division.
       program-id. prog1.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk
           access mode is random
           organization indexed
           record key file1-key
           lock mode is automatic
           status is fs.
       data division.
       file section.
       fd file1.
       1    file1-rec.
        2   file1-key pic x.
       working-storage section.
       1    fs pic xx.
       1    os-check   pic x(7).
         88 os-is-windows-or-dos values 'WINDOWS' 'FREEDOS'.
       78  callee       value "./prog2".
       78  callee-wdos  value ".\prog2".
       procedure division.
           open output file1.
           move "X" to file1-key.
           write file1-rec.
           if fs not = "00"
              display "FAILED 1::w fs=" fs.
           close file1.
           open i-o file1.
           move "X" to file1-key.
           read file1.
           if fs not = "00"
              display "FAILED 1::r fs=" fs.
           accept os-check from environment "COB_ON_CYGWIN".
           if os-check = spaces
             accept os-check from environment "OS".
           if os-check = spaces
             accept os-check from environment "OS_NAME".
           inspect os-check converting "werfdosin" to "WERFDOSIN".
           if os-is-windows-or-dos
             call "SYSTEM" using callee-wdos
           else
             call "SYSTEM" using callee.
           close file1.
           stop run.
])
AT_DATA([prog2.cob], [
       identification division.
       program-id. prog2.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk
           access mode is random
           organization indexed
           record key file1-key
           lock mode is automatic
           status is fs.
       data division.
       file section.
       fd file1.
       1    file1-rec.
        2   file1-key pic x.
       working-storage section.
       1    fs pic xx.
       procedure division.
           open i-o file1.
           move "X" to file1-key.
           read file1.
           if fs not = "61"
              display "FAILED 2::r " fs.
           close file1
           stop run.
])

AT_CHECK([$COMPILE prog1.cob], [0], [], [])
AT_CHECK([$COMPILE prog2.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog1], [0], [], [])


AT_CLEANUP

## Read unlocked record
AT_SETUP([INDEXED file with LOCK AUTOMATIC (2)])
AT_KEYWORDS([runfile])

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog1.cob], [
       identification division.
       program-id. prog1.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk
           access mode is random
           organization indexed
           record key file1-key
           lock mode is automatic
           status is fs.
       data division.
       file section.
       fd file1.
       1    file1-rec.
        2   file1-key pic x.
       working-storage section.
       1    fs pic xx.
       1    os-check   pic x(7).
         88 os-is-windows-or-dos values 'WINDOWS' 'FREEDOS'.
       78  callee       value "./prog2".
       78  callee-wdos  value ".\prog2".
       procedure division.
           open output file1.
           move "X" to file1-key.
           write file1-rec.
           if fs not = "00"
              display "FAILED 1::w fs=" fs.
           close file1.
           open i-o file1.
           move "X" to file1-key.
           read file1.
           if fs not = "00"
              display "FAILED 1::r fs=" fs.
           rewrite file1-rec.
           if fs not = "00"
              display "FAILED 1::rw fs=" fs.
           accept os-check from environment "COB_ON_CYGWIN".
           if os-check = spaces
             accept os-check from environment "OS".
           if os-check = spaces
             accept os-check from environment "OS_NAME".
           inspect os-check converting "werfdosin" to "WERFDOSIN".
           if os-is-windows-or-dos
             call "SYSTEM" using callee-wdos
           else
             call "SYSTEM" using callee.
           close file1.
           stop run.
])
AT_DATA([prog2.cob], [
       identification division.
       program-id. prog2.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk
           access mode is random
           organization indexed
           record key file1-key
           status is fs.
       data division.
       file section.
       fd file1.
       1    file1-rec.
        2   file1-key pic x.
       working-storage section.
       1    fs pic xx.
       procedure division.
           open input file1.
           move "X" to file1-key.
           read file1.
           if fs not = "00"
              display "FAILED 2::r " fs
           end-if.
           close file1
           stop run.
])

AT_CHECK([$COMPILE prog1.cob], [0], [], [])
AT_CHECK([$COMPILE prog2.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog1], [0], [], [])

AT_CLEANUP


AT_SETUP([INDEXED file with LOCK MANUAL])
AT_KEYWORDS([runfile])

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])
AT_XFAIL_IF([true])

AT_DATA([prog1.cob], [
       identification division.
       program-id. prog1.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk
           access mode is random
           organization indexed
           record key file1-key
           lock mode is manual
           status is fs.
       data division.
       file section.
       fd file1.
       1    file1-rec.
        2   file1-key pic x.
       working-storage section.
       1    fs pic xx.
       1    os-check   pic x(7).
         88 os-is-windows-or-dos values 'WINDOWS' 'FREEDOS'.
       78  callee       value "./prog2".
       78  callee-wdos  value ".\prog2".
       procedure division.
           open output file1.
           move "X" to file1-key.
           write file1-rec.
           if fs not = "00"
              display "FAILED 1::w fs=" fs.
           close file1.
           open i-o file1.
           move "X" to file1-key.
           read file1 with lock.
           if fs not = "00"
              display "FAILED 1::r fs=" fs.
           accept os-check from environment "COB_ON_CYGWIN".
           if os-check = spaces
             accept os-check from environment "OS".
           if os-check = spaces
             accept os-check from environment "OS_NAME".
           inspect os-check converting "werfdosin" to "WERFDOSIN".
           if os-is-windows-or-dos
             call "SYSTEM" using callee-wdos
           else
             call "SYSTEM" using callee.
           close file1.
           stop run.
])
AT_DATA([prog2.cob], [
       identification division.
       program-id. prog2.
       environment division.
       input-output section.
       file-control.
       select file1 assign disk
           access mode is random
           organization indexed
           record key file1-key
           status is fs.
       data division.
       file section.
       fd file1.
       1    file1-rec.
        2   file1-key pic x.
       working-storage section.
       1    fs pic xx.
       procedure division.
           open i-o file1.
           move "X" to file1-key.
           read file1.
           if fs not = "61"
              display "FAILED 2::r " fs
           end-if.
           close file1
           stop run.
])

AT_CHECK([$COMPILE prog1.cob], [0], [], [])
AT_CHECK([$COMPILE prog2.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog1], [0], [], [])

AT_CLEANUP


AT_SETUP([START INDEXED])
AT_KEYWORDS([runfile])

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
       SELECT file1 ASSIGN TO "./file1X"
                    ORGANIZATION INDEXED
                    ACCESS DYNAMIC RECORD KEY file1-key.
       DATA DIVISION.
       FILE SECTION.
       FD file1.
       1  file1-rec.
          2  file1-key pic 999.
          2  file1-data pic 999.
       PROCEDURE DIVISION.
          OPEN OUTPUT file1.
          CLOSE file1.
          OPEN I-O file1.
          MOVE 10 TO file1-key file1-data.
          WRITE file1-rec.
          MOVE 11 TO file1-key file1-data.
          WRITE file1-rec.
          MOVE 12 TO file1-key file1-data.
          WRITE file1-rec.
          MOVE 13 TO file1-key file1-data.
          WRITE file1-rec.
      *
          MOVE 0 TO file1-key.
          START file1 KEY > file1-key.
          READ file1 NEXT.
          IF (file1-data <> 10)
             DISPLAY "FAILED: START key > 0".
      *
          MOVE 99 TO file1-key.
          START file1 KEY < file1-key.
          READ file1 NEXT.
          IF (file1-data <> 13)
             DISPLAY "FAILED: START key < 99".
      *
          MOVE 999 TO file1-key.
          START file1 FIRST.
          READ file1 NEXT.
          IF (file1-data <> 10)
             DISPLAY "FAILED: START key FIRST".
      *
          MOVE 0 TO file1-key.
          START file1 LAST.
          READ file1 NEXT.
          IF (file1-data <> 13)
             DISPLAY "FAILED: START key LAST".
      *
          MOVE 0 TO file1-key.
          START file1 KEY >= file1-key.
          READ file1 NEXT.
          IF (file1-data <> 10)
             DISPLAY "FAILED: START key >= 0".
      *
          MOVE 99 TO file1-key.
          START file1 KEY <= file1-key.
          READ file1 NEXT.
          IF (file1-data <> 13)
             DISPLAY "FAILED: START key <= 99".

          CLOSE file1.
          STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([INDEXED partial keys])
AT_KEYWORDS([runfile])

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.

       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT OPTIONAL f ASSIGN "fileX"
               ORGANIZATION INDEXED
               ACCESS DYNAMIC
               RECORD KEY f-key1
               ALTERNATE RECORD f-key2
               ALTERNATE RECORD f-key3 DUPLICATES
               STATUS f-status.

       DATA DIVISION.
       FILE SECTION.
       FD  f.
       01  f-rec.
           02  f-key1.
               03  f-key1-1 PIC X(3).
               03  f-key1-2 PIC X(3).
           02  f-key2.
               03  f-key2-1 PIC X(3).
               03  f-key2-2 PIC X(3).
           02  f-key3.
               03  f-key3-1 PIC X(3).
               03  f-key3-2 PIC X(3).
           02  file1-serial PIC 99.

       WORKING-STORAGE SECTION.
       01  f-status PIC XX.
       01  w-serial PIC 99 VALUE 0.

       PROCEDURE DIVISION.
           DELETE FILE f
           OPEN I-O f
           MOVE "AAAAAAaaaaaaXX----" TO f-rec
           PERFORM write-f
           MOVE "AAAAABaaaaabXX----" TO f-rec
           PERFORM write-f
           MOVE "AAAABBaaaabbXX----" TO f-rec
           PERFORM write-f
           MOVE "AAABBBaaabbbXXX---" TO f-rec
           PERFORM write-f
           MOVE "AABBBBaabbbbXXX---" TO f-rec
           PERFORM write-f
           MOVE "ABBBBBabbbbbXXX---" TO f-rec
           PERFORM write-f
           MOVE "BBBBBBbbbbbbXXX---" TO f-rec
           PERFORM write-f

           MOVE "AAB" TO f-key1-1
           MOVE "~~~" TO f-key1-2
           START f KEY = f-key1-1
           READ f NEXT
           IF (f-status <> "00") OR
                   (file1-serial <> 4)
               DISPLAY "FAILED 1: status " f-status "-"
                       "serial: " file1-serial
           END-IF

           MOVE "AAB" TO f-key1-1
           MOVE "~~~" TO f-key1-2
           START f KEY < f-key1-1
           READ f PREVIOUS
           IF (f-status <> "00") OR
                   (file1-serial <> 3)
               DISPLAY "FAILED 2: status " f-status "-"
                       "serial: " file1-serial
           END-IF

           MOVE "AAA" TO f-key1-1
           MOVE "~~~" TO f-key1-2
           START f KEY > f-key1-1
           READ f NEXT
           IF (f-status <> "00") OR
                   (file1-serial <> 4)
               DISPLAY "FAILED 3: status " f-status "-"
                       "serial: " file1-serial
           END-IF

           MOVE "aab" TO f-key2-1
           MOVE "~~~" TO f-key2-2
           START f KEY = f-key2-1
           READ f NEXT
           IF (f-status <> "00") OR
                   (file1-serial <> 4)
               DISPLAY "FAILED 4: status " f-status "-"
                       "serial: " file1-serial
           END-IF

           MOVE "aab" TO f-key2-1
           MOVE "~~~" TO f-key2-2
           START f KEY < f-key2-1
           READ f PREVIOUS
           IF (f-status <> "00") OR
                   (file1-serial <> 3)
               DISPLAY "FAILED 5: status " f-status "-"
                       "serial: " file1-serial
           END-IF

           MOVE "aaa" TO f-key2-1
           MOVE "~~~" TO f-key2-2
           START f KEY > f-key2-1
           READ f NEXT
           IF (f-status <> "00") OR
                   (file1-serial <> 4)
               DISPLAY "FAILED 6: status " f-status "-"
                       "serial: " file1-serial
           END-IF

           MOVE "XX-" TO f-key3-1
           START f KEY > f-key3-1
           READ f NEXT
      *  CHECK: Return file-status "02" if duplicates exist
           IF (f-status <> "02"
      *    Depends on xISAM implementation and the way BDB is used (not yet
      *    implemented in 3.x)
            AND f-status <> "00"
               ) OR file1-serial <> 3
               DISPLAY "FAILED 7: status " f-status "-"
           END-IF
           CLOSE f
           STOP RUN
           .
       write-f.
           MOVE w-serial TO file1-serial
           WRITE f-rec
           ADD 1 TO w-serial
           .
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


# Write records to a file with 3 keys declared. Check files with a subset of the
# keys can access file and that a record added by such files gets indexed for
# the 2nd and 3rd keys.
AT_SETUP([INDEXED undeclared keys])
AT_KEYWORDS([runfile])

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

# real ISAM has the key information and will "fail" one part,
# BDB hasn't and will "pass" this one but fail the other
# -> skip as 4.x feature
AT_SKIP_IF([true])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
       SELECT file1 ASSIGN TO "./fileX"
                    ORGANIZATION INDEXED
                    ACCESS RANDOM
                    RECORD KEY file1-key1
                    ALTERNATE RECORD KEY file1-key2
                    ALTERNATE RECORD KEY file1-key3.
       SELECT file2 ASSIGN TO "./fileX"
                    ORGANIZATION INDEXED
                    ACCESS RANDOM
                    RECORD KEY file2-key1
                    ALTERNATE RECORD KEY file2-key2.
       SELECT file3 ASSIGN TO "./fileX"
                    ORGANIZATION INDEXED
                    ACCESS RANDOM
                    RECORD KEY file3-key1.
       DATA DIVISION.
       FILE SECTION.
       FD file1.
       1  file1-rec.
          2  file1-key1 pic 999.
          2  file1-key2 pic 999.
          2  file1-key3 pic 999.
          2  file1-data pic 999.
       FD file2.
       1  file2-rec.
          2  file2-key1 pic 999.
          2  file2-key2 pic 999.
          2  file2-key3 pic 999.
          2  file2-data pic 999.
       FD file3.
       1  file3-rec.
          2  file3-key1 pic 999.
          2  file3-key2 pic 999.
          2  file3-key3 pic 999.
          2  file3-data pic 999.
       WORKING-STORAGE SECTION.
       77 ix pic 9(6).
       PROCEDURE DIVISION.
          OPEN OUTPUT file1.
          PERFORM VARYING ix FROM 1 BY 1
             UNTIL ix > 10
             MOVE ix TO file1-key1 file1-data
             ADD 100 TO ix GIVING file1-key2
             ADD 200 TO ix GIVING file1-key3
             WRITE file1-rec
          END-PERFORM.
          CLOSE file1.
      *
          OPEN INPUT file1.
          PERFORM VARYING ix FROM 1 BY 1
             UNTIL ix > 10
             MOVE ix TO file1-key1
             READ file1 KEY file1-key1
             IF (file1-data <> ix)
                DISPLAY "FAILED 1-1"
             END-IF
          END-PERFORM.
          PERFORM VARYING ix FROM 1 BY 1
             UNTIL ix > 10
             ADD 100 TO ix GIVING file1-key2
             READ file1 KEY file1-key2
             IF (file1-data <> ix)
                DISPLAY "FAILED 1-2"
             END-IF
          END-PERFORM.
          PERFORM VARYING ix FROM 1 BY 1
             UNTIL ix > 10
             ADD 200 TO ix GIVING file1-key3
             READ file1 KEY file1-key3
             IF (file1-data <> ix)
                DISPLAY "FAILED 1-3"
             END-IF
          END-PERFORM.
          CLOSE file1.
      *
          OPEN INPUT file2.
          PERFORM VARYING ix FROM 1 BY 1
             UNTIL ix > 10
             MOVE ix TO file2-key1
             READ file2 KEY file2-key1
             IF (file2-data <> ix)
                DISPLAY "FAILED 2-1"
             END-IF
          END-PERFORM.
          PERFORM VARYING ix FROM 1 BY 1
             UNTIL ix > 10
             ADD 100 TO ix GIVING file2-key2
             READ file2 KEY file2-key2
             IF (file2-data <> ix)
                DISPLAY "FAILED 2-2"
             END-IF
          END-PERFORM.
          CLOSE file2.
      *
          OPEN INPUT file3.
          PERFORM VARYING ix FROM 1 BY 1
             UNTIL ix > 10
             MOVE ix TO file3-key1
             READ file3 KEY file3-key1
             IF (file3-data <> ix)
                DISPLAY "FAILED 3-1"
             END-IF
          END-PERFORM.
          CLOSE file3.
      *
      *   Insert rec via file with only 1 index declared
          OPEN I-O file3.
          MOVE 20 TO ix.
          MOVE ix TO file3-key1 file3-data
          ADD 100 TO ix GIVING file3-key2
          ADD 200 TO ix GIVING file3-key3
          WRITE file3-rec
          CLOSE file3
      *
      *   Check new rec is visible in other files
          OPEN INPUT file1.
          MOVE 10 TO file1-key1.
          READ file1 KEY file1-key1.
          IF (file1-data <> 10)
             DISPLAY "FAILED 1-4".
          MOVE SPACES TO file1-rec.
          MOVE 110 TO file1-key2.
          READ file1 KEY file1-key2.
          IF (file1-data <> 10)
             DISPLAY "FAILED 1-5".
          MOVE SPACES TO file1-rec.
          MOVE 210 TO file1-key3.
          READ file1 KEY file1-key3.
          IF (file1-data <> 10)
             DISPLAY "FAILED 1-6".
          CLOSE file1.
      *
          OPEN INPUT file2.
          MOVE 10 TO file2-key1.
          READ file2 KEY file2-key1.
          IF (file2-data <> 10)
             DISPLAY "FAILED 2-3".
          MOVE SPACES TO file2-rec.
          MOVE 110 TO file2-key2.
          READ file2 KEY file2-key2.
          IF (file2-data <> 10)
             DISPLAY "FAILED 2-4".
          CLOSE file2.
          STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [1], [],
[libcob: prog.cob:82: error: unknown file error (status = 39) for file file2 ('.' => ./fileX) on OPEN
])
AT_CHECK([COB_KEYCHECK=OFF $COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([READ INPUT pipe & WRITE OUTPUT pipe])
AT_KEYWORDS([runfile])

# only implemented with 4+
AT_XFAIL_IF([true])

AT_DATA([test-data-in],
[NAME
STREET
TOWN
COUNTRY
])

AT_DATA([provider], [
cat $1
])

AT_DATA([consumer], [
cat
])

AT_DATA([prog.cob], [
       identification division.
       program-id. prog.
       environment division.
       configuration section.
       input-output section.
       file-control.
           select pipe-in
               organization line sequential
               access sequential
               assign to w-command
               status is f-status.
           select pipe-out
               organization line sequential
               access sequential
               assign to w-command
               status is f-status.
       data division.
       file section.
       fd  pipe-in.
       1   pipe-msg-in pic x(132).
       fd  pipe-out.
       1   pipe-msg-out pic x(132).
       working-storage section.
       77  f-status pic xx.
           88  f-status-ok value "00".
       77  w-command pic x(100).
       procedure division.
           move "< sh ./provider ./test-data-in"
             to w-command.
           open input pipe-in.
           if not f-status-ok
              display "FAILED: OPEN INPUT"
              stop run
           end-if.
           move "> sh ./consumer > ./test-data-out"
             to w-command.
           open output pipe-out.
           if not f-status-ok
              display "FAILED: OPEN OUTPUT"
              stop run
           end-if.
           perform until not f-status-ok
              read pipe-in
              if f-status-ok
                 perform x01-100-map
                 write pipe-msg-out
              end-if
           end-perform.
           close pipe-in.
           close pipe-out.
           stop run.
      *
       x01-100-map.
           move "*** Jacques Tati ***" to pipe-msg-out.
           if (pipe-msg-in = "COUNTRY")
              move "Country: FRANCE" to pipe-msg-out.
           if (pipe-msg-in = "TOWN")
              move "Town: DEAUVILLE" to pipe-msg-out.
           if (pipe-msg-in = "NAME")
              move "Name: M. Hulot" to pipe-msg-out.
           if (pipe-msg-in = "STREET")
              move "Street: Rue des Anglais" to pipe-msg-out.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([cat test-data-out], [0],
[Name: M. Hulot
Street: Rue des Anglais
Town: DEAUVILLE
Country: FRANCE
])

AT_CLEANUP


AT_SETUP([EXTFH: using ISAM callback])
AT_KEYWORDS([runfile EXTFH indexed])

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.

       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.

       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT OPTIONAL TSPFILE
           ASSIGN TO "testisam"
           ORGANIZATION INDEXED ACCESS DYNAMIC
           RECORD KEY IS CM-CUST-NUM
           ALTERNATE RECORD KEY IS CM-TELEPHONE WITH DUPLICATES
           ALTERNATE RECORD KEY IS CM-DISK WITH DUPLICATES
           FILE STATUS IS CUST-STAT .

           SELECT TSTFILE
           ASSIGN TO "testisam"
           ORGANIZATION INDEXED ACCESS DYNAMIC
           RECORD KEY IS TS-CUST-NUM
           ALTERNATE RECORD KEY IS TS-TELEPHONE WITH DUPLICATES
           ALTERNATE RECORD KEY IS TS-DISK WITH DUPLICATES
           FILE STATUS IS CUST-STAT .

           SELECT FLATFILE ASSIGN EXTERNAL RELFIX
           ORGANIZATION RELATIVE
           ACCESS IS RANDOM RELATIVE KEY IS REC-NUM
           FILE STATUS IS CUST-STAT.

       DATA  DIVISION.
       FILE SECTION.
       FD  TSPFILE
           BLOCK CONTAINS 5 RECORDS.

       01  TSPFL-RECORD.
           05  TSPFL-REC.
           10  CM-CUST-NUM.
             15  CM-CUST-PRE                   PICTURE X(3).
             15  CM-CUST-NNN                   PICTURE X(5).
           10  CM-STATUS                       PICTURE X.
           10  CM-COMPANY                      PICTURE X(25).
           10  CM-ADDRESS-1                    PICTURE X(25).
           10  CM-ADDRESS-2                    PICTURE X(25).
           10  CM-ADDRESS-3                    PICTURE X(25).
           10  CM-TELEPHONE                    PICTURE 9(10).
           10  CM-DP-MGR                       PICTURE X(25).
           10  CM-MACHINE                      PICTURE X(8).
           10  CM-MEMORY                       PICTURE X(4).
           10  CM-DISK                         PICTURE X(8).
           10  CM-TAPE                         PICTURE X(8).
           10  CM-NO-TERMINALS                 PICTURE 9(5).

       FD  TSTFILE
           BLOCK CONTAINS 5 RECORDS.

       01  TSTFL-RECORD.
           05  TSTFL-REC.
           10  TS-CUST-NUM                     PICTURE X(8).
           10  TS-STATUS                       PICTURE X.
           10  TS-COMPANY                      PICTURE X(25).
           10  TS-ADDRESS-1                    PICTURE X(25).
           10  TS-ADDRESS-2                    PICTURE X(25).
           10  TS-ADDRESS-3                    PICTURE X(25).
           10  TS-TELEPHONE                    PICTURE 9(10).
           10  TS-DP-MGR                       PICTURE X(25).
           10  TS-MACHINE                      PICTURE X(8).
           10  TS-MEMORY                       PICTURE X(4).
           10  TS-DISK                         PICTURE X(8).
           10  TS-TAPE                         PICTURE X(8).

       FD  FLATFILE
           BLOCK CONTAINS 5 RECORDS.

       01  TSP2-RECORD.
           10  C2-CUST-NUM                     PICTURE X(8).
           10  C2-COMPANY                      PICTURE X(25).
           10  C2-DISK                         PICTURE X(8).
           10  C2-NO-TERMINALS                 PICTURE 9(4) COMP-4.
           10  C2-PK-DATE                      PICTURE S9(14) COMP-3.

       WORKING-STORAGE SECTION.

       01  CUST-STAT.
           05  FILLER PICTURE XX.
       78  MAX-SUB           VALUE  16.

       01  TEST-DATA.

         02  DATA-CUST-NUM-TBL.

           05  FILLER PIC X(8) VALUE "ALP00000".
           05  FILLER PIC X(8) VALUE "BET00000".
           05  FILLER PIC X(8) VALUE "GAM00000".
           05  FILLER PIC X(8) VALUE "DEL00000".
           05  FILLER PIC X(8) VALUE "EPS00000".
           05  FILLER PIC X(8) VALUE "FOR00000".
           05  FILLER PIC X(8) VALUE "GIB00000".
           05  FILLER PIC X(8) VALUE "H&J00000".
           05  FILLER PIC X(8) VALUE "INC00000".
           05  FILLER PIC X(8) VALUE "JOH00000".
           05  FILLER PIC X(8) VALUE "KON00000".
           05  FILLER PIC X(8) VALUE "LEW00000".
           05  FILLER PIC X(8) VALUE "MOR00000".
           05  FILLER PIC X(8) VALUE "NEW00000".
           05  FILLER PIC X(8) VALUE "OLD00000".
           05  FILLER PIC X(8) VALUE "PRE00000".

         02  DATA-CUST-NUM REDEFINES DATA-CUST-NUM-TBL
                                       PIC X(8) OCCURS MAX-SUB.
         02  DATA-COMPANY-TBL.

           05  FILLER PIC X(25) VALUE "ALPHA ELECTRICAL CO. LTD.".
           05  FILLER PIC X(25) VALUE "BETA SHOE MFG. INC.      ".
           05  FILLER PIC X(25) VALUE "GAMMA X-RAY TECHNOLOGY   ".
           05  FILLER PIC X(25) VALUE "DELTA LUGGAGE REPAIRS    ".
           05  FILLER PIC X(25) VALUE "EPSILON EQUIPMENT SUPPLY ".
           05  FILLER PIC X(25) VALUE "FORTUNE COOKIE COMPANY   ".
           05  FILLER PIC X(25) VALUE "GIBRALTER LIFE INSURANCE ".
           05  FILLER PIC X(25) VALUE "H & J PLUMBING SUPPLIES  ".
           05  FILLER PIC X(25) VALUE "INCREMENTAL BACKUP CORP. ".
           05  FILLER PIC X(25) VALUE "JOHNSON BOATING SUPPLIES ".
           05  FILLER PIC X(25) VALUE "KONFLAB PLASTIC PRODUCTS.".
           05  FILLER PIC X(25) VALUE "LEWISTON GRAPHICS LTD.   ".
           05  FILLER PIC X(25) VALUE "MORNINGSIDE CARPENTRY.   ".
           05  FILLER PIC X(25) VALUE "NEW WAVE SURF SHOPS INC. ".
           05  FILLER PIC X(25) VALUE "OLD TYME PIZZA MFG. CO.  ".
           05  FILLER PIC X(25) VALUE "PRESTIGE OFFICE FURNITURE".

         02  DATA-COMPANY  REDEFINES DATA-COMPANY-TBL
                                       PIC X(25) OCCURS MAX-SUB.
         02  DATA-ADDRESS-1-TBL.

           05  FILLER PIC X(25) VALUE "123 MAIN STREET          ".
           05  FILLER PIC X(25) VALUE "1090 2ND AVE. WEST       ".
           05  FILLER PIC X(25) VALUE "1401 JEFFERSON BLVD.     ".
           05  FILLER PIC X(25) VALUE "1620 ARIZONA WAY         ".
           05  FILLER PIC X(25) VALUE "1184 EAST FIRST STREET   ".
           05  FILLER PIC X(25) VALUE "114 JOHN F. KENNEDY AVE. ".
           05  FILLER PIC X(25) VALUE "650 LIBERTY CRESCENT     ".
           05  FILLER PIC X(25) VALUE "77 SUNSET BLVD.          ".
           05  FILLER PIC X(25) VALUE "10908 SANTA MONICA BLVD. ".
           05  FILLER PIC X(25) VALUE "1134 PARIS ROAD          ".
           05  FILLER PIC X(25) VALUE "808 NORTHWEST MAIN ST.   ".
           05  FILLER PIC X(25) VALUE "9904 QUEEN STREET        ".
           05  FILLER PIC X(25) VALUE "1709 DUNDAS CRESCENT W.  ".
           05  FILLER PIC X(25) VALUE "3240 MARIS AVENUE        ".
           05  FILLER PIC X(25) VALUE "1705 WISCONSIN ROAD      ".
           05  FILLER PIC X(25) VALUE "114A MAPLE GROVE         ".

         02  DATA-ADDRESS-1 REDEFINES DATA-ADDRESS-1-TBL
                                       PIC X(25) OCCURS MAX-SUB.
         02  DATA-ADDRESS-2-TBL.

           05  FILLER PIC X(10) VALUE "NEW YORK  ".
           05  FILLER PIC X(10) VALUE "ATLANTA   ".
           05  FILLER PIC X(10) VALUE "WASHINGTON".
           05  FILLER PIC X(10) VALUE "TORONTO   ".
           05  FILLER PIC X(10) VALUE "CALGARY   ".
           05  FILLER PIC X(10) VALUE "SAN DIEGO ".
           05  FILLER PIC X(10) VALUE "LOS RIOS  ".
           05  FILLER PIC X(10) VALUE "MADISON   ".
           05  FILLER PIC X(10) VALUE "WILBUR    ".
           05  FILLER PIC X(10) VALUE "TOPEKA    ".
           05  FILLER PIC X(10) VALUE "SEATTLE   ".
           05  FILLER PIC X(10) VALUE "NEW JERSEY".
           05  FILLER PIC X(10) VALUE "FORT WAYNE".
           05  FILLER PIC X(10) VALUE "COLUMBUS  ".
           05  FILLER PIC X(10) VALUE "RICHMOND  ".
           05  FILLER PIC X(10) VALUE "WHITEPLAIN".

         02  DATA-ADDRESS-2 REDEFINES DATA-ADDRESS-2-TBL
                                       PIC X(10) OCCURS MAX-SUB.
         02  DATA-ADDRESS-3-TBL.

           05  FILLER PIC X(10) VALUE "N.Y.      ".
           05  FILLER PIC X(10) VALUE "GEORGIA   ".
           05  FILLER PIC X(10) VALUE "D.C.      ".
           05  FILLER PIC X(10) VALUE "CANADA    ".
           05  FILLER PIC X(10) VALUE "CANADA    ".
           05  FILLER PIC X(10) VALUE "CALIFORNIA".
           05  FILLER PIC X(10) VALUE "NEW MEXICO".
           05  FILLER PIC X(10) VALUE "WISCONSIN ".
           05  FILLER PIC X(10) VALUE "DELAWARE  ".
           05  FILLER PIC X(10) VALUE "KANSAS    ".
           05  FILLER PIC X(10) VALUE "WASHINGTON".
           05  FILLER PIC X(10) VALUE "N.J.      ".
           05  FILLER PIC X(10) VALUE "COLORADO  ".
           05  FILLER PIC X(10) VALUE "OHIO      ".
           05  FILLER PIC X(10) VALUE "VIRGINIA  ".
           05  FILLER PIC X(10) VALUE "N.Y.      ".

         02  DATA-ADDRESS-3 REDEFINES DATA-ADDRESS-3-TBL
                                       PIC X(10) OCCURS MAX-SUB.
         02  DATA-TELEPHONE-TBL.

           05  FILLER PIC 9(10) VALUE 3131234432.
           05  FILLER PIC 9(10) VALUE 4082938498.
           05  FILLER PIC 9(10) VALUE 8372487274.
           05  FILLER PIC 9(10) VALUE 4169898509.
           05  FILLER PIC 9(10) VALUE 5292398745.
           05  FILLER PIC 9(10) VALUE 8009329492.
           05  FILLER PIC 9(10) VALUE 6456445643.
           05  FILLER PIC 9(10) VALUE 6546456333.
           05  FILLER PIC 9(10) VALUE 3455445444.
           05  FILLER PIC 9(10) VALUE 6456445643.
           05  FILLER PIC 9(10) VALUE 7456434355.
           05  FILLER PIC 9(10) VALUE 6554456433.
           05  FILLER PIC 9(10) VALUE 4169898509.
           05  FILLER PIC 9(10) VALUE 7534587453.
           05  FILLER PIC 9(10) VALUE 8787458374.
           05  FILLER PIC 9(10) VALUE 4169898509.

         02  DATA-TELEPHONE REDEFINES DATA-TELEPHONE-TBL
                                       PIC 9(10) OCCURS MAX-SUB.
         02  DATA-DP-MGR-TBL.

           05  FILLER PIC X(20) VALUE "MR. DAVE HARRIS     ".
           05  FILLER PIC X(20) VALUE "MS. JANICE SILCOX   ".
           05  FILLER PIC X(20) VALUE "MR. ALLAN JONES     ".
           05  FILLER PIC X(20) VALUE "MR. PETER MACKAY    ".
           05  FILLER PIC X(20) VALUE "MRS. DONNA BREWER   ".
           05  FILLER PIC X(20) VALUE "MR. MICHAEL SMYTHE  ".
           05  FILLER PIC X(20) VALUE "MR. D.A. MORRISON   ".
           05  FILLER PIC X(20) VALUE "MR. BRIAN PATTERSON ".
           05  FILLER PIC X(20) VALUE "MR. DARRYL TOWNSEND ".
           05  FILLER PIC X(20) VALUE "MS. VALERIE HARPER  ".
           05  FILLER PIC X(20) VALUE "MR. FRED MILLER     ".
           05  FILLER PIC X(20) VALUE "MR. DONALD FISCHER  ".
           05  FILLER PIC X(20) VALUE "MR. STEVEN YOURDIN  ".
           05  FILLER PIC X(20) VALUE "MS. Goldie Hawn     ".
           05  FILLER PIC X(20) VALUE "MS. ALICE WINSTON   ".
           05  FILLER PIC X(20) VALUE "MR. THOMAS JEFFERSON".

         02  DATA-DP-MGR    REDEFINES DATA-DP-MGR-TBL
                                       PIC X(20) OCCURS MAX-SUB.
         02  DATA-MACHINE-TBL.

           05  FILLER PIC X(8) VALUE "UNI-9030".
           05  FILLER PIC X(8) VALUE "UNI-9040".
           05  FILLER PIC X(8) VALUE "UNI-80/3".
           05  FILLER PIC X(8) VALUE "UNI-80/5".
           05  FILLER PIC X(8) VALUE "UNI-80/6".
           05  FILLER PIC X(8) VALUE "UNI-80/6".
           05  FILLER PIC X(8) VALUE "UNI-80/6".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-9040".
           05  FILLER PIC X(8) VALUE "UNI-9040".

         02  DATA-MACHINE   REDEFINES DATA-MACHINE-TBL
                                       PIC X(8) OCCURS MAX-SUB.
         02  DATA-NO-TERMINALS-TBL.

           05  FILLER PIC 9(3) COMP-3 VALUE 85.
           05  FILLER PIC 9(3) COMP-3 VALUE 34.
           05  FILLER PIC 9(3) COMP-3 VALUE 75.
           05  FILLER PIC 9(3) COMP-3 VALUE 45.
           05  FILLER PIC 9(3) COMP-3 VALUE 90.
           05  FILLER PIC 9(3) COMP-3 VALUE 107.
           05  FILLER PIC 9(3) COMP-3 VALUE 67.
           05  FILLER PIC 9(3) COMP-3 VALUE 32.
           05  FILLER PIC 9(3) COMP-3 VALUE 16.
           05  FILLER PIC 9(3) COMP-3 VALUE 34.
           05  FILLER PIC 9(3) COMP-3 VALUE 128.
           05  FILLER PIC 9(3) COMP-3 VALUE 64.
           05  FILLER PIC 9(3) COMP-3 VALUE 110.
           05  FILLER PIC 9(3) COMP-3 VALUE 324.
           05  FILLER PIC 9(3) COMP-3 VALUE 124.
           05  FILLER PIC 9(3) COMP-3 VALUE 86.

         02  DATA-NO-TERMINALS REDEFINES DATA-NO-TERMINALS-TBL
                                       PIC 9(3) COMP-3 OCCURS MAX-SUB.

       78  REC-MAX                     VALUE 10.
       01  WORK-AREA.
           05  REC-NUM                 BINARY-SHORT UNSIGNED VALUE 0.
           05  SUB                     BINARY-SHORT UNSIGNED.
               88  ODD-RECORD                  VALUE 1 3 5 7 9 10 11.

           05  TSPFL-KEY                       PICTURE X(8).

       PROCEDURE DIVISION.

       MAINFILE.
           OPEN OUTPUT TSPFILE
           CLOSE TSPFILE.

           OPEN I-O TSPFILE
           MOVE '99' TO CUST-STAT
           READ  TSPFILE NEXT RECORD WITH NO LOCK
           IF CUST-STAT NOT = "10"
               DISPLAY "Error " CUST-STAT " on read of empty file"
                                UPON CONSOLE
               STOP RUN
           END-IF.
           MOVE LOW-VALUES                     TO TSPFL-RECORD.
           START TSPFILE KEY GREATER THAN CM-CUST-NUM
           IF CUST-STAT NOT = "23"
               DISPLAY "Error " CUST-STAT " starting empty file"
                                UPON CONSOLE
               STOP RUN
           END-IF.
           READ  TSPFILE NEXT RECORD WITH NO LOCK
           IF CUST-STAT NOT = "46"
               DISPLAY "Error " CUST-STAT " start/read of empty file"
                                UPON CONSOLE
               STOP RUN
           END-IF.
           DISPLAY "OK: Operations on empty file"
           CLOSE TSPFILE.

           PERFORM LOADFILE.
           PERFORM LISTFILE.
           OPEN INPUT TSTFILE
           IF CUST-STAT NOT = "00"
               DISPLAY "Expected ERROR " CUST-STAT
                       " opening TSTFILE, Record size different"
                       UPON CONSOLE
           ELSE
               DISPLAY "Un-Expected open TSTFILE, Record size different"
                       UPON CONSOLE
               CLOSE TSTFILE
           END-IF.
           PERFORM LOADFLAT.
           STOP RUN.

       LOADFILE.
           DISPLAY "Loading sample data file."
                            UPON CONSOLE.

           OPEN OUTPUT TSPFILE
           IF CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT
               " opening 'testisam' file" UPON CONSOLE
               STOP RUN
           END-IF.

           PERFORM 1000-LOAD-RECORD
                        VARYING SUB FROM 1 BY 1
                          UNTIL SUB > MAX-SUB.

           DISPLAY "Sample data file load complete."
                            UPON CONSOLE.
           CLOSE TSPFILE.

      *---------------------------------------------------------------*
      *         LOAD A RECORD FROM DATA TABLES                        *
      *---------------------------------------------------------------*

       1000-LOAD-RECORD.

           MOVE SPACES                       TO TSPFL-RECORD.
           MOVE DATA-CUST-NUM      (SUB)     TO CM-CUST-NUM.
           MOVE CM-CUST-NUM                  TO TSPFL-KEY.
           MOVE DATA-COMPANY       (SUB)     TO CM-COMPANY.
           MOVE DATA-ADDRESS-1     (SUB)     TO CM-ADDRESS-1.
           MOVE DATA-ADDRESS-2     (SUB)     TO CM-ADDRESS-2.
           MOVE DATA-ADDRESS-3     (SUB)     TO CM-ADDRESS-3.
           MOVE DATA-TELEPHONE     (SUB)     TO CM-TELEPHONE.
           MOVE DATA-DP-MGR        (SUB)     TO CM-DP-MGR.
           MOVE DATA-MACHINE       (SUB)     TO CM-MACHINE.
           MOVE DATA-NO-TERMINALS  (SUB)     TO CM-NO-TERMINALS.

           IF  ODD-RECORD
               MOVE "8417"                   TO CM-DISK
               MOVE "1600 BPI"               TO CM-TAPE
               MOVE "1MEG"                   TO CM-MEMORY
           ELSE
               MOVE "8470"                   TO CM-DISK
               MOVE "6250 BPI"               TO CM-TAPE
               MOVE "3MEG"                   TO CM-MEMORY.

           WRITE TSPFL-RECORD.
           IF CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Load - Key: " TSPFL-KEY ", Status: " CUST-STAT
                                 UPON CONSOLE.

       LISTFILE.
           DISPLAY "LIST SAMPLE FILE" UPON CONSOLE.
           OPEN INPUT TSTFILE
           MOVE SPACES                       TO TSTFL-RECORD.
           MOVE "PRE00000" TO CM-CUST-NUM.
           START TSTFILE KEY GREATER THAN OR EQUAL TO TS-CUST-NUM
           READ  TSTFILE NEXT RECORD
           READ  TSTFILE NEXT RECORD
           CLOSE TSTFILE.

           MOVE ZERO TO REC-NUM
           OPEN INPUT TSPFILE
           IF CUST-STAT NOT = "00"
               DISPLAY "ERROR " CUST-STAT " OPENING INPUT FILE"
                                             UPON CONSOLE
               STOP RUN
           END-IF.
           MOVE SPACES                       TO TSPFL-RECORD.
           MOVE "PRE00000" TO CM-CUST-NUM.
           START TSPFILE KEY GREATER THAN OR EQUAL TO CM-CUST-NUM
           READ  TSPFILE NEXT RECORD
           READ  TSPFILE NEXT RECORD

           MOVE SPACES                       TO TSPFL-RECORD.
           MOVE "DEL00000" TO CM-CUST-NUM.
           START TSPFILE KEY GREATER THAN CM-CUST-NUM
           IF CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " starting file"
                                UPON CONSOLE
               STOP RUN
           END-IF.
           READ  TSPFILE NEXT RECORD WITH NO LOCK
           IF CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " on 1st read of file"
                                UPON CONSOLE
               STOP RUN
           END-IF.
           PERFORM UNTIL CUST-STAT NOT = "00"
                      OR REC-NUM > REC-MAX
               DISPLAY "Key: " CM-CUST-NUM " is " CM-COMPANY
                        " Disk=" CM-DISK "."
                         UPON CONSOLE
               READ TSPFILE NEXT RECORD
                    AT END
                        MOVE "99" TO CUST-STAT
                END-READ
                ADD 1 TO REC-NUM
           END-PERFORM
           IF CUST-STAT = "99"
               DISPLAY "Hit End of File" UPON CONSOLE
           END-IF.

           DISPLAY "LIST SAMPLE FILE DESCENDING" UPON CONSOLE.
           MOVE ZERO TO REC-NUM
           START TSPFILE KEY LESS THAN CM-CUST-NUM
           IF CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " starting file"
                                UPON CONSOLE
               STOP RUN
           END-IF.
           READ  TSPFILE PREVIOUS RECORD WITH NO LOCK
           IF CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " on 1st read of file"
                                UPON CONSOLE
               STOP RUN
           END-IF.
           PERFORM UNTIL CUST-STAT NOT = "00"
                      OR REC-NUM > REC-MAX
               DISPLAY "Key: " CM-CUST-NUM " is " CM-COMPANY
                        " Disk=" CM-DISK "."
                         UPON CONSOLE
               READ TSPFILE PREVIOUS RECORD
                    AT END
                        MOVE "99" TO CUST-STAT
                END-READ
                ADD 1 TO REC-NUM
           END-PERFORM.

           CLOSE TSPFILE.

           OPEN I-O TSPFILE.
           MOVE SPACES                       TO TSPFL-RECORD.
           MOVE DATA-CUST-NUM      (2)       TO CM-CUST-NUM.
           MOVE 'X'                          TO CM-CUST-NUM (5:1).
           READ TSPFILE KEY IS CM-CUST-NUM
           IF  CUST-STAT NOT = "23"
               DISPLAY "Error " CUST-STAT " instead of 23."
                                UPON CONSOLE
           END-IF.
           MOVE DATA-CUST-NUM      (2)       TO CM-CUST-NUM.
           MOVE DATA-COMPANY       (2)       TO CM-COMPANY.
           READ TSPFILE KEY IS CM-CUST-NUM
           IF  CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " on primary read ."
                                UPON CONSOLE
           ELSE
               DISPLAY "Got: " CM-CUST-NUM " is " CM-COMPANY
                        " Disk=" CM-DISK "."
                         UPON CONSOLE
           END-IF.
           READ TSPFILE NEXT RECORD
           IF  CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " on next read"
                                UPON CONSOLE
           ELSE
               DISPLAY "Nxt: " CM-CUST-NUM " is " CM-COMPANY
                        " Disk=" CM-DISK "."
                         UPON CONSOLE
           END-IF.
           MOVE DATA-TELEPHONE     (7)       TO CM-TELEPHONE.
           MOVE DATA-MACHINE       (7)       TO CM-MACHINE.
           READ TSPFILE KEY IS CM-TELEPHONE
           IF  CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " instead of 23"
                                UPON CONSOLE
           ELSE
               DISPLAY "Ky2: " CM-CUST-NUM " is " CM-COMPANY
                        " Mach=" CM-MACHINE "."
                         UPON CONSOLE
           END-IF.
           WRITE TSPFL-RECORD
           IF  CUST-STAT NOT = "22"
               DISPLAY "Error " CUST-STAT " instead of 22"
                                UPON CONSOLE
           ELSE
               DISPLAY "  Write: " CM-CUST-NUM " got 22 as expected"
                         UPON CONSOLE
           END-IF.
           MOVE DATA-CUST-NUM      (3)       TO CM-CUST-NUM.
           MOVE DATA-COMPANY       (3)       TO CM-COMPANY.
           READ TSPFILE KEY IS CM-CUST-NUM
           DISPLAY "   Read: " CM-CUST-NUM " got "
                         CUST-STAT " as expected "
                         CM-NO-TERMINALS " terminals"
                         UPON CONSOLE.
           ADD 5 TO CM-NO-TERMINALS
           REWRITE TSPFL-RECORD
           IF  CUST-STAT NOT = "02"
           AND CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " instead of 02"
                                UPON CONSOLE
           ELSE
               DISPLAY "ReWrite: " CM-CUST-NUM " got "
                         "00/02 as expected "
                         CM-NO-TERMINALS " terminals"
                         UPON CONSOLE
           END-IF.
           MOVE DATA-CUST-NUM      (2)       TO CM-CUST-NUM.
           MOVE DATA-COMPANY       (2)       TO CM-COMPANY.
           READ TSPFILE KEY IS CM-CUST-NUM
           DISPLAY "   Read: " CM-CUST-NUM " got "
                         CUST-STAT " as expected "
                         CM-NO-TERMINALS " terminals"
                         UPON CONSOLE.
           MOVE DATA-CUST-NUM      (3)       TO CM-CUST-NUM.
           MOVE DATA-COMPANY       (3)       TO CM-COMPANY.
           REWRITE TSPFL-RECORD
           IF  CUST-STAT NOT = "02"
           AND CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " instead of 02"
                                UPON CONSOLE
           ELSE
               DISPLAY "ReWrite: " CM-CUST-NUM " got "
                       "00/02 as expected"
                         UPON CONSOLE
           END-IF.
           MOVE DATA-CUST-NUM      (6)       TO CM-CUST-NUM.
           MOVE DATA-COMPANY       (6)       TO CM-COMPANY.
           READ TSPFILE KEY IS CM-CUST-NUM
           MOVE DATA-TELEPHONE     (7)       TO CM-TELEPHONE.
           MOVE DATA-MACHINE       (7)       TO CM-MACHINE.
           REWRITE TSPFL-RECORD
           IF  CUST-STAT NOT = "02"
           AND CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " instead of 02"
                                UPON CONSOLE
           ELSE
               DISPLAY "ReWrite: " CM-CUST-NUM " got "
                        "00/02 as expected"
                         UPON CONSOLE
           END-IF.
           DELETE TSPFILE.
           CLOSE TSPFILE.

       LOADFLAT.
           OPEN OUTPUT FLATFILE.
           PERFORM FLAT-RECORD
                        VARYING SUB FROM 1 BY 1
                          UNTIL SUB > MAX-SUB
                             OR SUB > 5.
           CLOSE FLATFILE.
           OPEN INPUT FLATFILE.
           MOVE 3 TO REC-NUM
           READ FLATFILE
           MOVE 999 TO REC-NUM
           READ FLATFILE
           CLOSE FLATFILE.

       FLAT-RECORD.

           MOVE SPACES                       TO TSP2-RECORD.
           MOVE SUB                          TO REC-NUM.
           MOVE DATA-CUST-NUM      (SUB)     TO C2-CUST-NUM.
           MOVE DATA-COMPANY       (SUB)     TO C2-COMPANY.
           MOVE DATA-NO-TERMINALS  (SUB)     TO C2-NO-TERMINALS.
           MOVE 20070319                     TO C2-PK-DATE.
           IF  ODD-RECORD
               MOVE "8417"                   TO C2-DISK
           ELSE
               MOVE "8470"                   TO C2-DISK.
           WRITE TSP2-RECORD.
])

AT_DATA([cmod.c], [[
#include <stdio.h>
#include <libcob.h>

static char *txtOpCode(int opCode);

/*********************************************************
 *  TSTFH - External File Handler entry point.
*********************************************************/

COB_EXT_EXPORT int
TSTFH (unsigned char *opCodep, FCD3 *fcd)
{
   unsigned int   opCode;

   if (*opCodep == 0xfa)
      opCode = 0xfa00 + opCodep[1];
   else
      opCode = opCodep[1];

   if (fcd->fileOrg == ORG_LINE_SEQ
    || fcd->fileOrg == ORG_SEQ
    || fcd->fileOrg == ORG_INDEXED
    || fcd->fileOrg == ORG_RELATIVE) {
      switch (opCode) {
      case OP_OPEN_OUTPUT:
      case OP_OPEN_IO:
      case OP_OPEN_EXTEND:
      case OP_OPEN_OUTPUT_NOREWIND:
         return EXTFH(opCodep, fcd);
         break;

      case OP_OPEN_INPUT:
      case OP_OPEN_INPUT_NOREWIND:
      case OP_OPEN_INPUT_REVERSED:
         return EXTFH(opCodep, fcd);
         break;

      default:
         break;
      }

   }

   if (opCode == OP_CLOSE
    && (fcd->openMode & OPEN_NOT_OPEN) ) {
      return 0;
   }

   return EXTFH(opCodep, fcd);
}
]])

AT_CHECK([$COMPILE -fcallfh=TSTFH prog.cob cmod.c], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[OK: Operations on empty file
Loading sample data file.
Sample data file load complete.
LIST SAMPLE FILE
Key: EPS00000 is EPSILON EQUIPMENT SUPPLY  Disk=8417    .
Key: FOR00000 is FORTUNE COOKIE COMPANY    Disk=8470    .
Key: GAM00000 is GAMMA X-RAY TECHNOLOGY    Disk=8417    .
Key: GIB00000 is GIBRALTER LIFE INSURANCE  Disk=8417    .
Key: H&J00000 is H & J PLUMBING SUPPLIES   Disk=8470    .
Key: INC00000 is INCREMENTAL BACKUP CORP.  Disk=8417    .
Key: JOH00000 is JOHNSON BOATING SUPPLIES  Disk=8417    .
Key: KON00000 is KONFLAB PLASTIC PRODUCTS. Disk=8417    .
Key: LEW00000 is LEWISTON GRAPHICS LTD.    Disk=8470    .
Key: MOR00000 is MORNINGSIDE CARPENTRY.    Disk=8470    .
Key: NEW00000 is NEW WAVE SURF SHOPS INC.  Disk=8470    .
LIST SAMPLE FILE DESCENDING
Key: NEW00000 is NEW WAVE SURF SHOPS INC.  Disk=8470    .
Key: MOR00000 is MORNINGSIDE CARPENTRY.    Disk=8470    .
Key: LEW00000 is LEWISTON GRAPHICS LTD.    Disk=8470    .
Key: KON00000 is KONFLAB PLASTIC PRODUCTS. Disk=8417    .
Key: JOH00000 is JOHNSON BOATING SUPPLIES  Disk=8417    .
Key: INC00000 is INCREMENTAL BACKUP CORP.  Disk=8417    .
Key: H&J00000 is H & J PLUMBING SUPPLIES   Disk=8470    .
Key: GIB00000 is GIBRALTER LIFE INSURANCE  Disk=8417    .
Key: GAM00000 is GAMMA X-RAY TECHNOLOGY    Disk=8417    .
Key: FOR00000 is FORTUNE COOKIE COMPANY    Disk=8470    .
Key: EPS00000 is EPSILON EQUIPMENT SUPPLY  Disk=8417    .
Got: BET00000 is BETA SHOE MFG. INC.       Disk=8470    .
Nxt: DEL00000 is DELTA LUGGAGE REPAIRS     Disk=8470    .
Ky2: GIB00000 is GIBRALTER LIFE INSURANCE  Mach=UNI-80/6.
  Write: GIB00000 got 22 as expected
   Read: GAM00000 got 00 as expected 00075 terminals
ReWrite: GAM00000 got 00/02 as expected 00080 terminals
   Read: BET00000 got 00 as expected 00034 terminals
ReWrite: GAM00000 got 00/02 as expected
ReWrite: FOR00000 got 00/02 as expected
Expected ERROR 39 opening TSTFILE, Record size different
], [])

AT_CLEANUP


AT_SETUP([EXTFH: Indexed with FH--FCD])
AT_KEYWORDS([runfile EXTFH FCDREG FH--KEYDEF isam])

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.

       PROGRAM-ID. prog.

       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.

      $set fcdreg
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT TSPFILE
           ASSIGN TO "mytstisam"
           ORGANIZATION INDEXED ACCESS DYNAMIC
           RECORD KEY IS PRIME-KEY
           SOURCE IS CM-CUST-NUM

           ALTERNATE RECORD KEY IS SPLIT-KEY2
           SOURCE IS CM-TELEPHONE,CM-MACHINE
      *         WITH DUPLICATES

           ALTERNATE RECORD KEY IS SPLIT-KEY3
           SOURCE IS CM-DISK,CM-TAPE
      *         WITH DUPLICATES
      *         SUPPRESS WHEN ALL "*"
           FILE STATUS IS CUST-STAT
           .

       DATA  DIVISION.
       FILE SECTION.
       FD  TSPFILE
           BLOCK CONTAINS 5 RECORDS.

       01  TSPFL-RECORD.
           05  TSPFL-REC.
           10  CM-CUST-NUM.
             15  CM-CUST-PRE                   PICTURE X(3).
             15  CM-CUST-NNN                   PICTURE X(5).
           10  CM-STATUS                       PICTURE X.
           10  CM-COMPANY                      PICTURE X(25).
           10  CM-ADDRESS-1                    PICTURE X(25).
           10  CM-ADDRESS-2                    PICTURE X(25).
           10  CM-ADDRESS-3                    PICTURE X(25).
           10  CM-TELEPHONE                    PICTURE 9(10).
           10  CM-DP-MGR                       PICTURE X(25).
           10  CM-MACHINE                      PICTURE X(8).
           10  CM-MEMORY                       PICTURE X(4).
           10  CM-DISK                         PICTURE X(8).
           10  CM-TAPE                         PICTURE X(8).
           10  CM-NO-TERMINALS                 PICTURE 9(5).

       WORKING-STORAGE SECTION.
       01  CUST-STAT.
           05  STAT-1 PICTURE 9(4) COMP SYNC.
           05  FILLER REDEFINES STAT-1.
               10  STAT-X1 PIC X COMP-X.
               10  STAT-X2 PIC X COMP-X.
       77  BYTE-1  PICTURE 9(3).
       77  BYTE-2  PICTURE 9(3).
       78  MAX-SUB           VALUE  16.
       77  IDX                                 PICTURE 9.
       77  IDX2                                PICTURE 9.
       77  OUT-FILE-NAME                       PICTURE X(9)
           VALUE "myextisam".

       01  TEST-DATA.

         02  DATA-CUST-NUM-TBL.

           05  FILLER PIC X(8) VALUE "ALP00000".
           05  FILLER PIC X(8) VALUE "BET00000".
           05  FILLER PIC X(8) VALUE "GAM00000".
           05  FILLER PIC X(8) VALUE "DEL00000".
           05  FILLER PIC X(8) VALUE "EPS00000".
           05  FILLER PIC X(8) VALUE "FOR00000".
           05  FILLER PIC X(8) VALUE "GIB00000".
           05  FILLER PIC X(8) VALUE "H&J00000".
           05  FILLER PIC X(8) VALUE "INC00000".
           05  FILLER PIC X(8) VALUE "JOH00000".
           05  FILLER PIC X(8) VALUE "KON00000".
           05  FILLER PIC X(8) VALUE "LEW00000".
           05  FILLER PIC X(8) VALUE "MOR00000".
           05  FILLER PIC X(8) VALUE "NEW00000".
           05  FILLER PIC X(8) VALUE "OLD00000".
           05  FILLER PIC X(8) VALUE "PRE00000".

         02  DATA-CUST-NUM REDEFINES DATA-CUST-NUM-TBL
                                       PIC X(8) OCCURS MAX-SUB.
         02  DATA-COMPANY-TBL.

           05  FILLER PIC X(25) VALUE "ALPHA ELECTRICAL CO. LTD.".
           05  FILLER PIC X(25) VALUE "BETA SHOE MFG. INC.      ".
           05  FILLER PIC X(25) VALUE "GAMMA X-RAY TECHNOLOGY   ".
           05  FILLER PIC X(25) VALUE "DELTA LUGGAGE REPAIRS    ".
           05  FILLER PIC X(25) VALUE "EPSILON EQUIPMENT SUPPLY ".
           05  FILLER PIC X(25) VALUE "FORTUNE COOKIE COMPANY   ".
           05  FILLER PIC X(25) VALUE "GIBRALTER LIFE INSURANCE ".
           05  FILLER PIC X(25) VALUE "H & J PLUMBING SUPPLIES  ".
           05  FILLER PIC X(25) VALUE "INCREMENTAL BACKUP CORP. ".
           05  FILLER PIC X(25) VALUE "JOHNSON BOATING SUPPLIES ".
           05  FILLER PIC X(25) VALUE "KONFLAB PLASTIC PRODUCTS.".
           05  FILLER PIC X(25) VALUE "LEWISTON GRAPHICS LTD.   ".
           05  FILLER PIC X(25) VALUE "MORNINGSIDE CARPENTRY.   ".
           05  FILLER PIC X(25) VALUE "NEW WAVE SURF SHOPS INC. ".
           05  FILLER PIC X(25) VALUE "OLD TYME PIZZA MFG. CO.  ".
           05  FILLER PIC X(25) VALUE "PRESTIGE OFFICE FURNITURE".

         02  DATA-COMPANY  REDEFINES DATA-COMPANY-TBL
                                       PIC X(25) OCCURS MAX-SUB.
         02  DATA-ADDRESS-1-TBL.

           05  FILLER PIC X(25) VALUE "123 MAIN STREET          ".
           05  FILLER PIC X(25) VALUE "1090 2ND AVE. WEST       ".
           05  FILLER PIC X(25) VALUE "1401 JEFFERSON BLVD.     ".
           05  FILLER PIC X(25) VALUE "1620 ARIZONA WAY         ".
           05  FILLER PIC X(25) VALUE "1184 EAST FIRST STREET   ".
           05  FILLER PIC X(25) VALUE "114 JOHN F. KENNEDY AVE. ".
           05  FILLER PIC X(25) VALUE "650 LIBERTY CRESCENT     ".
           05  FILLER PIC X(25) VALUE "77 SUNSET BLVD.          ".
           05  FILLER PIC X(25) VALUE "10908 SANTA MONICA BLVD. ".
           05  FILLER PIC X(25) VALUE "1134 PARIS ROAD          ".
           05  FILLER PIC X(25) VALUE "808 NORTHWEST MAIN ST.   ".
           05  FILLER PIC X(25) VALUE "9904 QUEEN STREET        ".
           05  FILLER PIC X(25) VALUE "1709 DUNDAS CRESCENT W.  ".
           05  FILLER PIC X(25) VALUE "3240 MARIS AVENUE        ".
           05  FILLER PIC X(25) VALUE "1705 WISCONSIN ROAD      ".
           05  FILLER PIC X(25) VALUE "114A MAPLE GROVE         ".

         02  DATA-ADDRESS-1 REDEFINES DATA-ADDRESS-1-TBL
                                       PIC X(25) OCCURS MAX-SUB.
         02  DATA-ADDRESS-2-TBL.

           05  FILLER PIC X(10) VALUE "NEW YORK  ".
           05  FILLER PIC X(10) VALUE "ATLANTA   ".
           05  FILLER PIC X(10) VALUE "WASHINGTON".
           05  FILLER PIC X(10) VALUE "TORONTO   ".
           05  FILLER PIC X(10) VALUE "CALGARY   ".
           05  FILLER PIC X(10) VALUE "SAN DIEGO ".
           05  FILLER PIC X(10) VALUE "LOS RIOS  ".
           05  FILLER PIC X(10) VALUE "MADISON   ".
           05  FILLER PIC X(10) VALUE "WILBUR    ".
           05  FILLER PIC X(10) VALUE "TOPEKA    ".
           05  FILLER PIC X(10) VALUE "SEATTLE   ".
           05  FILLER PIC X(10) VALUE "NEW JERSEY".
           05  FILLER PIC X(10) VALUE "FORT WAYNE".
           05  FILLER PIC X(10) VALUE "COLUMBUS  ".
           05  FILLER PIC X(10) VALUE "RICHMOND  ".
           05  FILLER PIC X(10) VALUE "WHITEPLAIN".

         02  DATA-ADDRESS-2 REDEFINES DATA-ADDRESS-2-TBL
                                       PIC X(10) OCCURS MAX-SUB.
         02  DATA-ADDRESS-3-TBL.

           05  FILLER PIC X(10) VALUE "N.Y.      ".
           05  FILLER PIC X(10) VALUE "GEORGIA   ".
           05  FILLER PIC X(10) VALUE "D.C.      ".
           05  FILLER PIC X(10) VALUE "CANADA    ".
           05  FILLER PIC X(10) VALUE "CANADA    ".
           05  FILLER PIC X(10) VALUE "CALIFORNIA".
           05  FILLER PIC X(10) VALUE "NEW MEXICO".
           05  FILLER PIC X(10) VALUE "WISCONSIN ".
           05  FILLER PIC X(10) VALUE "DELAWARE  ".
           05  FILLER PIC X(10) VALUE "KANSAS    ".
           05  FILLER PIC X(10) VALUE "WASHINGTON".
           05  FILLER PIC X(10) VALUE "N.J.      ".
           05  FILLER PIC X(10) VALUE "COLORADO  ".
           05  FILLER PIC X(10) VALUE "OHIO      ".
           05  FILLER PIC X(10) VALUE "VIRGINIA  ".
           05  FILLER PIC X(10) VALUE "N.Y.      ".

         02  DATA-ADDRESS-3 REDEFINES DATA-ADDRESS-3-TBL
                                       PIC X(10) OCCURS MAX-SUB.
         02  DATA-TELEPHONE-TBL.

           05  FILLER PIC 9(10) VALUE 3131234432.
           05  FILLER PIC 9(10) VALUE 4082938498.
           05  FILLER PIC 9(10) VALUE 8372487274.
           05  FILLER PIC 9(10) VALUE 4169898509.
           05  FILLER PIC 9(10) VALUE 5292398745.
           05  FILLER PIC 9(10) VALUE 8009329492.
           05  FILLER PIC 9(10) VALUE 6456445643.
           05  FILLER PIC 9(10) VALUE 6546456333.
           05  FILLER PIC 9(10) VALUE 3455445444.
           05  FILLER PIC 9(10) VALUE 6456445643.
           05  FILLER PIC 9(10) VALUE 7456434355.
           05  FILLER PIC 9(10) VALUE 6554456433.
           05  FILLER PIC 9(10) VALUE 4169898509.
           05  FILLER PIC 9(10) VALUE 7534587453.
           05  FILLER PIC 9(10) VALUE 8787458374.
           05  FILLER PIC 9(10) VALUE 4169898509.

         02  DATA-TELEPHONE REDEFINES DATA-TELEPHONE-TBL
                                       PIC 9(10) OCCURS MAX-SUB.
         02  DATA-DP-MGR-TBL.

           05  FILLER PIC X(20) VALUE "MR. DAVE HARRIS     ".
           05  FILLER PIC X(20) VALUE "MS. JANICE SILCOX   ".
           05  FILLER PIC X(20) VALUE "MR. ALLAN JONES     ".
           05  FILLER PIC X(20) VALUE "MR. PETER MACKAY    ".
           05  FILLER PIC X(20) VALUE "MRS. DONNA BREWER   ".
           05  FILLER PIC X(20) VALUE "MR. MICHAEL SMYTHE  ".
           05  FILLER PIC X(20) VALUE "MR. D.A. MORRISON   ".
           05  FILLER PIC X(20) VALUE "MR. BRIAN PATTERSON ".
           05  FILLER PIC X(20) VALUE "MR. DARRYL TOWNSEND ".
           05  FILLER PIC X(20) VALUE "MS. VALERIE HARPER  ".
           05  FILLER PIC X(20) VALUE "MR. FRED MILLER     ".
           05  FILLER PIC X(20) VALUE "MR. DONALD FISCHER  ".
           05  FILLER PIC X(20) VALUE "MR. STEVEN YOURDIN  ".
           05  FILLER PIC X(20) VALUE "MS. Goldie Hawn     ".
           05  FILLER PIC X(20) VALUE "MS. ALICE WINSTON   ".
           05  FILLER PIC X(20) VALUE "MR. THOMAS JEFFERSON".

         02  DATA-DP-MGR    REDEFINES DATA-DP-MGR-TBL
                                       PIC X(20) OCCURS MAX-SUB.
         02  DATA-MACHINE-TBL.

           05  FILLER PIC X(8) VALUE "UNI-9030".
           05  FILLER PIC X(8) VALUE "UNI-9040".
           05  FILLER PIC X(8) VALUE "UNI-80/3".
           05  FILLER PIC X(8) VALUE "UNI-80/5".
           05  FILLER PIC X(8) VALUE "UNI-80/6".
           05  FILLER PIC X(8) VALUE "UNI-80/6".
           05  FILLER PIC X(8) VALUE "UNI-80/6".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-9040".
           05  FILLER PIC X(8) VALUE "UNI-9040".

         02  DATA-MACHINE   REDEFINES DATA-MACHINE-TBL
                                       PIC X(8) OCCURS MAX-SUB.
         02  DATA-NO-TERMINALS-TBL.

           05  FILLER PIC 9(3) COMP-3 VALUE 85.
           05  FILLER PIC 9(3) COMP-3 VALUE 34.
           05  FILLER PIC 9(3) COMP-3 VALUE 75.
           05  FILLER PIC 9(3) COMP-3 VALUE 45.
           05  FILLER PIC 9(3) COMP-3 VALUE 90.
           05  FILLER PIC 9(3) COMP-3 VALUE 107.
           05  FILLER PIC 9(3) COMP-3 VALUE 67.
           05  FILLER PIC 9(3) COMP-3 VALUE 32.
           05  FILLER PIC 9(3) COMP-3 VALUE 16.
           05  FILLER PIC 9(3) COMP-3 VALUE 34.
           05  FILLER PIC 9(3) COMP-3 VALUE 128.
           05  FILLER PIC 9(3) COMP-3 VALUE 64.
           05  FILLER PIC 9(3) COMP-3 VALUE 110.
           05  FILLER PIC 9(3) COMP-3 VALUE 324.
           05  FILLER PIC 9(3) COMP-3 VALUE 124.
           05  FILLER PIC 9(3) COMP-3 VALUE 86.

         02  DATA-NO-TERMINALS REDEFINES DATA-NO-TERMINALS-TBL
                                       PIC 9(3) COMP-3 OCCURS MAX-SUB.

       01  WORK-AREA.
           05  REC-NUM                         PICTURE 9(2) VALUE 0.
           05  SUB                             BINARY-SHORT UNSIGNED.
               88  ODD-RECORD                  VALUE 1 3 5 7 9 10 11.
               88  NULL-KEY                    VALUE 4 5 8 12 14.

           05  TSPFL-KEY                       PICTURE X(8).
           05  KC-PTR                          USAGE POINTER.

       LINKAGE SECTION.

       01  TSP-FCD.
           COPY "xfhfcd.cpy".

       01 key-def.
           03 kdb-len             pic 9(4) comp-x.
           03 filler              pic x(4).
           03 key-nkeys           pic 9(4) comp-x.
           03 filler              pic x(6).
           03 key-defs occurs 1 to 8 times depending on key-nkeys.
              05 key-count       pic 9(3) comp-x.
              05 key-offset      pic 9(3) comp-x.
              05 key-flags       pic X  comp-x.
              05 key-compression pic X  comp-x.
              05 key-sparse      pic x.
              05 filler          pic x(9).

       01 key-comp.
           03 kc-desc            pic X comp-x.
           03 kc-type            pic X comp-x.
           03 kc-pos             pic 9(9) comp-x.
           03 kc-len             pic 9(9) comp-x.

       01 TSP-FILENAME   PIC X(256).
       PROCEDURE DIVISION.

       MAINFILE.
           SET ADDRESS OF TSP-FCD TO ADDRESS OF FH--FCD OF TSPFILE.
           SET ADDRESS OF KEY-DEF TO ADDRESS OF FH--KEYDEF OF TSPFILE.
           DISPLAY "Other Flags " FCD-OTHER-FLAGS "."
           DISPLAY "File has " key-nkeys " keys."
           DISPLAY "Key def  " kdb-len " bytes."
           SET ADDRESS OF TSP-FILENAME TO FCD-FILENAME-ADDRESS.
           DISPLAY "File assigned is '"
                   TSP-FILENAME (1:FCD-NAME-LENGTH) "'".
           SET FCD-FILENAME-ADDRESS TO ADDRESS OF OUT-FILE-NAME.
           MOVE LENGTH OF OUT-FILE-NAME TO FCD-NAME-LENGTH.
           DISPLAY "*** Dump FCD before changes"
           PERFORM DUMP-FCD.
           MOVE 64 TO KEY-FLAGS (2)
           MOVE 66 TO KEY-FLAGS (3)
           MOVE '*' TO KEY-SPARSE (3)
           DISPLAY "*** Dump FCD after changes"
           PERFORM DUMP-FCD.
           PERFORM LOADFILE.
           PERFORM LISTFILE.
           STOP RUN.

       DUMP-FCD.
           PERFORM VARYING IDX FROM 1 BY 1
                     UNTIL IDX > key-nkeys
             IF key-sparse (idx) < ' '
               MOVE ' ' TO key-sparse (idx)
             END-IF
             DISPLAY "Key" IDX " has " key-count (idx) " parts,"
                     " Offset " key-offset (idx)
                     " Flags " key-flags (idx)
                     " Comp " key-compression (idx)
                     " Sparse " key-sparse (idx) "."
             SET KC-PTR TO ADDRESS OF KEY-DEF
             SET KC-PTR UP BY key-offset (idx)
             PERFORM VARYING IDX2 FROM 1 BY 1
                     UNTIL IDX2 > key-count (idx)
               SET ADDRESS OF KEY-COMP TO KC-PTR
               DISPLAY "      Pos " kc-pos " Len " kc-len
               SET KC-PTR UP BY LENGTH OF KEY-COMP
             END-PERFORM
           END-PERFORM.

       LOADFILE.
           OPEN OUTPUT TSPFILE
           SET ADDRESS OF TSP-FILENAME TO FCD-FILENAME-ADDRESS.
           DISPLAY "Loading sample file '"
                   TSP-FILENAME (1:FCD-NAME-LENGTH) "'"
                            UPON CONSOLE.

           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "05"
               DISPLAY "Error " CUST-STAT " opening '"
                       TSP-FILENAME (1:FCD-NAME-LENGTH) "' file"
                                UPON CONSOLE
               STOP RUN
           END-IF.

           PERFORM 1000-LOAD-RECORD
                        VARYING SUB FROM 1 BY 1
                          UNTIL SUB > MAX-SUB.

           DISPLAY "Sample data file load complete."
                            UPON CONSOLE.
           CLOSE TSPFILE.

      *---------------------------------------------------------------*
      *         LOAD A RECORD FROM DATA TABLES                        *
      *---------------------------------------------------------------*

       1000-LOAD-RECORD.

           MOVE SPACES                       TO TSPFL-RECORD.
           MOVE DATA-CUST-NUM      (SUB)     TO CM-CUST-NUM.
           MOVE CM-CUST-NUM                  TO TSPFL-KEY.
           MOVE DATA-COMPANY       (SUB)     TO CM-COMPANY.
           MOVE DATA-ADDRESS-1     (SUB)     TO CM-ADDRESS-1.
           MOVE DATA-ADDRESS-2     (SUB)     TO CM-ADDRESS-2.
           MOVE DATA-ADDRESS-3     (SUB)     TO CM-ADDRESS-3.
           MOVE DATA-TELEPHONE     (SUB)     TO CM-TELEPHONE.
           MOVE DATA-DP-MGR        (SUB)     TO CM-DP-MGR.
           MOVE DATA-MACHINE       (SUB)     TO CM-MACHINE.
           MOVE DATA-NO-TERMINALS  (SUB)     TO CM-NO-TERMINALS.

           IF  ODD-RECORD
               MOVE "8417"                   TO CM-DISK
               MOVE "1600 BPI"               TO CM-TAPE
               MOVE "1MEG"                   TO CM-MEMORY
           ELSE
               MOVE "8470"                   TO CM-DISK
               MOVE "6250 BPI"               TO CM-TAPE
               MOVE "3MEG"                   TO CM-MEMORY.
           IF  NULL-KEY
               MOVE ALL "*"                  TO CM-DISK
               MOVE ALL "*"                  TO CM-TAPE.
           IF  SUB = 1 OR 6
               MOVE "2417"                   TO CM-DISK
               MOVE "549  mmm"               TO CM-TAPE.

           WRITE TSPFL-RECORD
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "WRITE: " TSPFL-KEY ", Status: "
                       CUST-STAT UPON CONSOLE
           END-IF.

       LISTFILE.
           MOVE ZERO TO REC-NUM
           OPEN INPUT TSPFILE
           SET ADDRESS OF TSP-FILENAME TO FCD-FILENAME-ADDRESS.
           DISPLAY "List sample file '"
                   TSP-FILENAME (1:FCD-NAME-LENGTH) "'"
                            UPON CONSOLE.
           IF  CUST-STAT NOT = "00"
               DISPLAY "ERROR " CUST-STAT " OPENING INPUT FILE"
                                             UPON CONSOLE
               IF CUST-STAT (1:1) = "9"
                   DISPLAY "Sub Error " STAT-X2 UPON CONSOLE
               END-IF
               STOP RUN
           END-IF.
           MOVE SPACES                       TO TSPFL-RECORD.
           START TSPFILE KEY GREATER THAN PRIME-KEY
           IF CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " starting file"
                                UPON CONSOLE
               IF CUST-STAT (1:1) = "9"
                   DISPLAY "Sub Error " STAT-X2 UPON CONSOLE
               END-IF
               STOP RUN
           END-IF.
           READ  TSPFILE NEXT RECORD WITH NO LOCK
           IF CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " on 1st read of file"
                                UPON CONSOLE
               IF CUST-STAT (1:1) = "9"
                   DISPLAY "Sub Error " STAT-X2 UPON CONSOLE
               END-IF
               STOP RUN
           END-IF.
           PERFORM UNTIL CUST-STAT NOT = "00"
                      OR REC-NUM > MAX-SUB
               DISPLAY "Key: " CM-CUST-NUM " is " CM-COMPANY
                        " Disk=" CM-DISK "."
                         UPON CONSOLE
               READ TSPFILE NEXT RECORD
                    AT END
                        MOVE "99" TO CUST-STAT
                END-READ
                ADD 1 TO REC-NUM
           END-PERFORM
           IF CUST-STAT = "99"
               DISPLAY "Hit End of File after " REC-NUM UPON CONSOLE
           END-IF.

           DISPLAY "LIST SAMPLE FILE DESCENDING" UPON CONSOLE.
           MOVE ZERO TO REC-NUM
           MOVE ALL 'Z'                      TO TSPFL-RECORD.
           START TSPFILE KEY LESS THAN PRIME-KEY
           IF CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " starting file"
                                UPON CONSOLE
               STOP RUN
           END-IF.
           READ  TSPFILE PREVIOUS RECORD WITH NO LOCK
           IF CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " on 1st read of file"
                                UPON CONSOLE
               STOP RUN
           END-IF.
           PERFORM UNTIL CUST-STAT NOT = "00"
                      OR REC-NUM > MAX-SUB
               DISPLAY "Key: " CM-CUST-NUM " is " CM-COMPANY
                        " Disk=" CM-DISK "."
                         UPON CONSOLE
               READ TSPFILE PREVIOUS RECORD
                    AT END
                        MOVE "99" TO CUST-STAT
                END-READ
                ADD 1 TO REC-NUM
           END-PERFORM.
           IF CUST-STAT = "99"
               DISPLAY "Hit End of File after " REC-NUM UPON CONSOLE
           END-IF.

           DISPLAY "LIST SAMPLE FILE BY KEY3" UPON CONSOLE.
           MOVE ZERO                         TO REC-NUM
           MOVE SPACES                       TO TSPFL-RECORD.
           START TSPFILE KEY GREATER THAN OR EQUAL TO SPLIT-KEY3
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " starting file"
                                UPON CONSOLE
               STOP RUN
           END-IF.
           READ  TSPFILE NEXT RECORD WITH NO LOCK
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " on 1st read of file"
                                UPON CONSOLE
               STOP RUN
           END-IF.
           PERFORM UNTIL (CUST-STAT NOT = "00"
                      AND CUST-STAT NOT = "02")
                      OR REC-NUM > MAX-SUB
               DISPLAY "Key: " CM-CUST-NUM " is " CM-COMPANY
                        " Disk=" CM-DISK "."
                         UPON CONSOLE
               READ TSPFILE NEXT RECORD
                    AT END
                        MOVE "99" TO CUST-STAT
                END-READ
                ADD 1 TO REC-NUM
           END-PERFORM.
           IF CUST-STAT = "99"
               DISPLAY "Hit End of File after " REC-NUM UPON CONSOLE
           END-IF.
           CLOSE TSPFILE.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])

AT_CAPTURE_FILE([prog.out])

AT_CHECK([$COBCRUN_DIRECT ./prog 1>prog.out], [0], [], [])

AT_DATA([reference], [Other Flags 32.
File has 0003 keys.
Key def  0112 bytes.
File assigned is 'mytstisam'
*** Dump FCD before changes
Key1 has 001 parts, Offset 062 Flags 00 Comp 00 Sparse  .
      Pos 000000000 Len 000000008
Key2 has 002 parts, Offset 072 Flags 00 Comp 00 Sparse  .
      Pos 000000109 Len 000000010
      Pos 000000144 Len 000000008
Key3 has 002 parts, Offset 092 Flags 00 Comp 00 Sparse  .
      Pos 000000156 Len 000000008
      Pos 000000164 Len 000000008
*** Dump FCD after changes
Key1 has 001 parts, Offset 062 Flags 00 Comp 00 Sparse  .
      Pos 000000000 Len 000000008
Key2 has 002 parts, Offset 072 Flags 64 Comp 00 Sparse  .
      Pos 000000109 Len 000000010
      Pos 000000144 Len 000000008
Key3 has 002 parts, Offset 092 Flags 66 Comp 00 Sparse *.
      Pos 000000156 Len 000000008
      Pos 000000164 Len 000000008
Loading sample file 'myextisam'
Sample data file load complete.
List sample file 'myextisam'
Key: ALP00000 is ALPHA ELECTRICAL CO. LTD. Disk=2417    .
Key: BET00000 is BETA SHOE MFG. INC.       Disk=8470    .
Key: DEL00000 is DELTA LUGGAGE REPAIRS     Disk=********.
Key: EPS00000 is EPSILON EQUIPMENT SUPPLY  Disk=********.
Key: FOR00000 is FORTUNE COOKIE COMPANY    Disk=2417    .
Key: GAM00000 is GAMMA X-RAY TECHNOLOGY    Disk=8417    .
Key: GIB00000 is GIBRALTER LIFE INSURANCE  Disk=8417    .
Key: H&J00000 is H & J PLUMBING SUPPLIES   Disk=********.
Key: INC00000 is INCREMENTAL BACKUP CORP.  Disk=8417    .
Key: JOH00000 is JOHNSON BOATING SUPPLIES  Disk=8417    .
Key: KON00000 is KONFLAB PLASTIC PRODUCTS. Disk=8417    .
Key: LEW00000 is LEWISTON GRAPHICS LTD.    Disk=********.
Key: MOR00000 is MORNINGSIDE CARPENTRY.    Disk=8470    .
Key: NEW00000 is NEW WAVE SURF SHOPS INC.  Disk=********.
Key: OLD00000 is OLD TYME PIZZA MFG. CO.   Disk=8470    .
Key: PRE00000 is PRESTIGE OFFICE FURNITURE Disk=8470    .
Hit End of File after 16
LIST SAMPLE FILE DESCENDING
Key: PRE00000 is PRESTIGE OFFICE FURNITURE Disk=8470    .
Key: OLD00000 is OLD TYME PIZZA MFG. CO.   Disk=8470    .
Key: NEW00000 is NEW WAVE SURF SHOPS INC.  Disk=********.
Key: MOR00000 is MORNINGSIDE CARPENTRY.    Disk=8470    .
Key: LEW00000 is LEWISTON GRAPHICS LTD.    Disk=********.
Key: KON00000 is KONFLAB PLASTIC PRODUCTS. Disk=8417    .
Key: JOH00000 is JOHNSON BOATING SUPPLIES  Disk=8417    .
Key: INC00000 is INCREMENTAL BACKUP CORP.  Disk=8417    .
Key: H&J00000 is H & J PLUMBING SUPPLIES   Disk=********.
Key: GIB00000 is GIBRALTER LIFE INSURANCE  Disk=8417    .
Key: GAM00000 is GAMMA X-RAY TECHNOLOGY    Disk=8417    .
Key: FOR00000 is FORTUNE COOKIE COMPANY    Disk=2417    .
Key: EPS00000 is EPSILON EQUIPMENT SUPPLY  Disk=********.
Key: DEL00000 is DELTA LUGGAGE REPAIRS     Disk=********.
Key: BET00000 is BETA SHOE MFG. INC.       Disk=8470    .
Key: ALP00000 is ALPHA ELECTRICAL CO. LTD. Disk=2417    .
Hit End of File after 16
LIST SAMPLE FILE BY KEY3
Key: ALP00000 is ALPHA ELECTRICAL CO. LTD. Disk=2417    .
Key: FOR00000 is FORTUNE COOKIE COMPANY    Disk=2417    .
Key: GAM00000 is GAMMA X-RAY TECHNOLOGY    Disk=8417    .
Key: GIB00000 is GIBRALTER LIFE INSURANCE  Disk=8417    .
Key: INC00000 is INCREMENTAL BACKUP CORP.  Disk=8417    .
Key: JOH00000 is JOHNSON BOATING SUPPLIES  Disk=8417    .
Key: KON00000 is KONFLAB PLASTIC PRODUCTS. Disk=8417    .
Key: BET00000 is BETA SHOE MFG. INC.       Disk=8470    .
Key: MOR00000 is MORNINGSIDE CARPENTRY.    Disk=8470    .
Key: OLD00000 is OLD TYME PIZZA MFG. CO.   Disk=8470    .
Key: PRE00000 is PRESTIGE OFFICE FURNITURE Disk=8470    .
Hit End of File after 11
])

AT_CHECK([diff reference prog.out], [0], [], [])

# verify that all of this works with wrapping to EXTFH calls
# and that those don't trash the FH--FCD allocated memory

AT_CHECK([$COMPILE -fcallfh=EXTFH -o extfh prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./extfh 1>prog.out], [0], [], [])

AT_CHECK([diff reference prog.out], [0], [], [])


AT_CLEANUP


AT_SETUP([EXTFH: SEQUENTIAL files])
AT_KEYWORDS([runfile EXTFH])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.

       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.

       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT FLATFILE ASSIGN EXTERNAL SEQFIX
           ORGANIZATION SEQUENTIAL
           FILE STATUS IS CUST-STAT .

       DATA DIVISION.
       FILE SECTION.
       FD  FLATFILE
           BLOCK CONTAINS 5 RECORDS.

       01  TSPFL-RECORD.
           10  CM-CUST-NUM                     PICTURE X(8).
           10  CM-COMPANY                      PICTURE X(25).
           10  CM-DISK                         PICTURE X(8).
           10  CM-NO-TERMINALS                 PICTURE 9(4) COMP-4.
           10  CM-PK-DATE                      PICTURE S9(14) COMP-3.
           10  CM-TRAILER                      PICTURE X(8).

       WORKING-STORAGE SECTION.

       78  MAX-SUB           VALUE  6.
       77  CUST-STAT                           PICTURE X(2).

       01  TEST-DATA.

         02  DATA-CUST-NUM-TBL.

           05  FILLER PIC X(8) VALUE "ALP00000".
           05  FILLER PIC X(8) VALUE "BET00000".
           05  FILLER PIC X(8) VALUE "GAM00000".
           05  FILLER PIC X(8) VALUE "DEL00000".
           05  FILLER PIC X(8) VALUE "EPS00000".
           05  FILLER PIC X(8) VALUE "FOR00000".

         02  DATA-CUST-NUM REDEFINES DATA-CUST-NUM-TBL
                                       PIC X(8) OCCURS MAX-SUB.
         02  DATA-COMPANY-TBL.

           05  FILLER PIC X(25) VALUE "ALPHA ELECTRICAL CO. LTD.".
           05  FILLER PIC X(25) VALUE "BETA SHOE MFG. INC.      ".
           05  FILLER PIC X(25) VALUE "GAMMA X-RAY TECHNOLOGY   ".
           05  FILLER PIC X(25) VALUE "DELTA LUGGAGE REPAIRS    ".
           05  FILLER PIC X(25) VALUE "EPSILON EQUIPMENT SUPPLY ".
           05  FILLER PIC X(25) VALUE "FORTUNE COOKIE COMPANY   ".
         02  DATA-COMPANY  REDEFINES DATA-COMPANY-TBL
                                       PIC X(25) OCCURS MAX-SUB.
         02  DATA-ADDRESS-2-TBL.

           05  FILLER PIC X(10) VALUE "NEW YORK  ".
           05  FILLER PIC X(10) VALUE "ATLANTA   ".
           05  FILLER PIC X(10) VALUE "WASHINGTON".
           05  FILLER PIC X(10) VALUE "TORONTO   ".
           05  FILLER PIC X(10) VALUE "CALGARY   ".
           05  FILLER PIC X(10) VALUE "WHITEPLAIN".

         02  DATA-ADDRESS   REDEFINES DATA-ADDRESS-2-TBL
                                       PIC X(10) OCCURS MAX-SUB.

         02  DATA-NO-TERMINALS-TBL.

           05  FILLER PIC 9(3) COMP-3 VALUE 10.
           05  FILLER PIC 9(3) COMP-3 VALUE 13.
           05  FILLER PIC 9(3) COMP-3 VALUE 75.
           05  FILLER PIC 9(3) COMP-3 VALUE 10.
           05  FILLER PIC 9(3) COMP-3 VALUE 90.
           05  FILLER PIC 9(3) COMP-3 VALUE 254.

         02  DATA-NO-TERMINALS REDEFINES DATA-NO-TERMINALS-TBL
                                       PIC 9(3) COMP-3 OCCURS MAX-SUB.
       01  WORK-AREA.
           05  SUB                             BINARY-SHORT UNSIGNED.
               88  ODD-RECORD                  VALUE 1 3 5.


       PROCEDURE DIVISION.

           OPEN INPUT FLATFILE.
           DISPLAY "Open Input when no file Sts:" CUST-STAT
           OPEN EXTEND FLATFILE.
           DISPLAY "Open Extend when no file Sts:" CUST-STAT
           CLOSE FLATFILE.
           DISPLAY "Close when no open file Sts:" CUST-STAT
           OPEN OUTPUT FLATFILE.
           CLOSE FLATFILE.
           OPEN EXTEND FLATFILE.
           DISPLAY "Open Extend when empty file Sts:" CUST-STAT
           CLOSE FLATFILE.

           PERFORM LOADFILE.
           OPEN INPUT FLATFILE.
           DISPLAY "Open Sts:" CUST-STAT
           READ FLATFILE
           DISPLAY "Read " CM-CUST-NUM " Sts:" CUST-STAT.
           READ FLATFILE
           DISPLAY "Read " CM-CUST-NUM " Sts:" CUST-STAT.
           CLOSE FLATFILE.

           OPEN I-O FLATFILE.
           READ FLATFILE
           DISPLAY "Read " CM-CUST-NUM " Sts:" CUST-STAT.
           ADD 1 TO CM-NO-TERMINALS
           REWRITE TSPFL-RECORD
           DISPLAY "REWRITE " CM-CUST-NUM " Sts " CUST-STAT
                   " Trms:" CM-NO-TERMINALS.
           CLOSE FLATFILE.

           OPEN I-O FLATFILE.
           READ FLATFILE
           DISPLAY "Read " CM-CUST-NUM " Sts:" CUST-STAT.
           ADD 1 TO CM-NO-TERMINALS
           REWRITE TSPFL-RECORD
           DISPLAY "REWRITE " CM-CUST-NUM " Sts " CUST-STAT
                   " Trms:" CM-NO-TERMINALS.
           READ FLATFILE WITH LOCK
           DISPLAY "Read " CM-CUST-NUM
      *    DELETE FLATFILE
      *    DISPLAY "DELETE " CM-CUST-NUM " Sts " CUST-STAT.
           CLOSE FLATFILE.
           OPEN INPUT FLATFILE.
           DISPLAY "Re-list File Open Sts:" CUST-STAT
           PERFORM UNTIL CUST-STAT NOT = "00"
               PERFORM READ-RECORD
           END-PERFORM.
           CLOSE FLATFILE.
           OPEN EXTEND FLATFILE.
           MOVE 2 TO SUB
           PERFORM LOAD-RECORD
           CLOSE FLATFILE.
           OPEN INPUT FLATFILE.
           DISPLAY "List File afer EXTEND Open Sts:" CUST-STAT
           PERFORM UNTIL CUST-STAT NOT = "00"
               PERFORM READ-RECORD
           END-PERFORM.
           CLOSE FLATFILE.
           STOP RUN RETURNING 0.

       READ-RECORD.
           MOVE SPACES                       TO TSPFL-RECORD.
           READ FLATFILE
           IF CUST-STAT NOT = "00"
             DISPLAY "Read Status: " CUST-STAT
           ELSE
             DISPLAY "Read  " CM-CUST-NUM
                     " Trms:" CM-NO-TERMINALS
           END-IF.

       LOADFILE.
           DISPLAY "Loading sample data file.".

           OPEN OUTPUT FLATFILE.

           PERFORM LOAD-RECORD
                        VARYING SUB FROM 1 BY 1
                          UNTIL SUB > MAX-SUB.

           DISPLAY "Sample data file load complete.".
           CLOSE FLATFILE.

       LOAD-RECORD.

           MOVE SPACES                       TO TSPFL-RECORD.
           MOVE DATA-CUST-NUM      (SUB)     TO CM-CUST-NUM.
           MOVE DATA-COMPANY       (SUB)     TO CM-COMPANY.
           MOVE DATA-NO-TERMINALS  (SUB)     TO CM-NO-TERMINALS.
           MOVE 20070319                     TO CM-PK-DATE.
           IF SUB = 1 OR 4 OR 6
               MOVE -20070319                 TO CM-PK-DATE.

           IF  ODD-RECORD
               MOVE "8417"                   TO CM-DISK
           ELSE
               MOVE "8470"                   TO CM-DISK.
           WRITE TSPFL-RECORD.
])

AT_DATA([cmod.c], [[
#include <stdio.h>
#include <libcob.h>

static char *txtOpCode(int opCode);

static int
doOpenFile(
   unsigned char  *opCodep,
   FCD3  *fcd,
   char  *opmsg)
{
   int      sts;

   sts = EXTFH( opCodep, fcd );
   printf("EXFTH did %s; Status=%c%c; File now %s\n",
       opmsg, fcd->fileStatus[0], fcd->fileStatus[1],
       (fcd->openMode & OPEN_NOT_OPEN) ? "Closed" : "Open");
   return sts;
}

/*********************************************************
 *  TSTFH - External File Handler entry point.
*********************************************************/

COB_EXT_EXPORT int
TSTFH (unsigned char *opCodep, FCD3 *fcd)
{
   unsigned int   opCode;
   int      sts;

   if (*opCodep == 0xfa)
      opCode = 0xfa00 + opCodep[1];
   else
      opCode = opCodep[1];

   if (fcd->fileOrg == ORG_LINE_SEQ
    || fcd->fileOrg == ORG_SEQ
    || fcd->fileOrg == ORG_INDEXED
    || fcd->fileOrg == ORG_RELATIVE) {
      switch (opCode) {
      case OP_OPEN_OUTPUT:
      case OP_OPEN_IO:
      case OP_OPEN_EXTEND:
      case OP_OPEN_OUTPUT_NOREWIND:
         return doOpenFile( opCodep, fcd, txtOpCode(opCode));
         break;

      case OP_OPEN_INPUT:
      case OP_OPEN_INPUT_NOREWIND:
      case OP_OPEN_INPUT_REVERSED:
         return doOpenFile( opCodep, fcd, txtOpCode(opCode));
         break;

      case OP_CLOSE:
         return doOpenFile( opCodep, fcd, txtOpCode(opCode));
         break;

      default:
         break;
      }

   }

   if (opCode == OP_CLOSE
    && (fcd->openMode & OPEN_NOT_OPEN) ) {
      return 0;
   }

   sts = EXTFH(opCodep, fcd);
   printf("EXFTH did %s; Status=%c%c\n", txtOpCode(opCode),
       fcd->fileStatus[0], fcd->fileStatus[1]);
   return sts;
}

static char *           /* Return Text name of function */
txtOpCode(int opCode)
{
   static char tmp[32];
   switch (opCode) {
   case OP_OPEN_INPUT:     return "OPEN_IN";
   case OP_OPEN_OUTPUT:       return "OPEN_OUT";
   case OP_OPEN_IO:     return "OPEN_IO";
   case OP_OPEN_EXTEND:       return "OPEN_EXT";
   case OP_OPEN_INPUT_NOREWIND:  return "OPEN_IN_NOREW";
   case OP_OPEN_OUTPUT_NOREWIND: return "OPEN_OUT_NOREW";
   case OP_OPEN_INPUT_REVERSED:  return "OPEN_IN_REV";
   case OP_CLOSE:          return "CLOSE";
   case OP_CLOSE_LOCK:     return "CLOSE_LOCK";
   case OP_CLOSE_NOREWIND:    return "CLOSE_NORED";
   case OP_CLOSE_REEL:     return "CLOSE_REEL";
   case OP_CLOSE_REMOVE:      return "CLOSE_REMOVE";
   case OP_CLOSE_NO_REWIND:   return "CLOSE_NO_REW";
   case OP_START_EQ:       return "START_EQ";
   case OP_START_EQ_ANY:      return "START_EQ_ANY";
   case OP_START_GT:       return "START_GT";
   case OP_START_GE:       return "START_GE";
   case OP_START_LT:       return "START_LT";
   case OP_START_LE:       return "START_LE";
   case OP_READ_SEQ_NO_LOCK:  return "READ_SEQ_NO_LK";
   case OP_READ_SEQ:       return "READ_SEQ";
   case OP_READ_SEQ_LOCK:     return "READ_SEQ_LK";
   case OP_READ_SEQ_KEPT_LOCK:   return "READ_SEQ_KEPT_LK";
   case OP_READ_PREV_NO_LOCK:    return "READ_PREV_NO_LK";
   case OP_READ_PREV:      return "READ_PREV";
   case OP_READ_PREV_LOCK:    return "READ_PREV_LK";
   case OP_READ_PREV_KEPT_LOCK:  return "READ_PREV_KEPT_LK";
   case OP_READ_RAN:       return "READ_RAN";
   case OP_READ_RAN_NO_LOCK:  return "READ_RAN_NO_LK";
   case OP_READ_RAN_KEPT_LOCK:   return "READ_RAN_KEPT_LK";
   case OP_READ_RAN_LOCK:     return "READ_RAN_LK";
   case OP_READ_DIR:       return "READ_DIR";
   case OP_READ_DIR_NO_LOCK:  return "READ_DIR_NO_LK";
   case OP_READ_DIR_KEPT_LOCK:   return "READ_DIR_KEPT_LK";
   case OP_READ_DIR_LOCK:     return "READ_DIR_LK";
   case OP_READ_POSITION:     return "READ_POSITION";
   case OP_WRITE:          return "WRITE";
   case OP_REWRITE:     return "REWRITE";
   case OP_DELETE:      return "DELETE";
   case OP_DELETE_FILE:       return "DELETE_FILE";
   case OP_UNLOCK:      return "UNLOCK";
   case OP_ROLLBACK:       return "ROLLBACK";
   case OP_COMMIT:      return "COMMIT";
   case OP_WRITE_BEFORE:      return "WRITE_BEFORE";
   case OP_WRITE_BEFORE_TAB:  return "WRITE_BEFORE_TAB";
   case OP_WRITE_BEFORE_PAGE:    return "WRITE_BEFORE_PAGE";
   case OP_WRITE_AFTER:       return "WRITE_AFTER";
   case OP_WRITE_AFTER_TAB:   return "WRITE_AFTER_TAB";
   case OP_WRITE_AFTER_PAGE:  return "WRITE_AFTER_PAGE";
   }
   sprintf(tmp, "Func 0x%02X:", opCode);
   return tmp;
}
]])

AT_CHECK([$COMPILE -fcallfh=TSTFH prog.cob cmod.c], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[EXFTH did OPEN_IN; Status=35; File now Closed
Open Input when no file Sts:35
EXFTH did OPEN_EXT; Status=35; File now Closed
Open Extend when no file Sts:35
EXFTH did CLOSE; Status=42; File now Closed
Close when no open file Sts:42
EXFTH did OPEN_OUT; Status=00; File now Open
EXFTH did CLOSE; Status=00; File now Closed
EXFTH did OPEN_EXT; Status=00; File now Open
Open Extend when empty file Sts:00
EXFTH did CLOSE; Status=00; File now Closed
Loading sample data file.
EXFTH did OPEN_OUT; Status=00; File now Open
EXFTH did WRITE; Status=00
EXFTH did WRITE; Status=00
EXFTH did WRITE; Status=00
EXFTH did WRITE; Status=00
EXFTH did WRITE; Status=00
EXFTH did WRITE; Status=00
Sample data file load complete.
EXFTH did CLOSE; Status=00; File now Closed
EXFTH did OPEN_IN; Status=00; File now Open
Open Sts:00
EXFTH did READ_SEQ; Status=00
Read ALP00000 Sts:00
EXFTH did READ_SEQ; Status=00
Read BET00000 Sts:00
EXFTH did CLOSE; Status=00; File now Closed
EXFTH did OPEN_IO; Status=00; File now Open
EXFTH did READ_SEQ; Status=00
Read ALP00000 Sts:00
EXFTH did REWRITE; Status=00
REWRITE ALP00000 Sts 00 Trms:0011
EXFTH did CLOSE; Status=00; File now Closed
EXFTH did OPEN_IO; Status=00; File now Open
EXFTH did READ_SEQ; Status=00
Read ALP00000 Sts:00
EXFTH did REWRITE; Status=00
REWRITE ALP00000 Sts 00 Trms:0012
EXFTH did READ_SEQ; Status=00
Read BET00000
EXFTH did CLOSE; Status=00; File now Closed
EXFTH did OPEN_IN; Status=00; File now Open
Re-list File Open Sts:00
EXFTH did READ_SEQ; Status=00
Read  ALP00000 Trms:0012
EXFTH did READ_SEQ; Status=00
Read  BET00000 Trms:0013
EXFTH did READ_SEQ; Status=00
Read  GAM00000 Trms:0075
EXFTH did READ_SEQ; Status=00
Read  DEL00000 Trms:0010
EXFTH did READ_SEQ; Status=00
Read  EPS00000 Trms:0090
EXFTH did READ_SEQ; Status=00
Read  FOR00000 Trms:0254
EXFTH did READ_SEQ; Status=10
Read Status: 10
EXFTH did CLOSE; Status=00; File now Closed
EXFTH did OPEN_EXT; Status=00; File now Open
EXFTH did WRITE; Status=00
EXFTH did CLOSE; Status=00; File now Closed
EXFTH did OPEN_IN; Status=00; File now Open
List File afer EXTEND Open Sts:00
EXFTH did READ_SEQ; Status=00
Read  ALP00000 Trms:0012
EXFTH did READ_SEQ; Status=00
Read  BET00000 Trms:0013
EXFTH did READ_SEQ; Status=00
Read  GAM00000 Trms:0075
EXFTH did READ_SEQ; Status=00
Read  DEL00000 Trms:0010
EXFTH did READ_SEQ; Status=00
Read  EPS00000 Trms:0090
EXFTH did READ_SEQ; Status=00
Read  FOR00000 Trms:0254
EXFTH did READ_SEQ; Status=00
Read  BET00000 Trms:0013
EXFTH did READ_SEQ; Status=10
Read Status: 10
EXFTH did CLOSE; Status=00; File now Closed
], [])

AT_CLEANUP


AT_SETUP([EXTFH: LINE SEQUENTIAL files, direct EXTFH])
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
       DATA DIVISION.
       FILE SECTION.
       WORKING-STORAGE SECTION.

       01  I                       PIC XX COMP-X.

       01  WS-FCD-DDNAME           PIC X(8) VALUE SPACES.
       01  WS-FCD-PTR              POINTER   VALUE NULL.

       01  WS-FCD-SIZE             PIC 9(04) VALUE   0       COMP-5.
       01  WS-FCD-FLAGS            PIC 9(04) VALUE   0       COMP-5.

       01  DISPLAY-BYTE.
          05  DISPLAY-XXX             PIC X(03).
          05  DISPLAY-ZZ9             REDEFINES DISPLAY-XXX
                                      PIC ZZ9.
       01  ACTION-CODE                 pic x(2).
          78  OP-OPEN-INPUT           value x"fa00".
          78  OP-OPEN-OUTPUT          value x"fa01".
          78  OP-OPEN-I-O             value x"fa02".
          78  OP-WRITE                value x"faf3".
          78  OP-RELEASE              value x"faf3".
          78  OP-REWRITE              value x"faf4".
          78  OP-READ-NEXT            value x"faf5".
          78  OP-START-EQUAL          value x"fae9".
          78  OP-CLOSE                value x"fa80".
          78  OP-QUERY-FILE           value x"0006".

       01  DISPLAY-A1-XXX              PIC X(03).
       01  DISPLAY-A1-ZZ9              REDEFINES DISPLAY-A1-XXX
                                      PIC ZZ9.
       01  DISPLAY-A2-XXX              PIC X(03).
       01  DISPLAY-A2-ZZ9              REDEFINES DISPLAY-A2-XXX
                                       PIC ZZ9.

       01  FCD-FILENAME               PIC X(80) value "test.out".
       01  FCD-RECORD                 PIC X(512) value spaces.

       LINKAGE SECTION.

       01  FCD-MAP.
           copy 'xfhfcd3.cpy'.

      *================================================================*
       PROCEDURE DIVISION.
      *----------------------------------------------------------------*
       000-MAIN.

          PERFORM 100-OPEN.

          PERFORM VARYING I FROM 1 BY 1 UNTIL I > 10
            MOVE I TO DISPLAY-A1-ZZ9
            MOVE DISPLAY-A1-ZZ9 TO FCD-RECORD
            PERFORM 300-WRITE
          END-PERFORM.

          PERFORM 400-CLOSE.
          STOP RUN.

      *----------------------------------------------------------------*
      *    Process the open request
      *
       100-OPEN.

          MOVE "TESTOUT" TO WS-FCD-DDNAME

          MOVE LENGTH OF FCD-MAP TO WS-FCD-SIZE
          DISPLAY "FCD SIZE " WS-FCD-SIZE.

          IF WS-FCD-PTR EQUAL NULL
             ALLOCATE ws-fcd-size characters
                           returning WS-FCD-PTR

             SET  ADDRESS OF FCD-MAP  TO WS-FCD-PTR
             MOVE LOW-VALUES          TO FCD-MAP
             MOVE WS-FCD-SIZE         TO FCD-LENGTH
             move fcd--version-number TO FCD-VERSION
             MOVE "00"                TO FCD-FILE-STATUS
             move fcd--status-defined to FCD-ACCESS-MODE
             move fcd--open-closed    to FCD-OPEN-MODE
             move fcd--external-name  to FCD-OTHER-FLAGS
             SET  FCD-HANDLE          TO NULL
             MOVE 8                   TO FCD-NAME-LENGTH
             SET  FCD-FILENAME-ADDRESS TO ADDRESS
                                       OF WS-FCD-DDNAME
             SET  FCD-KEY-DEF-ADDRESS TO NULL
             move fcd--allow-readers  to FCD-LOCKTYPES
          ELSE
             SET  ADDRESS OF FCD-MAP  TO WS-FCD-PTR
             IF FCD-OPEN-MODE NOT = fcd--open-closed
                DISPLAY "ERRROR - FILE ALREADY OPEN"
                STOP RUN
             END-IF
          END-IF

          move fcd--line-sequential-org to FCD-ORGANIZATION
          move fcd--recmode-fixed       to FCD-RECORDING-MODE
          move 10 to FCD-MIN-REC-LENGTH, FCD-MAX-REC-LENGTH
          SET  FCD-RECORD-ADDRESS     TO ADDRESS OF FCD-RECORD

      * Move fcd--cr-delimiter for CR LF after each record
      *   move fcd--cr-delimiter        to FCD-STATUS-TYPE

          move op-open-output to action-code

          PERFORM 800-CALL-EXTFH
          .

      *----------------------------------------------------------------*
      *    Process the write request
      *
       300-WRITE.

          move 10 to FCD-CURRENT-REC-LEN
          move op-write to action-code
          PERFORM 800-CALL-EXTFH
          .
      *----------------------------------------------------------------*
      *    Process the close request
      *
       400-CLOSE.
          MOVE "00"                   TO FCD-FILE-STATUS
          move op-close               to action-code
          PERFORM 800-CALL-EXTFH
          .
      *----------------------------------------------------------------*
      *    External file handler interface -- all I/O goes through here
      *
        800-CALL-EXTFH.

            CALL "EXTFH" USING ACTION-CODE, FCD-MAP

            IF FCD-STATUS-KEY-1 = "9" AND FCD-BINARY = 199
               MOVE "10" TO FCD-FILE-STATUS
            END-IF
            .
])

# FIXME: by default comp-x should not be truncated (see trunk)
AT_CHECK([$COMPILE -fnotrunc prog.cob], [0], [], [])

AT_CHECK([TESTOUT=TEST-OUT $COBCRUN_DIRECT ./prog], [0],
[FCD SIZE 00216
], [])


AT_CAPTURE_FILE([TEST-OUT])

# note: currently with the same behaviour as MF
#       (ignoring minimal record length for line-sequential)
#       this may change in the future...
AT_DATA([reference],
[  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
])

AT_CHECK([diff reference TEST-OUT], [0], [], [])

AT_CLEANUP


AT_SETUP([EXTFH: LINE SEQUENTIAL files (2)])
AT_KEYWORDS([runfile EXTFH])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       78  PROGRAM-NAME  VALUE 'SEQEXTFH'.
       01  FCDOPCODE.
           02  FILLER             PIC X               VALUE X'FA'.
           02  EXTFH-OPCODE       PIC X.
      *    STANDARD OPERATION CODES
           88  EXTFH-OPCODE-ISOPENINPUT               VALUE X'00'.
           88  EXTFH-OPCODE-ISOPENOUTPUT              VALUE X'01'.
           88  EXTFH-OPCODE-ISREADSEQUENTIAL          VALUE X'8D'.
           88  EXTFH-OPCODE-ISCLOSE                   VALUE X'80'.
           88  EXTFH-OPCODE-ISWRITE                   VALUE X'F3'.
       01  FCD-PARAMETER-BLOCK.
           copy xfhfcd3.
       01  LSEQ-FILENAME PIC X(44)
            VALUE 'FCDLS'.
       01  LSEQ-RECORDAREA PIC X(255).
       01  LSEQ-RECORDS.
           02  LSEQ-COUNT             PIC X    COMP-X  VALUE 3.
           02  LSEQ-RECORD1.
               03  LSEQ-1LENGTH       PIC X    COMP-X  VALUE 22.
               03  LSEQ-1DATA         PIC X(80)
               VALUE 'THERE IS LITTLE LAMB'.
           02  LSEQ-RECORD2.
               03  LSEQ-2LENGTH       PIC X    COMP-X  VALUE 33.
               03  LSEQ-2DATA         PIC X(80)
               VALUE 'THE LAMB WAS GRAND AND A GRANDMA'.
           02  LSEQ-RECORD3.
               03  LSEQ-3LENGTH       PIC X    COMP-X  VALUE 22.
               03  LSEQ-3DATA         PIC X(80)
               VALUE 'THE OLD EWE CHORTLED'.
       01  LSEQ-RECORDTABLE
               REDEFINES LSEQ-RECORDS.
           02  LSEQ-TCOUNT            PIC X    COMP-X.
           02  LSEQ-TENTRY            OCCURS 3 TIMES
                                      INDEXED BY LSEQ-TX.
               03  LSEQ-TEST-LEN      PIC X    COMP-X.
               03  LSEQ-TESTDATA      PIC X(80).
       PROCEDURE DIVISION.
           DISPLAY PROGRAM-NAME ': STARTING.'
           DISPLAY PROGRAM-NAME ': CREATING LINE SEQUENTIAL FILE.'
           SET EXTFH-OPCODE-ISOPENOUTPUT      TO TRUE
           MOVE LENGTH OF FCD-PARAMETER-BLOCK TO FCD-LENGTH
           MOVE fcd--version-number           TO FCD-VERSION
           MOVE fcd--open-closed              TO FCD-OPEN-MODE
           MOVE LENGTH OF LSEQ-FILENAME       TO FCD-NAME-LENGTH
           MOVE fcd--exclusive-bit            TO FCD-LOCK-MODE
           MOVE fcd--format-cobol2            TO FCD-FILE-FORMAT
           MOVE LENGTH OF LSEQ-RECORDAREA TO FCD-MAX-REC-LENGTH
           MOVE fcd--recmode-variable TO FCD-RECORDING-MODE
           MOVE 0 TO FCD-MIN-REC-LENGTH
           SET FCD-FILENAME-ADDRESS TO ADDRESS OF LSEQ-FILENAME
           PERFORM CALL-EXTFH
           PERFORM FCD-CHECK-STAT
           IF FCD-FILE-STATUS = '00'
             DISPLAY PROGRAM-NAME
                 ': LINE SEQUENTIAL FILE IS OPEN OUTPUT.'
             PERFORM WITH TEST AFTER VARYING LSEQ-TX FROM 1 BY 1
                 UNTIL LSEQ-TX = LSEQ-TCOUNT OR FCD-FILE-STATUS <> '00'
               SET EXTFH-OPCODE-ISWRITE       TO TRUE
               MOVE LSEQ-TEST-LEN (LSEQ-TX) TO FCD-CURRENT-REC-LEN
               MOVE 1 TO FCD-LINE-COUNT
               SET FCD-RECORD-ADDRESS TO
                ADDRESS OF LSEQ-TESTDATA (LSEQ-TX)
               PERFORM CALL-EXTFH
               PERFORM FCD-CHECK-STAT
             END-PERFORM
             IF FCD-FILE-STATUS = '00'
               DISPLAY PROGRAM-NAME ': LINE SEQUENTIAL WRITES COMPLETE.'
             ELSE
               DISPLAY PROGRAM-NAME
                   ': UNABLE TO CREATE LINE SEQUENTIAL FILE.'
             END-IF
             SET EXTFH-OPCODE-ISCLOSE       TO TRUE
             PERFORM CALL-EXTFH
             PERFORM FCD-CHECK-STAT
             IF FCD-FILE-STATUS = '00'
              DISPLAY PROGRAM-NAME ': LINE SEQUENTIAL FILE IS CLOSED.'
             ELSE
              DISPLAY PROGRAM-NAME
                  ': UNABLE TO CLOSE LINE SEQUENTIAL FILE.'
             END-IF
           ELSE
             DISPLAY PROGRAM-NAME
                 ': UNABLE TO OPEN LINE SEQUENTIAL FILE AS OUTPUT.'
             STOP RUN
           END-IF
           DISPLAY PROGRAM-NAME ': READING LINE SEQUENTIAL FILE.'
           SET EXTFH-OPCODE-ISOPENINPUT       TO TRUE
           MOVE fcd--open-closed              TO FCD-OPEN-MODE
           MOVE LENGTH OF LSEQ-FILENAME       TO FCD-NAME-LENGTH
           MOVE fcd--exclusive-bit            TO FCD-LOCK-MODE
           MOVE LENGTH OF LSEQ-RECORDAREA     TO FCD-MAX-REC-LENGTH
           MOVE 0 TO FCD-MIN-REC-LENGTH
           SET FCD-FILENAME-ADDRESS TO ADDRESS OF LSEQ-FILENAME
           PERFORM CALL-EXTFH
           PERFORM FCD-CHECK-STAT
           IF FCD-FILE-STATUS = '00'
             SET FCD-RECORD-ADDRESS
              TO ADDRESS OF LSEQ-RECORDAREA
             DISPLAY PROGRAM-NAME
                 ': LINE SEQUENTIAL FILE IS OPEN INPUT.'
             PERFORM WITH TEST AFTER UNTIL FCD-FILE-STATUS <> '00'
               SET EXTFH-OPCODE-ISREADSEQUENTIAL  TO TRUE
               PERFORM CALL-EXTFH
               PERFORM FCD-CHECK-STAT
               IF FCD-FILE-STATUS = '00'
                 DISPLAY PROGRAM-NAME
                     ': RECORD = ' LSEQ-RECORDAREA
                                   (1:FCD-CURRENT-REC-LEN)
               END-IF
             END-PERFORM
             IF FCD-FILE-STATUS = '00' OR '10'
               DISPLAY PROGRAM-NAME ': LINE SEQUENTIAL READS COMPLETE.'
             ELSE
               DISPLAY PROGRAM-NAME
                   ': UNABLE TO READ LINE SEQUENTIAL FILE.'
             END-IF
             SET EXTFH-OPCODE-ISCLOSE       TO TRUE
             PERFORM CALL-EXTFH
             PERFORM FCD-CHECK-STAT
             IF FCD-FILE-STATUS = '00'
               DISPLAY PROGRAM-NAME ': LSEQ FILE IS CLOSED.'
             ELSE
               DISPLAY PROGRAM-NAME
                   ': UNABLE TO CLOSE LINE SEQUENTIAL FILE.'
             END-IF
           ELSE
             DISPLAY PROGRAM-NAME
                 ': UNABLE TO OPEN LINE SEQUENTIAL FILE AS INPUT.'
             STOP RUN
           END-IF
           DISPLAY PROGRAM-NAME ': ENDING.'
           STOP RUN.
       CALL-EXTFH.
           CALL 'EXTFH' USING
                        FCDOPCODE
                        FCD-PARAMETER-BLOCK.
       FCD-CHECK-STAT.
           IF FCD-STATUS-KEY-1 = '9'
             DISPLAY PROGRAM-NAME ': RUN-TIME ERROR 9/' FCD-BINARY
           ELSE
             IF FCD-FILE-STATUS <> '00'
               DISPLAY PROGRAM-NAME ': FILE STATUS = ' FCD-FILE-STATUS
             ELSE
               CONTINUE
             END-IF
           END-IF.
       SEQEXTFH-TERM.
           EXIT.
])

# FIXME: by default comp-x should not be truncated (see trunk)
AT_CHECK([$COMPILE -fnotrunc prog.cob], [0], [], [])

AT_CHECK([DD_FCDLS=./report.txt \
$COBCRUN_DIRECT ./prog], [0],
[SEQEXTFH: STARTING.
SEQEXTFH: CREATING LINE SEQUENTIAL FILE.
SEQEXTFH: LINE SEQUENTIAL FILE IS OPEN OUTPUT.
SEQEXTFH: LINE SEQUENTIAL WRITES COMPLETE.
SEQEXTFH: LINE SEQUENTIAL FILE IS CLOSED.
SEQEXTFH: READING LINE SEQUENTIAL FILE.
SEQEXTFH: LINE SEQUENTIAL FILE IS OPEN INPUT.
SEQEXTFH: RECORD = THERE IS LITTLE LAMB
SEQEXTFH: RECORD = THE LAMB WAS GRAND AND A GRANDMA
SEQEXTFH: RECORD = THE OLD EWE CHORTLED
SEQEXTFH: FILE STATUS = 10
SEQEXTFH: LINE SEQUENTIAL READS COMPLETE.
SEQEXTFH: LSEQ FILE IS CLOSED.
SEQEXTFH: ENDING.
], [])


AT_CAPTURE_FILE([report.txt])

AT_DATA([reference],
[THERE IS LITTLE LAMB
THE LAMB WAS GRAND AND A GRANDMA
THE OLD EWE CHORTLED
])

AT_CHECK([diff reference report.txt], [0])

AT_CLEANUP


AT_SETUP([EXTFH: FIXED SEQUENTIAL])
AT_KEYWORDS([runfile EXTFH])

# CHECKME: Should it really be possible to change the length
# with a line-sequentia file this way?
# If yes: should there be an implied "WRITE FROM" - so
# that an intermediate record field, space padded, is
# internally used?

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
      ** TEST FIXED (BLOCK) LENGTH SEQUENTIAL RECORD EXTFH
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       78  PROGRAM-NAME  VALUE 'FBSEXTFH'.
       01  FCDOPCODE.
           02  FILLER              PIC X               VALUE X'FA'.
           02  EXTFH-OPCODE        PIC X.
      *    STANDARD OPERATION CODES
           88  EXTFH-OPCODE-ISOPENINPUT               VALUE X'00'.
           88  EXTFH-OPCODE-ISOPENOUTPUT              VALUE X'01'.
           88  EXTFH-OPCODE-ISREADSEQUENTIAL          VALUE X'8D'.
           88  EXTFH-OPCODE-ISCLOSE                   VALUE X'80'.
           88  EXTFH-OPCODE-ISWRITE                   VALUE X'F3'.
      *
       01  FCD-PARAMETER-BLOCK.
           copy xfhfcd3.
       01  FIX-FILENAME PIC X(44)
            VALUE 'FCDFB'.
       01  FIX-RECORDAREA PIC X(255).
       01  FIX-RECORDS.
           02  FIX-COUNT              PIC X    COMP-X  VALUE 3.
           02  FIX-RECORD1.
               03  FIX-1LENGTH        PIC X    COMP-X  VALUE 22.
               03  FIX-1DATA          PIC X(80)
               VALUE 'THERE IS LITTLE LAMB'.
           02  FIX-RECORD2.
               03  FIX-2LENGTH        PIC X    COMP-X  VALUE 33.
               03  FIX-2DATA          PIC X(80)
               VALUE 'THE LAMB WAS GRAND AND A GRANDMA'.
           02  FIX-RECORD3.
               03  FIX-3LENGTH        PIC X    COMP-X  VALUE 22.
               03  FIX-3DATA          PIC X(80)
               VALUE 'THE OLD EWE CHORTLED'.
       01  FIX-RECORDTABLE
               REDEFINES FIX-RECORDS.
           02  FIX-TCOUNT             PIC X    COMP-X.
           02  FIX-TENTRY             OCCURS 3 TIMES
                                      INDEXED BY FIX-TX.
               03  FIX-TEST-LEN       PIC X    COMP-X.
               03  FIX-TESTDATA       PIC X(80).
       PROCEDURE DIVISION.
           DISPLAY PROGRAM-NAME ': STARTING.'
           DISPLAY PROGRAM-NAME ': CREATING FIXED  SEQ FILE.'
           SET EXTFH-OPCODE-ISOPENOUTPUT      TO TRUE
           MOVE LENGTH OF FCD-PARAMETER-BLOCK TO FCD-LENGTH
           move fcd--version-number TO FCD-VERSION
           MOVE fcd--sequential-org TO FCD-ORGANIZATION
           MOVE fcd--open-closed TO FCD-OPEN-MODE
           MOVE LENGTH OF FIX-FILENAME TO FCD-NAME-LENGTH
           MOVE fcd--exclusive-bit TO FCD-LOCK-MODE
           move fcd--format-cobol2 to FCD-FILE-FORMAT
           MOVE LENGTH OF FIX-RECORDAREA TO FCD-MAX-REC-LENGTH
           MOVE 0 TO FCD-MIN-REC-LENGTH
           SET FCD-FILENAME-ADDRESS TO ADDRESS OF FIX-FILENAME
           MOVE 80 TO FCD-CURRENT-REC-LEN
           MOVE 80 TO FCD-MAX-REC-LENGTH
           MOVE 80 TO FCD-MIN-REC-LENGTH
           PERFORM CALL-EXTFH
           PERFORM FCD-CHECK-STAT
           IF FCD-FILE-STATUS = '00'
             DISPLAY PROGRAM-NAME
                 ': FIXED  SEQ FILE IS OPEN OUTPUT.'
             PERFORM WITH TEST AFTER VARYING FIX-TX FROM 1 BY 1
                 UNTIL FIX-TX = FIX-TCOUNT OR FCD-FILE-STATUS <> '00'
               SET EXTFH-OPCODE-ISWRITE       TO TRUE
               MOVE FIX-TEST-LEN (FIX-TX) TO FCD-CURRENT-REC-LEN
               MOVE 1 TO FCD-LINE-COUNT
               SET FCD-RECORD-ADDRESS TO
                ADDRESS OF FIX-TESTDATA (FIX-TX)
               PERFORM CALL-EXTFH
               PERFORM FCD-CHECK-STAT
             END-PERFORM
             IF FCD-FILE-STATUS = '00'
               DISPLAY PROGRAM-NAME ': FIXED  SEQ WRITES COMPLETE.'
             ELSE
               DISPLAY PROGRAM-NAME
                   ': UNABLE TO CREATE FIXED  SEQ FILE.'
             END-IF
             SET EXTFH-OPCODE-ISCLOSE       TO TRUE
             PERFORM CALL-EXTFH
             PERFORM FCD-CHECK-STAT
             IF FCD-FILE-STATUS = '00'
              DISPLAY PROGRAM-NAME ': FIXED  SEQ FILE IS CLOSED.'
             ELSE
              DISPLAY PROGRAM-NAME
                  ': UNABLE TO CLOSE FIXED  SEQ FILE.'
             END-IF
           ELSE
             DISPLAY PROGRAM-NAME
                 ': UNABLE TO OPEN FIXED  SEQ FILE AS OUTPUT.'
             STOP RUN
           END-IF
           DISPLAY PROGRAM-NAME ': READING FIXED  SEQ FILE.'
           SET EXTFH-OPCODE-ISOPENINPUT       TO TRUE
           MOVE fcd--sequential-org TO FCD-ORGANIZATION
           MOVE fcd--open-closed TO FCD-OPEN-MODE
           MOVE LENGTH OF FIX-FILENAME TO FCD-NAME-LENGTH
           MOVE fcd--exclusive-bit TO FCD-LOCK-MODE
           move fcd--format-cobol2 to FCD-FILE-FORMAT
           MOVE LENGTH OF FIX-RECORDAREA TO FCD-MAX-REC-LENGTH
           MOVE 0 TO FCD-MIN-REC-LENGTH
           SET FCD-FILENAME-ADDRESS TO ADDRESS OF FIX-FILENAME
           MOVE 80 TO FCD-CURRENT-REC-LEN
           MOVE 80 TO FCD-MAX-REC-LENGTH
           MOVE 80 TO FCD-MIN-REC-LENGTH
           PERFORM CALL-EXTFH
           PERFORM FCD-CHECK-STAT
           IF FCD-FILE-STATUS = '00'
             DISPLAY PROGRAM-NAME
                 ': FIXED  SEQ FILE IS OPEN INPUT.'
             PERFORM WITH TEST AFTER UNTIL FCD-FILE-STATUS <> '00'
               SET EXTFH-OPCODE-ISREADSEQUENTIAL  TO TRUE
               SET FCD-RECORD-ADDRESS
                TO ADDRESS OF FIX-RECORDAREA
               PERFORM CALL-EXTFH
               PERFORM FCD-CHECK-STAT
               IF FCD-FILE-STATUS = '00'
                 DISPLAY PROGRAM-NAME
                     ': RECORD = ' FIX-RECORDAREA (1:40) '. '
                     'Size:' FCD-CURRENT-REC-LEN
               END-IF
             END-PERFORM
             IF FCD-FILE-STATUS = '00' OR '10'
               DISPLAY PROGRAM-NAME ': FIXED  SEQ READS COMPLETE.'
             ELSE
               DISPLAY PROGRAM-NAME
                   ': UNABLE TO READ FIXED  SEQ FILE.'
             END-IF
             SET EXTFH-OPCODE-ISCLOSE       TO TRUE
             PERFORM CALL-EXTFH
             PERFORM FCD-CHECK-STAT
             IF FCD-FILE-STATUS = '00'
               DISPLAY PROGRAM-NAME ': LSEQ FILE IS CLOSED.'
             ELSE
               DISPLAY PROGRAM-NAME
                   ': UNABLE TO CLOSE FIXED  SEQ FILE.'
             END-IF
           ELSE
             DISPLAY PROGRAM-NAME
                 ': UNABLE TO OPEN FIXED  SEQ FILE AS INPUT.'
             STOP RUN
           END-IF
           DISPLAY PROGRAM-NAME ': ENDING.'
           STOP RUN.
       CALL-EXTFH.
           CALL 'EXTFH' USING
                        FCDOPCODE
                        FCD-PARAMETER-BLOCK.
       FCD-CHECK-STAT.
           IF FCD-STATUS-KEY-1 = '9'
             DISPLAY PROGRAM-NAME ': RUN-TIME ERROR 9/' FCD-BINARY
           ELSE
             IF FCD-FILE-STATUS <> '00'
               DISPLAY PROGRAM-NAME ': FILE STATUS = ' FCD-FILE-STATUS
             ELSE
               CONTINUE
             END-IF
           END-IF.
       SEQEXTFH-TERM.
           EXIT.
])

# FIXME: by default comp-x should not be truncated (see trunk)
AT_CHECK([$COMPILE -fnotrunc prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[FBSEXTFH: STARTING.
FBSEXTFH: CREATING FIXED  SEQ FILE.
FBSEXTFH: FIXED  SEQ FILE IS OPEN OUTPUT.
FBSEXTFH: FIXED  SEQ WRITES COMPLETE.
FBSEXTFH: FIXED  SEQ FILE IS CLOSED.
FBSEXTFH: READING FIXED  SEQ FILE.
FBSEXTFH: FIXED  SEQ FILE IS OPEN INPUT.
FBSEXTFH: RECORD = THERE IS LITTLE LAMB                    . Size:0000000080
FBSEXTFH: RECORD = THE LAMB WAS GRAND AND A GRANDMA        . Size:0000000080
FBSEXTFH: RECORD = THE OLD EWE CHORTLED                    . Size:0000000080
FBSEXTFH: FILE STATUS = 10
FBSEXTFH: FIXED  SEQ READS COMPLETE.
FBSEXTFH: LSEQ FILE IS CLOSED.
FBSEXTFH: ENDING.
], [])

AT_CLEANUP


AT_SETUP([EXTFH: operation OP_GETINFO / QUERY-FILE])
AT_KEYWORDS([runfile EXTFH GETINFO QUERY])

# FIXME: BDB has no way to get definition until 4.x (filename.dd)
AT_SKIP_IF([test "$COB_HAS_ISAM" = "db"])

# TODO: duplicate with line sequential, likely needs update to fileio first
AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT OPTIONAL TSPFILE
           ASSIGN TO FCD-FILENAME
           ORGANIZATION INDEXED ACCESS DYNAMIC
           RECORD KEY IS CM-CUST-NUM
           ALTERNATE RECORD KEY IS CM-TELEPHONE WITH DUPLICATES
           ALTERNATE RECORD KEY IS SPLIT-KEY3
           SOURCE IS CM-DISK,CM-DP-MGR,CM-MACHINE WITH DUPLICATES
                SUPPRESS WHEN ALL "*"
           FILE STATUS IS CUST-STAT .

       DATA DIVISION.
       FILE SECTION.
       FD  TSPFILE
           BLOCK CONTAINS 5 RECORDS.

       01  TSPFL-RECORD.
           05  TSPFL-REC.
           10  CM-CUST-NUM.
             15  CM-CUST-PRE                   PICTURE X(3).
             15  CM-CUST-NNN                   PICTURE X(5).
           10  CM-STATUS                       PICTURE X.
           10  CM-COMPANY                      PICTURE X(25).
           10  CM-ADDRESS-1                    PICTURE X(25).
           10  CM-ADDRESS-2                    PICTURE X(25).
           10  CM-ADDRESS-3                    PICTURE X(25).
           10  CM-TELEPHONE                    PICTURE 9(10).
           10  CM-DP-MGR                       PICTURE X(25).
           10  CM-MACHINE                      PICTURE X(8).
           10  CM-MEMORY                       PICTURE X(4).
           10  CM-DISK                         PICTURE X(8).
           10  CM-TAPE                         PICTURE X(8).
           10  CM-NO-TERMINALS                 PICTURE 9(5).

       WORKING-STORAGE SECTION.

       01  I                       PIC 99.
       01  K                       PIC 99.

       01  CUST-STAT               PIC X(2) VALUE SPACES.
       01  WS-FCD-DDNAME           PIC X(8) VALUE SPACES.
       01  WS-FCD-PTR              POINTER   VALUE NULL.

       01  ACTION-CODE                PIC X(2).
          78  OP-OPEN-INPUT           VALUE x"fa00".
          78  OP-OPEN-OUTPUT          VALUE x"fa01".
          78  OP-OPEN-I-O             VALUE x"fa02".
          78  OP-WRITE                VALUE x"faf3".
          78  OP-RELEASE              VALUE x"faf3".
          78  OP-REWRITE              VALUE x"faf4".
          78  OP-READ-NEXT            VALUE x"faf5".
          78  OP-START-EQUAL          VALUE x"fae9".
          78  OP-CLOSE                VALUE x"fa80".
          78  OP-QUERY-FILE           VALUE x"0006".

       01  FCD-FILENAME               PIC X(80) value "testisam".
       01  FCD-RECORD                 PIC X(512) VALUE SPACES.

       01  FCD-MAP.
           COPY 'xfhfcd3.cpy'.

       01  KEY-DEF.
           03 KDB-LEN             PIC 9(4) COMP-X.
           03 FILLER              PIC X(4).
           03 KEY-NKEYS           PIC 9(4) COMP-X.
           03 FILLER              PIC X(6).
           03 KEY-DEFS OCCURS 16 TIMES.
               05 KEY-COUNT       PIC XX   COMP-X.
               05 KEY-OFFSET      PIC XX   COMP-X.
               05 KEY-FLAGS       PIC X    COMP-X.
               05 KEY-COMPRESSION PIC X    COMP-X.
               05 KEY-SPARSE      PIC X    COMP-X.
               05 FILLER          PIC X(9).
           03 FILLER              PIC X(128).

       LINKAGE SECTION.
       01  KEY-INF.
           03 KEY-DESC            PIC X COMP-X.
           03 KEY-TYPE            PIC X COMP-X.
           03 KEY-POS             PIC X(4) COMP-X.
           03 KEY-LEN             PIC X(4) COMP-X.
      *================================================================*
       PROCEDURE DIVISION.
      *----------------------------------------------------------------*
       000-MAIN.

          DELETE FILE TSPFILE.
          OPEN OUTPUT TSPFILE.
          WRITE TSPFL-RECORD.
          CLOSE TSPFILE.

          SET FCD-KEY-DEF-ADDRESS  TO ADDRESS OF KEY-DEF.
          SET FCD-FILENAME-ADDRESS TO ADDRESS OF FCD-FILENAME.
          MOVE 64 TO FCD-NAME-LENGTH
          MOVE LENGTH OF KEY-DEF TO KDB-LEN.
          SET FCD-RECORD-ADDRESS   TO ADDRESS OF FCD-RECORD.
          MOVE 512 TO FCD-CURRENT-REC-LEN
          MOVE 512 TO FCD-MIN-REC-LENGTH
          MOVE 512 TO FCD-MAX-REC-LENGTH
          MOVE 1 TO FCD-VERSION
          MOVE 255 TO FCD-ORGANIZATION
          MOVE OP-QUERY-FILE TO ACTION-CODE
          PERFORM 800-CALL-EXTFH.
          DISPLAY "Status: " FCD-FILE-STATUS
                  " File: " FCD-FILENAME (1:20) "."
          DISPLAY " Nkeys: " key-nkeys
                  " Recsz: " FCD-MAX-REC-LENGTH.
          DISPLAY "kdblen: " kdb-len.
          PERFORM VARYING I FROM 1 UNTIL I > KEY-NKEYS
             DISPLAY " Index: " i
                     " Parts: " key-count (i)
                     " Offset: " key-offset (i)
                     " Flags: " key-flags (i)
                     " Comp: " key-compression (i)
                     " Sparse: " key-sparse (i)
             SET WS-FCD-PTR TO ADDRESS OF key-def
             SET WS-FCD-PTR UP BY key-offset (i)
             SET ADDRESS OF key-inf TO WS-FCD-PTR
             PERFORM VARYING K FROM 1 UNTIL K > KEY-count (i)
                DISPLAY "   Pos: " key-pos
                        "   Len: " key-len
                        "   Desc: " key-desc
                        " Type: " key-type
                SET WS-FCD-PTR UP BY LENGTH OF key-inf
                SET ADDRESS OF key-inf TO WS-FCD-PTR
             END-PERFORM
          END-PERFORM.

          STOP RUN.

      *----------------------------------------------------------------*
      *    External file handler interface -- all I/O goes through here
      *
        800-CALL-EXTFH.

            CALL "EXTFH" USING ACTION-CODE, FCD-MAP

            IF FCD-STATUS-KEY-1 = "9" AND FCD-BINARY = 199
               MOVE "10" TO FCD-FILE-STATUS
            END-IF
            .
])

# FIXME: by default comp-x should not be truncated (see trunk)
AT_CHECK([$COMPILE -fnotrunc prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[Status: 00 File: testisam            .
 Nkeys: 0003 Recsz: 0000000177
kdblen: 0398
 Index: 01 Parts: 00001 Offset: 00062 Flags: 000 Comp: 000 Sparse: 000
   Pos: 0000000000   Len: 0000000008   Desc: 000 Type: 000
 Index: 02 Parts: 00001 Offset: 00072 Flags: 064 Comp: 000 Sparse: 000
   Pos: 0000000109   Len: 0000000010   Desc: 032 Type: 032
 Index: 03 Parts: 00003 Offset: 00082 Flags: 066 Comp: 000 Sparse: 042
   Pos: 0000000156   Len: 0000000008   Desc: 000 Type: 000
   Pos: 0000000119   Len: 0000000025   Desc: 000 Type: 000
   Pos: 0000000144   Len: 0000000008   Desc: 000 Type: 000
], [])

AT_CLEANUP


# TODO: add missing test for CLOSE options (most important: REEL)
#       which are missing both for "normal" io and for EXTFH tests


AT_SETUP([EXTFH: changing record address])
AT_KEYWORDS([runfile EXTFH])

# TODO: replace INDEXED with line sequential (or duplicate)
AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([progl.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.

       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       INPUT-OUTPUT  SECTION.
       FILE-CONTROL.
           SELECT OUTFILE
           ASSIGN "TEST1EXTFH"
           ORGANIZATION INDEXED
           RECORD KEY IS PRIME-KEY
           ACCESS IS SEQUENTIAL
           FILE STATUS IS OUT-STAT.

       DATA DIVISION.
       FILE SECTION.
       FD OUTFILE
           BLOCK CONTAINS 5 RECORDS.

       01  OUT-REC.
           05  PRIME-KEY PIC X(25).
           05  IN-DATA   PIC X(10).

       WORKING-STORAGE SECTION.
       01  OUT-STAT             PIC XX    VALUE '00'.
       01  OUT-RECNUM           PIC 9 VALUE 0.

       PROCEDURE DIVISION.
       MAIN-100.
           OPEN OUTPUT OUTFILE.
           IF OUT-STAT NOT = '00'
               DISPLAY 'ERROR ' OUT-STAT ' OPENING OUTPUT FILE'
               STOP RUN
           END-IF.
           INITIALIZE OUT-REC.

       GET-NEXT-100.
           ADD 1  TO OUT-RECNUM.
           MOVE "RECORD-X" TO PRIME-KEY.
           MOVE OUT-RECNUM TO PRIME-KEY (8:1).
           WRITE OUT-REC.
           IF  OUT-STAT NOT = '00'
           AND OUT-STAT NOT = '02'
               DISPLAY 'ERROR ' OUT-STAT ' WRITING OUTPUT'
               GO TO END-PROG-100
           END-IF.
           IF OUT-RECNUM < 5
               GO TO GET-NEXT-100.

       END-PROG-100.
           DISPLAY OUT-RECNUM ' records written'.
           CLOSE OUTFILE.
           STOP RUN.
])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
      *
       PROGRAM-ID. prog.
       DATA DIVISION.

       WORKING-STORAGE SECTION.

       77  I                               PIC 9(04) COMP-5.
       77  J                               PIC 9(04) COMP-5.
       77  K                               PIC 9(04) COMP-5.
       77  L                               PIC 9(04) COMP-5.
       77  M                               PIC 9(04) COMP-5.
       01  OP-N                            PIC X COMP-X.
       01  OP-X REDEFINES OP-N             PIC X.

       01  ACTION-CODE.
           05  ACTION-TYPE    PIC X(01).
               78  COBOL-TYPE                  VALUE X'FA'.
               78  SPECIAL-TYPE                VALUE X'00'.
           05  COBOL-OP       PIC X(01).
               78  OPEN-INPUT                  VALUE X'00'.
               78  OPEN-OUTPUT                 VALUE X'01'.
               78  OPEN-I-O                    VALUE X'02'.
               78  OPEN-EXTEND                 VALUE X'03'.
               78  OPEN-INPUT-NO-REWIND        VALUE X'04'.
               78  OPEN-OUTPUT-NO-REWIND       VALUE X'05'.
               78  OPEN-INPUT-REVERSED         VALUE X'08'.
               78  CLOSE-FILE                  VALUE X'80'.
               78  CLOSE-LOCK                  VALUE X'81'.
               78  CLOSE-NO-REWIND             VALUE X'82'.
               78  CLOSE-REEL-UNIT             VALUE X'84'.
               78  CLOSE-REEL-UNIT-FOR-REMOVAL VALUE X'85'.
               78  CLOSE-REEL-UNIT-NO-REWIND   VALUE X'86'.
               78  READ-SEQ-NO-LOCK            VALUE X'8D'.
               78  READ-SEQ-LOCK               VALUE X'D8'.
               78  READ-SEQ-KEPT-LOCK          VALUE X'D9'.
               78  READ-SEQ                    VALUE X'F5'.
               78  READ-PREVIOUS-NO-LOCK       VALUE X'8C'.
               78  READ-PREVIOUS-LOCK          VALUE X'DE'.
               78  READ-PREVIOUS-KEPT-LOCK     VALUE X'DF'.
               78  READ-PREVIOUS               VALUE X'F9'.
               78  READ-RANDOM-NO-LOCK         VALUE X'8E'.
               78  READ-RANDOM-LOCK            VALUE X'DA'.
               78  READ-RANDOM-KEPT-LOCK       VALUE X'DB'.
               78  READ-RANDOM                 VALUE X'F6'.
               78  READ-DIRECT-NO-LOCK         VALUE X'8F'.
               78  READ-DIRECT-LOCK            VALUE X'D6'.
               78  READ-DIRECT-KEPT-LOCK       VALUE X'D7'.
               78  READ-DIRECT                 VALUE X'C9'.
               78  READ-POSITION               VALUE X'F1'.
               78  WRITE-BEFORE                VALUE X'E1'.
               78  WRITE-AFTER                 VALUE X'E2'.
               78  WRITE-BEFORE-TAB            VALUE X'E3'.
               78  WRITE-AFTER-TAB             VALUE X'E4'.
               78  WRITE-BEFORE-PAGE           VALUE X'E5'.
               78  WRITE-AFTER-PAGE            VALUE X'E6'.
               78  WRITE-RECORD                VALUE X'F3'.
               78  REWRITE-RECORD              VALUE X'F4'.
               78  START-EQUAL-PRIME-KEY       VALUE X'E8'.
               78  START-EQUAL-KEY             VALUE X'E9'.
               78  START-GREATER               VALUE X'EA'.
               78  START-NOT-LESS              VALUE X'EB'.
               78  START-LESS                  VALUE X'FE'.
               78  START-LESS-OR-EQUAL         VALUE X'FF'.
               78  STEP-NEXT-NO-LOCK           VALUE X'90'.
               78  STEP-NEXT-LOCK              VALUE X'D4'.
               78  STEP-NEXT-KEPT-LOCK         VALUE X'D5'.
               78  STEP-NEXT                   VALUE X'CA'.
               78  STEP-FIRST-NO-LOCK          VALUE X'92'.
               78  STEP-FIRST-LOCK             VALUE X'D0'.
               78  STEP-FIRST-KEPT-LOCK        VALUE X'D1'.
               78  STEP-FIRST                  VALUE X'CC'.
               78  DELETE-RECORD               VALUE X'F7'.
               78  DELETE-FILE                 VALUE X'F8'.
               78  UNLOCK-CURRENT              VALUE X'0E'.
               78  COMMIT-ALL                  VALUE X'DC'.
               78  ROLLBACK-ALL                VALUE X'DD'.
               78  GET-FILE-INFO               VALUE X'06'.
               78  OPEN-NEW-INDEX              VALUE X'07'.
               78  GET-NEXT-RECORD             VALUE X'08'.
               78  ADD-KEY-VALUE               VALUE X'09'.
               78  UNLOCK-RECORD               VALUE X'0F'.

       01  FCD-AREA.
           COPY xfhfcd.

       01  FILE-NAME                       PIC X(64).
       01  FILE-NAME-LEN                   PIC 9(04) COMP-X.

       01  RECORD-AREA.
           05  PRIME-KEY                   PIC X(25).
           05  DATA-AREA                   PIC X(10).

       01  RECORD-AREA2.
           05  PRIME-KEY2                  PIC X(25).
           05  DATA-AREA2                  PIC X(10).

       01  KEY-DEF-AREA.
           05  GLOBAL-INFORMATION-AREA.
               10  LENGTH-OF-KEY-DEF-AREA  PIC 9(04) COMP-X.
               10  FILLER                  PIC X(04).
               10  NUMBER-OF-KEYS          PIC 9(04) COMP-X.
               10  FILLER                  PIC X(06).
           05  KEY-DEF-AREA-PARAM-BLOCK.
               10  COMPONENT-COUNT         PIC 9(04) COMP-X.
               10  OFFSET-TO-COMPONENT     PIC 9(04) COMP-X.
               10  KEY-FLAGS               PIC 9(02) COMP-X.
               10  KEY-COMPRESSION         PIC 9(02) COMP-X.
               10  SPARSE-CHARACTER        PIC X(01).
               10  FILLER                  PIC X(09).
           05  COMPONENT-DEF-AREA.
               10  FILLER                  PIC X(02).
               10  OFFSET-TO-COMPONENT-DEF PIC 9(09) COMP-X.
               10  COMPONENT-LENGTH        PIC 9(09) COMP-X.


      **************************************************************
       PROCEDURE DIVISION.
      **************************************************************
       0000-MAIN.
           PERFORM 1000-OPEN-FILE.
           PERFORM 2000-READ-RECORD.
           DISPLAY 'AFTER READ ------> ' RECORD-AREA '.'.
           MOVE '1234567890' TO DATA-AREA.
           PERFORM 3000-REWRITE-RECORD.
           PERFORM 2000-READ-RECORD.
           DISPLAY 'AFTER WRITE -----> ' RECORD-AREA '.'.
           MOVE SPACES TO DATA-AREA.
           PERFORM 3000-REWRITE-RECORD.
           PERFORM 5000-CLOSE-FILE.
           PERFORM 1000-OPEN-FILE.
           PERFORM 6000-START.
           PERFORM 7000-READ-PREVIOUS.
           DISPLAY 'AFTER READ PREV -> ' RECORD-AREA2 '.'.
           PERFORM 5000-CLOSE-FILE.

           STOP RUN.
      *
      *--------------------------------*
       1000-Open-File.
      *--------------------------------*
      *
           MOVE 'TEST1EXTFH' TO FILE-NAME
           MOVE 10           TO FILE-NAME-LEN

      *    MOVE LOW-VALUES             TO FCD-AREA
           MOVE FCD--VERSION-NUMBER    TO FCD-VERSION

           MOVE FCD--INDEXED-ORG       TO FCD-ORGANIZATION
           MOVE FILE-NAME-LEN          TO FCD-NAME-LENGTH
           SET  FCD-FILENAME-ADDRESS   TO ADDRESS OF FILE-NAME
           SET  FCD-KEY-DEF-ADDRESS    TO ADDRESS OF KEY-DEF-AREA
           MOVE 16                     TO FCD-FS-FLAGS
           MOVE LENGTH OF RECORD-AREA  TO FCD-CURRENT-REC-LEN
           MOVE 1                      TO NUMBER-OF-KEYS
           MOVE LENGTH OF PRIME-KEY    TO COMPONENT-LENGTH
           MOVE 8                      TO FCD-ACCESS-MODE
           MOVE 0                      TO FCD-LOCK-MODE
           MOVE 128                    TO FCD-OPEN-MODE

           MOVE COBOL-TYPE             TO ACTION-TYPE
           MOVE OPEN-I-O               TO COBOL-OP
           PERFORM 1100-CALL-EXTFH.

      *
      *--------------------------------*
       1100-Call-Extfh.
      *--------------------------------*
      *
           CALL 'EXTFH' USING ACTION-CODE
                              FCD-AREA
           IF FCD-FILE-STATUS NOT = '00'
               MOVE COBOL-OP TO OP-X
               IF FCD-STATUS-KEY-1 = '9'
                   DISPLAY "FILE ERROR, STATUS: 9/" FCD-BINARY
                           " OPCODE: " OP-N
               ELSE
                   DISPLAY "FILE ERROR, STATUS: " FCD-FILE-STATUS
                           " OPCODE: " OP-N
               END-IF
               IF FCD-FILE-STATUS = '23'
                   DISPLAY "Record: " RECORD-AREA "."
               END-IF
               STOP RUN
           END-IF.
      *
      *--------------------------------*
       2000-Read-Record.
      *--------------------------------*
      *
           INITIALIZE RECORD-AREA.

           MOVE 'RECORD-3'           TO PRIME-KEY.

           MOVE READ-RANDOM-LOCK     TO COBOL-OP.
           SET FCD-RECORD-ADDRESS    TO ADDRESS OF RECORD-AREA.
           PERFORM 1100-CALL-EXTFH.
      *
      *--------------------------------*
       3000-Rewrite-Record.
      *--------------------------------*
      *
           MOVE COBOL-TYPE     TO ACTION-TYPE.
           MOVE REWRITE-RECORD TO COBOL-OP.

           PERFORM 1100-CALL-EXTFH.
      *
      *--------------------------------*
       5000-Close-File.
      *--------------------------------*
      *
           MOVE COBOL-TYPE     TO ACTION-TYPE.
           MOVE CLOSE-FILE     TO COBOL-OP.

           PERFORM 1100-CALL-EXTFH.
      *
      *--------------------------------*
       6000-Start.
      *--------------------------------*
      *
           SET FCD-RECORD-ADDRESS     TO ADDRESS OF RECORD-AREA.
           MOVE 25                    TO FCD-KEY-LENGTH.
           MOVE HIGH-VALUES           TO PRIME-KEY.

           MOVE COBOL-TYPE            TO ACTION-TYPE.
           MOVE START-LESS            TO COBOL-OP.

           PERFORM 1100-CALL-EXTFH.
      *
      *--------------------------------*
       7000-Read-Previous.
      *--------------------------------*
      *
           MOVE COBOL-TYPE     TO ACTION-TYPE.
           MOVE READ-PREVIOUS  TO COBOL-OP.
           INITIALIZE RECORD-AREA2.
           SET FCD-RECORD-ADDRESS     TO ADDRESS OF RECORD-AREA2.

           PERFORM 1100-CALL-EXTFH.
])

# FIXME: by default comp-x should not be truncated (see trunk)
AT_CHECK([$COMPILE -fnotrunc progl.cob], [0], [], [])
AT_CHECK([$COMPILE -fnotrunc prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./progl], [0],
[5 records written
], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[AFTER READ ------> RECORD-3                           .
AFTER WRITE -----> RECORD-3                 1234567890.
AFTER READ PREV -> RECORD-5                           .
], [])

AT_CLEANUP


AT_SETUP([EXTFH: INDEXED with multiple keys])
AT_KEYWORDS([runfile EXTFH])

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
       DATA DIVISION.
       FILE SECTION.
       WORKING-STORAGE SECTION.
       77  CKEYS                           PIC 9(04) COMP-5.
       77  NKEYS                           PIC 9(04) COMP-5.
       77  CURR-OFF                        PIC 9(04) COMP-5.
       77  I                               PIC 9(04) COMP-5.
       01  FH-ACTION                       PIC X(02).
       01  FILLER REDEFINES FH-ACTION.
           05            PIC X COMP-X.
           05 FH-ACTION2 PIC X COMP-X.
       77  FILE-NAME                       PIC X(64).
       77  INDEX-NAME                      PIC X(64).
       77  FILE-NAME-LEN                   PIC 9(04) COMP-X.
       01  ACB-KEY-GROUP.
           05  ACB-CNT          PIC 9(02).
           05  ACB-KEY-TABLE OCCURS 32 TIMES.
               10  ACB-KEY-LEN  PIC 9(04) COMP-4.
               10  ACB-KEY-POS  PIC 9(04) COMP-4.
               10  ACB-KEY-DUPE PIC 9(02) COMP-X.
      *COPY EXTFHOPS.
       01  ACTION-CODE.
           05  ACTION-TYPE    PIC X(01).
               78  COBOL-TYPE                  VALUE X'FA'.
               78  SPECIAL-TYPE                VALUE X'00'.
           05  COBOL-OP       PIC X(01).
               78  OPEN-INPUT                  VALUE X'00'.
               78  OPEN-OUTPUT                 VALUE X'01'.
               78  OPEN-I-O                    VALUE X'02'.
               78  OPEN-EXTEND                 VALUE X'03'.
               78  OPEN-INPUT-NO-REWIND        VALUE X'04'.
               78  OPEN-OUTPUT-NO-REWIND       VALUE X'05'.
               78  OPEN-INPUT-REVERSED         VALUE X'08'.
               78  CLOSE-FILE                  VALUE X'80'.
               78  CLOSE-LOCK                  VALUE X'81'.
               78  CLOSE-NO-REWIND             VALUE X'82'.
               78  CLOSE-REEL-UNIT             VALUE X'84'.
               78  CLOSE-REEL-UNIT-FOR-REMOVAL VALUE X'85'.
               78  CLOSE-REEL-UNIT-NO-REWIND   VALUE X'86'.
               78  READ-SEQ-NO-LOCK            VALUE X'8D'.
               78  READ-SEQ-LOCK               VALUE X'D8'.
               78  READ-SEQ-KEPT-LOCK          VALUE X'D9'.
               78  READ-SEQ                    VALUE X'F5'.
               78  READ-PREVIOUS-NO-LOCK       VALUE X'8C'.
               78  READ-PREVIOUS-LOCK          VALUE X'DE'.
               78  READ-PREVIOUS-KEPT-LOCK     VALUE X'DF'.
               78  READ-PREVIOUS               VALUE X'F9'.
               78  READ-RANDOM-NO-LOCK         VALUE X'8E'.
               78  READ-RANDOM-LOCK            VALUE X'DA'.
               78  READ-RANDOM-KEPT-LOCK       VALUE X'DB'.
               78  READ-RANDOM                 VALUE X'F6'.
               78  READ-DIRECT-NO-LOCK         VALUE X'8F'.
               78  READ-DIRECT-LOCK            VALUE X'D6'.
               78  READ-DIRECT-KEPT-LOCK       VALUE X'D7'.
               78  READ-DIRECT                 VALUE X'C9'.
               78  READ-POSITION               VALUE X'F1'.
               78  WRITE-BEFORE                VALUE X'E1'.
               78  WRITE-AFTER                 VALUE X'E2'.
               78  WRITE-BEFORE-TAB            VALUE X'E3'.
               78  WRITE-AFTER-TAB             VALUE X'E4'.
               78  WRITE-BEFORE-PAGE           VALUE X'E5'.
               78  WRITE-AFTER-PAGE            VALUE X'E6'.
               78  WRITE-RECORD                VALUE X'F3'.
               78  REWRITE-RECORD              VALUE X'F4'.
               78  START-EQUAL-PRIME-KEY       VALUE X'E8'.
               78  START-EQUAL-KEY             VALUE X'E9'.
               78  START-GREATER               VALUE X'EA'.
               78  START-NOT-LESS              VALUE X'EB'.
               78  START-LESS                  VALUE X'FE'.
               78  START-LESS-OR-EQUAL         VALUE X'FF'.
               78  STEP-NEXT-NO-LOCK           VALUE X'90'.
               78  STEP-NEXT-LOCK              VALUE X'D4'.
               78  STEP-NEXT-KEPT-LOCK         VALUE X'D5'.
               78  STEP-NEXT                   VALUE X'CA'.
               78  STEP-FIRST-NO-LOCK          VALUE X'92'.
               78  STEP-FIRST-LOCK             VALUE X'D0'.
               78  STEP-FIRST-KEPT-LOCK        VALUE X'D1'.
               78  STEP-FIRST                  VALUE X'CC'.
               78  DELETE-RECORD               VALUE X'F7'.
               78  DELETE-FILE                 VALUE X'F8'.
               78  UNLOCK-CURRENT              VALUE X'0E'.
               78  COMMIT-ALL                  VALUE X'DC'.
               78  ROLLBACK-ALL                VALUE X'DD'.
               78  GET-FILE-INFO               VALUE X'06'.
               78  OPEN-NEW-INDEX              VALUE X'07'.
               78  GET-NEXT-RECORD             VALUE X'08'.
               78  ADD-KEY-VALUE               VALUE X'09'.
               78  UNLOCK-RECORD               VALUE X'0F'.
       01  FCD-AREA.
           COPY xfhfcd.

       01  RECORD-AREA.
           05  PRIME-KEY                   PIC X(20).
           05  DATA-AREA1                  PIC 9(10).
           05  DATA-AREA2                  PIC 9(15).
           05  DATA-AREA                   PIC X(355).
       01  KEY-DEF-AREA PIC X(512).
       PROCEDURE DIVISION.
       A-000-MAIN.
           PERFORM A-100-OPEN-FILE.
           PERFORM A-300-READ-RECORD.
           DISPLAY 'READ ------> ' RECORD-AREA (1:55) '.'
           MOVE '1234567890' TO RECORD-AREA (46:10)
           PERFORM A-400-REWRITE-RECORD.
           PERFORM A-300-READ-RECORD.
           DISPLAY 'WRITE -----> ' RECORD-AREA (1:55) '.'
           MOVE SPACES TO DATA-AREA.
           PERFORM A-400-REWRITE-RECORD.
           PERFORM A-700-START.
           PERFORM A-800-READ-PREVIOUS.
           DISPLAY 'READ PREV -> ' RECORD-AREA (1:55) '.'
           PERFORM A-600-CLOSE-FILE.
           STOP RUN.
       A-100-Open-File.
           MOVE LOW-VALUES TO FCD-AREA
           MOVE LOW-VALUES TO ACB-KEY-GROUP
           MOVE fcd--version-number TO FCD-VERSION
      ** MAKE 3 KEYS
           MOVE 3 TO ACB-CNT
           MOVE 0 TO ACB-KEY-POS (1)
           MOVE 20 TO ACB-KEY-LEN (1)
           MOVE 0 TO ACB-KEY-DUPE (1)
           MOVE 20 TO ACB-KEY-POS (2)
           MOVE 10 TO ACB-KEY-LEN (2)
           MOVE 1 TO ACB-KEY-DUPE (2)
           MOVE 30 TO ACB-KEY-POS (3)
           MOVE 15 TO ACB-KEY-LEN (3)
           MOVE 1 TO ACB-KEY-DUPE (3)
      ** MAKE MF KEY-DEF
           CALL "EXFHKEYS" USING
                         ACB-KEY-GROUP
                         KEY-DEF-AREA
           MOVE X'FA01' TO FH-ACTION
           SET FCD-KEY-DEF-ADDRESS TO ADDRESS OF KEY-DEF-AREA
           MOVE 'TESTISAM2' TO FILE-NAME
           MOVE 9 TO FILE-NAME-LEN
           MOVE FILE-NAME-LEN TO FCD-NAME-LENGTH
           MOVE 0 TO FCD-ACCESS-MODE
           MOVE 2 TO FCD-ORGANIZATION
           MOVE 128 TO FCD-OPEN-MODE
      **   FIXED OR VARIABLE
           MOVE 1 TO FCD-RECORDING-MODE
           MOVE 0 TO FCD-RECORDING-MODE
           SET FCD-FILENAME-ADDRESS TO ADDRESS OF FILE-NAME
           MOVE 400 TO FCD-MIN-REC-LENGTH
           MOVE 400 TO FCD-MAX-REC-LENGTH
           PERFORM A-200-CALL-EXTFH.
           PERFORM A-600-CLOSE-FILE.
      * Write test data to file
           MOVE X'FA02' TO FH-ACTION
           MOVE 8 TO FCD-ACCESS-MODE
           PERFORM A-200-CALL-EXTFH.
           MOVE SPACES    TO RECORD-AREA
           MOVE 0 TO DATA-AREA1
           MOVE 0 TO DATA-AREA2
           PERFORM 7 TIMES
               ADD 1  TO DATA-AREA1
               ADD 1  TO DATA-AREA2
               MOVE 'RECORD-1'           TO PRIME-KEY
               MOVE DATA-AREA1 (10:1)    TO PRIME-KEY (8:1)
               MOVE X'FAF3'              TO FH-ACTION
               SET FCD-RECORD-ADDRESS    TO ADDRESS OF RECORD-AREA
               PERFORM A-200-CALL-EXTFH
           END-PERFORM.
       A-110-EXIT.
           EXIT.
       A-200-Call-Extfh.
           CALL 'EXTFH' USING FH-ACTION
                              FCD-AREA
           IF FCD-FILE-STATUS NOT = '00' AND NOT = '02'
               IF FCD-STATUS-KEY-1 = '9'
                   DISPLAY "Operation: " FH-ACTION2
                           " FILE ERROR, STATUS: 9/" FCD-BINARY
               ELSE
                   DISPLAY "Operation: " FH-ACTION2
                           " FILE ERROR, STATUS: " FCD-FILE-STATUS
               END-IF
               STOP RUN
           END-IF.
       A-300-READ-RECORD.
           INITIALIZE RECORD-AREA.
           MOVE 'RECORD-3'           TO PRIME-KEY.
           MOVE X'FA8E' TO FH-ACTION
           SET FCD-RECORD-ADDRESS    TO ADDRESS OF RECORD-AREA.
           PERFORM A-200-CALL-EXTFH.
       A-400-REWRITE-RECORD.
           MOVE X'FAF4' TO FH-ACTION
           MOVE REWRITE-RECORD TO COBOL-OP.
           PERFORM A-200-CALL-EXTFH.
       A-600-CLOSE-FILE.
           MOVE X'FA80' TO FH-ACTION.
           PERFORM A-200-CALL-EXTFH.
       A-700-START.
           SET FCD-RECORD-ADDRESS     TO ADDRESS OF RECORD-AREA.
           MOVE 20                    TO FCD-KEY-LENGTH.
           MOVE HIGH-VALUES           TO PRIME-KEY.
           MOVE X'FAFE' TO FH-ACTION
           PERFORM A-200-CALL-EXTFH.
       A-800-READ-PREVIOUS.
           MOVE X'FAF9' TO FH-ACTION
           PERFORM A-200-CALL-EXTFH.

])

AT_DATA([progs.cob], [[
      $SET ODOSLIDE
      **  CREATE KEY-DEF-AREA FROM ACB ARRAY
       IDENTIFICATION DIVISION.
       PROGRAM-ID. EXFHKEYS.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       77  ZX1           PIC X(04).
       77  ZX2           PIC X(04).
       77  ZX4           PIC X(08).
       77  Z91           PIC 9(04) COMP-5.
       77  Z92           PIC 9(04) COMP-5.
       77  Z93           PIC 9(08) COMP-5.
       77  Z94           PIC 9(08) COMP-5.
       77  E4            PIC X(08) VALUE 'E4'.
       77  E6            PIC X(08) VALUE 'E6'.
       77  OFF1          PIC X(4)    COMP-X.
       77  OFF2          PIC X(2)    COMP-X.
       01  PROGRAM-DATA.
           05  I                         PIC 9(4) COMP.
           05  J                         PIC 9(4) COMP.
           05  K                         PIC 9(4) COMP.
           05  L                         PIC 9(4) COMP.
           05  X                         PIC 9(4) COMP.
           05  Y                         PIC 9(4) COMP.
           05  Z                         PIC 9(4) COMP.
       01  KEY-DEF-AREA.
           05  GLOBAL-INFORMATION-AREA.
               10  KEY-DEF-LEN             PIC 9(04) COMP-X.
               10  FILLER                  PIC X(04).
               10  NUMBER-OF-KEYS          PIC 9(04) COMP-X.
               10  FILLER                  PIC X(06).
           05  KEY-DEFINITION-PARAMETER-BLOCK
            OCCURS 1 TO 15 TIMES DEPENDING ON NUMBER-OF-KEYS.
               10 COMPONENT-COUNT     PIC 9(4) COMP-X.
               10 OFFSET-TO-COMPONENT PIC 9(4) COMP-X.
               10 KEY-FLAGS           PIC 9(2) COMP-X.
               10 KEY-COMPRESSION     PIC 9(2) COMP-X.
               10 SPARSE-CHARACTER    PIC X.
               10 FILLER              PIC X(9).
           05  COMPONENT-DEFINITION-AREA
             OCCURS 1 TO 15 TIMES DEPENDING ON NUMBER-OF-KEYS.
               10 FILLER                  PIC X(2).
               10 OFFSET-TO-COMPONENT-DEF PIC 9(9) COMP-X.
               10 COMPONENT-LENGTH        PIC 9(9) COMP-X.
       LINKAGE SECTION.
       01  ACB-KEY-GROUP.
           05  ACB-CNT           PIC 9(02).
           05  ACB-KEY-TABLE OCCURS 32 TIMES.
               10  ACB-KEY-LEN   PIC 9(04) COMP-4.
               10  ACB-KEY-LENX REDEFINES ACB-KEY-LEN  PIC X(02).
               10  ACB-KEY-POS   PIC 9(04) COMP-4.
               10  ACB-KEY-POSX REDEFINES ACB-KEY-POS  PIC X(02).
               10  ACB-KEY-DUP PIC 9(02) COMP-X.
               10  ACB-KEY-DUPX REDEFINES ACB-KEY-DUP PIC X(01).
       01 KEY-DEFS PIC X(512).
       PROCEDURE DIVISION USING
                          ACB-KEY-GROUP
                          KEY-DEFS.
       A-010-MAINLINE.
           MOVE LOW-VALUES TO KEY-DEFS
           MOVE LOW-VALUES TO KEY-DEF-AREA
      ** POPULATE THE GLOBAL AREA
           MOVE ACB-CNT TO NUMBER-OF-KEYS
           COMPUTE KEY-DEF-LEN  = (ACB-CNT * 16) + (ACB-CNT * 10) + 14
      ** POPULATE KEY-DEFINITION-PARAMETER-BLOCK & COMPONENT DEFEINTION
           PERFORM A-020-MAKE-KEY-DEF THRU A-020-EXIT
           MOVE KEY-DEF-AREA (1:KEY-DEF-LEN) TO KEY-DEFS (1:KEY-DEF-LEN)
           GOBACK.
       A-010-EXIT.
           EXIT.
       A-020-MAKE-KEY-DEF.
      ** DO THE PRIMARY KEY
           MOVE 1 TO I
           MOVE 1 TO COMPONENT-COUNT (I)
           MOVE 16 TO KEY-FLAGS (I)
           COMPUTE OFF2 = (ACB-CNT * 16) + ((I - 1) * 10) + 14
           MOVE OFF2 TO OFFSET-TO-COMPONENT (I)
           MOVE ACB-KEY-POS (I) TO OFFSET-TO-COMPONENT-DEF (I)
           MOVE 10 TO COMPONENT-LENGTH (I)
      ** IF THERE ARE NO ALTERNATE KEYS EXIT - KEY DEF IS BUILT
           IF ACB-CNT < 2
               GO TO A-020-EXIT
           END-IF
      ** DO ALTERNATE INDEX(S)
           PERFORM VARYING I FROM 2 BY 1 UNTIL I > ACB-CNT
               MOVE 1 TO COMPONENT-COUNT (I)
               COMPUTE OFF2 = (ACB-CNT * 16) + ((I - 1) * 10) + 14
               MOVE OFF2 TO OFFSET-TO-COMPONENT (I)
               IF ACB-KEY-DUP (I) = 1
                   MOVE 64 TO KEY-FLAGS (I)
               ELSE
                   MOVE 16 TO KEY-FLAGS (I)
                   MOVE 0 TO KEY-FLAGS (I)
               END-IF
               MOVE ACB-KEY-POS (I) TO OFFSET-TO-COMPONENT-DEF (I)
               MOVE ACB-KEY-LEN (I) TO COMPONENT-LENGTH (I)
           END-PERFORM.
       A-020-EXIT.
           EXIT.
]])

# FIXME: by default comp-x should not be truncated (see trunk)
AT_CHECK([$COMPILE -fnotrunc -fodoslide prog.cob progs.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[READ ------> RECORD-3            0000000003000000000000003          .
WRITE -----> RECORD-3            00000000030000000000000031234567890.
READ PREV -> RECORD-7            0000000007000000000000007          .
], [])

AT_CLEANUP


AT_SETUP([EXTFH: RELATIVE files])
AT_KEYWORDS([EXTFH])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       INPUT-OUTPUT SECTION.
       DATA DIVISION.
       FILE SECTION.
       WORKING-STORAGE SECTION.
       77  I                               PIC 9(04) COMP-5.
       77  FILE-NAME                       PIC X(64).
       77  FILE-NAME-LEN                   PIC 9(04) COMP-X.
       01  FH-ACTION                       PIC X(02).
       01  FILLER REDEFINES FH-ACTION.
           05            PIC X COMP-X.
           05 FH-ACTION2 PIC X COMP-X.
       01  ACTION-CODE REDEFINES FH-ACTION.
           05  ACTION-TYPE    PIC X(01).
               78  COBOL-TYPE                  VALUE X'FA'.
               78  SPECIAL-TYPE                VALUE X'00'.
           05  COBOL-OP       PIC X(01).
               78  OPEN-INPUT                  VALUE X'00'.
               78  OPEN-OUTPUT                 VALUE X'01'.
               78  OPEN-I-O                    VALUE X'02'.
               78  OPEN-EXTEND                 VALUE X'03'.
               78  OPEN-INPUT-NO-REWIND        VALUE X'04'.
               78  OPEN-OUTPUT-NO-REWIND       VALUE X'05'.
               78  OPEN-INPUT-REVERSED         VALUE X'08'.
               78  CLOSE-FILE                  VALUE X'80'.
               78  CLOSE-LOCK                  VALUE X'81'.
               78  CLOSE-NO-REWIND             VALUE X'82'.
               78  CLOSE-REEL-UNIT             VALUE X'84'.
               78  CLOSE-REEL-UNIT-FOR-REMOVAL VALUE X'85'.
               78  CLOSE-REEL-UNIT-NO-REWIND   VALUE X'86'.
               78  READ-SEQ-NO-LOCK            VALUE X'8D'.
               78  READ-SEQ-LOCK               VALUE X'D8'.
               78  READ-SEQ-KEPT-LOCK          VALUE X'D9'.
               78  READ-SEQ                    VALUE X'F5'.
               78  READ-PREVIOUS-NO-LOCK       VALUE X'8C'.
               78  READ-PREVIOUS-LOCK          VALUE X'DE'.
               78  READ-PREVIOUS-KEPT-LOCK     VALUE X'DF'.
               78  READ-PREVIOUS               VALUE X'F9'.
               78  READ-RANDOM-NO-LOCK         VALUE X'8E'.
               78  READ-RANDOM-LOCK            VALUE X'DA'.
               78  READ-RANDOM-KEPT-LOCK       VALUE X'DB'.
               78  READ-RANDOM                 VALUE X'F6'.
               78  READ-DIRECT-NO-LOCK         VALUE X'8F'.
               78  READ-DIRECT-LOCK            VALUE X'D6'.
               78  READ-DIRECT-KEPT-LOCK       VALUE X'D7'.
               78  READ-DIRECT                 VALUE X'C9'.
               78  READ-POSITION               VALUE X'F1'.
               78  WRITE-BEFORE                VALUE X'E1'.
               78  WRITE-AFTER                 VALUE X'E2'.
               78  WRITE-BEFORE-TAB            VALUE X'E3'.
               78  WRITE-AFTER-TAB             VALUE X'E4'.
               78  WRITE-BEFORE-PAGE           VALUE X'E5'.
               78  WRITE-AFTER-PAGE            VALUE X'E6'.
               78  WRITE-RECORD                VALUE X'F3'.
               78  REWRITE-RECORD              VALUE X'F4'.
               78  START-EQUAL-PRIME-KEY       VALUE X'E8'.
               78  START-EQUAL-KEY             VALUE X'E9'.
               78  START-GREATER               VALUE X'EA'.
               78  START-NOT-LESS              VALUE X'EB'.
               78  START-LESS                  VALUE X'FE'.
               78  START-LESS-OR-EQUAL         VALUE X'FF'.
               78  STEP-NEXT-NO-LOCK           VALUE X'90'.
               78  STEP-NEXT-LOCK              VALUE X'D4'.
               78  STEP-NEXT-KEPT-LOCK         VALUE X'D5'.
               78  STEP-NEXT                   VALUE X'CA'.
               78  STEP-FIRST-NO-LOCK          VALUE X'92'.
               78  STEP-FIRST-LOCK             VALUE X'D0'.
               78  STEP-FIRST-KEPT-LOCK        VALUE X'D1'.
               78  STEP-FIRST                  VALUE X'CC'.
               78  DELETE-RECORD               VALUE X'F7'.
               78  DELETE-FILE                 VALUE X'F8'.
               78  UNLOCK-CURRENT              VALUE X'0E'.
               78  COMMIT-ALL                  VALUE X'DC'.
               78  ROLLBACK-ALL                VALUE X'DD'.
               78  GET-FILE-INFO               VALUE X'06'.
               78  OPEN-NEW-INDEX              VALUE X'07'.
               78  GET-NEXT-RECORD             VALUE X'08'.
               78  ADD-KEY-VALUE               VALUE X'09'.
               78  UNLOCK-RECORD               VALUE X'0F'.

       01  FCD-AREA.
            COPY xfhfcd.

       01  RECORD-AREA.
           05  PRIME-KEY                   PIC X(20).
           05  DATA-AREA1                  PIC 9(10).
           05  RECORD-GROWTH               PIC X(50).

       PROCEDURE DIVISION.
       A-000-MAIN.
           MOVE X'FA01' TO FH-ACTION
           PERFORM A-100-OPEN-FILE.
           MOVE SPACES  TO RECORD-AREA
           MOVE 0 TO DATA-AREA1
           PERFORM 7 TIMES
               ADD 1  TO DATA-AREA1
               MOVE DATA-AREA1 TO FCD-RELATIVE-KEY
               MOVE 'RECORD-1'           TO PRIME-KEY
               MOVE DATA-AREA1 (10:1)    TO PRIME-KEY (8:1)
               MOVE X'FAF3'              TO FH-ACTION
               SET FCD-RECORD-ADDRESS    TO ADDRESS OF RECORD-AREA
               PERFORM A-200-CALL-EXTFH
           END-PERFORM.
           PERFORM A-600-CLOSE-FILE.

           MOVE X'FA02' TO FH-ACTION
           PERFORM A-100-OPEN-FILE.
           MOVE 3 TO FCD-RELATIVE-KEY
           PERFORM A-700-UPDATE.
           MOVE 6 TO FCD-RELATIVE-KEY
           PERFORM A-700-UPDATE.
           PERFORM A-600-CLOSE-FILE.
           STOP RUN.

       A-100-Open-File.
           MOVE LOW-VALUES TO FCD-AREA
           MOVE FCD--VERSION-NUMBER TO FCD-VERSION
           MOVE 'TESTREL.DAT' TO FILE-NAME
           MOVE 11 TO FILE-NAME-LEN
           MOVE FILE-NAME-LEN TO FCD-NAME-LENGTH
      **   ACCESS SEQ(0) RANDOM(4) DYNAMIC(8)
           MOVE 8 TO FCD-ACCESS-MODE
      **   ISAM(2) RELATIVE(3) LSEQ(0) SEQ(1)
           MOVE 3 TO FCD-ORGANIZATION
      **   CLOSED(128) INPUT(0) OUTPUT(1) I-O(2) EXTEND(3)
           MOVE 128 TO FCD-OPEN-MODE
      **   FIXED(0) OR VARIABLE(1)
           MOVE 0 TO FCD-RECORDING-MODE
           SET FCD-FILENAME-ADDRESS TO ADDRESS OF FILE-NAME
           MOVE LENGTH OF RECORD-AREA TO FCD-MIN-REC-LENGTH
           MOVE LENGTH OF RECORD-AREA TO FCD-MAX-REC-LENGTH
           MOVE LENGTH OF RECORD-AREA TO FCD-CURRENT-REC-LEN
           PERFORM A-200-CALL-EXTFH.

       A-200-Call-Extfh.
           CALL 'EXTFH' USING FH-ACTION
                              FCD-AREA
           IF FCD-FILE-STATUS NOT = '00' AND NOT = '02'
               IF FCD-STATUS-KEY-1 = '9'
                   DISPLAY "Operation: " FH-ACTION2
                           " FILE ERROR, STATUS: 9/" FCD-BINARY
               ELSE
                   DISPLAY "Operation: " FH-ACTION2
                           " FILE ERROR, STATUS: " FCD-FILE-STATUS
               END-IF
               STOP RUN
           END-IF.
       A-300-READ-RECORD.
           INITIALIZE RECORD-AREA.
           MOVE READ-RANDOM-LOCK     TO COBOL-OP.
           SET FCD-RECORD-ADDRESS    TO ADDRESS OF RECORD-AREA.
           PERFORM A-200-CALL-EXTFH.
           MOVE FCD-RELATIVE-KEY TO I.
       A-400-REWRITE-RECORD.
           MOVE COBOL-TYPE     TO ACTION-TYPE.
           MOVE REWRITE-RECORD TO COBOL-OP.
           PERFORM A-200-CALL-EXTFH.
       A-600-CLOSE-FILE.
           MOVE X'FA80' TO FH-ACTION.
           PERFORM A-200-CALL-EXTFH.
       A-700-UPDATE.
           PERFORM A-300-READ-RECORD.
           DISPLAY 'READ    ' I ': ' RECORD-AREA (1:41) '.'.
           MOVE '1234567890' TO RECORD-GROWTH.
           PERFORM A-400-REWRITE-RECORD.
           PERFORM A-300-READ-RECORD.
           DISPLAY 'REWRITE ' I ': ' RECORD-AREA (1:41) '.'.
])

# FIXME: by default comp-x should not be truncated (see trunk)
AT_CHECK([$COMPILE -fnotrunc prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[READ    00003: RECORD-3            0000000003           .
REWRITE 00003: RECORD-3            00000000031234567890 .
READ    00006: RECORD-6            0000000006           .
REWRITE 00006: RECORD-6            00000000061234567890 .
], [])

AT_CLEANUP


AT_SETUP([EXTFH: reading two files with one FCD])
AT_KEYWORDS([runfile EXTFH])

AT_DATA([prog.cob], [
       IDENTIFICATION          DIVISION.
      ****************************************************************
       PROGRAM-ID.             prog.
      *AUTHOR.                 TOKYO-SYSTEM-HOUSE.
      *DATE-WRITTEN.           2023/02/28.
      ****************************************************************
       ENVIRONMENT             DIVISION.
      ****************************************************************
       INPUT-OUTPUT            SECTION.
       FILE-CONTROL.
           SELECT  F-SEQ-FILE  ASSIGN          TO    "F-SEQ"
                               ORGANIZATION    IS    SEQUENTIAL
                               FILE STATUS     IS    F-SEQ-STATUS.
           SELECT  F-TXT-FILE  ASSIGN          TO    "F-TXT"
                               ORGANIZATION    IS    LINE SEQUENTIAL
                               FILE STATUS     IS    F-TXT-STATUS.
      ****************************************************************
       DATA                    DIVISION.
      ****************************************************************
       FILE                    SECTION.
       FD  F-SEQ-FILE.
       01  F-SEQ-RECORD.
         03  F-SEQ-DATA        PIC X(5).
       FD  F-TXT-FILE.
       01  F-TXT-RECORD.
         03  F-TXT-DATA        PIC X(10).
       WORKING-STORAGE         SECTION.
       01  F-SEQ-STATUS        PIC X(2).
       01  F-TXT-STATUS        PIC X(2).

       01  OPCODE              PIC X(2).
       78  OP-QUERY-FILE       VALUE X"0006".
       78  OP-OPEN-INPUT       VALUE X"fa00".
       78  OP-OPEN-OUTPUT      VALUE X"fa01".
       78  OP-OPEN-I-O         VALUE X"fa02".
       78  OP-WRITE            VALUE X"faf3".
       78  OP-RELEASE          VALUE X"faf3".
       78  OP-REWRITE          VALUE X"faf4".
       78  OP-READ-NEXT        VALUE X"faf5".
       78  OP-START-EQUAL      VALUE X"fae9".
       78  OP-CLOSE            VALUE X"fa80".

       01  FCD.
           COPY "xfhfcd3.cpy".
       01  EX-FILENAME         PIC X(260).
       01  EX-RECORD-BUFFER    PIC X(32767).
      ****************************************************************
       PROCEDURE               DIVISION.
      ****************************************************************
       MAIN-RTN.
      *    CREATE FILE
           OPEN OUTPUT F-SEQ-FILE.
           MOVE "SEQ01" TO F-SEQ-DATA.
           WRITE F-SEQ-RECORD.
           MOVE "SEQ02" TO F-SEQ-DATA.
           WRITE F-SEQ-RECORD.
           MOVE "SEQ03" TO F-SEQ-DATA.
           WRITE F-SEQ-RECORD.
           MOVE "SEQ04" TO F-SEQ-DATA.
           WRITE F-SEQ-RECORD.
           MOVE "SEQ05" TO F-SEQ-DATA.
           WRITE F-SEQ-RECORD.
           CLOSE F-SEQ-FILE.
           OPEN OUTPUT F-TXT-FILE.
           MOVE "TXTA123456" TO F-TXT-DATA.
           WRITE F-TXT-RECORD.
           MOVE "TXTB123456" TO F-TXT-DATA.
           WRITE F-TXT-RECORD.
           MOVE "TXTC123456" TO F-TXT-DATA.
           WRITE F-TXT-RECORD.
           MOVE "TXTD123456" TO F-TXT-DATA.
           WRITE F-TXT-RECORD.
           CLOSE F-TXT-FILE.

      *    SET FCD
           MOVE LOW-VALUES TO FCD.
           MOVE FCD--VERSION-NUMBER   TO FCD-VERSION.
           SET  FCD-FILENAME-ADDRESS  TO ADDRESS OF EX-FILENAME.
           MOVE 80                    TO FCD-NAME-LENGTH.
           SET FCD-RECORD-ADDRESS     TO ADDRESS OF EX-RECORD-BUFFER.

      *    OPEN first file
           MOVE fcd--sequential-org   TO FCD-ORGANIZATION.
           MOVE "F-SEQ"               TO EX-FILENAME.
           MOVE OP-OPEN-INPUT         TO OPCODE.
           MOVE FCD--DYNAMIC-ACCESS   TO FCD-ACCESS-MODE.
           MOVE 5                     TO FCD-CURRENT-REC-LEN.
           MOVE 5                     TO FCD-MIN-REC-LENGTH.
           MOVE 5                     TO FCD-MAX-REC-LENGTH.
           CALL "EXTFH" USING OPCODE, FCD.
           DISPLAY "OPEN STATUS:"  
                                      FCD-STATUS-KEY-1 "/" FCD-BINARY.

      *    READ RECORD
           MOVE OP-READ-NEXT          TO OPCODE.
           MOVE "00" TO FCD-FILE-STATUS.
           PERFORM UNTIL FCD-STATUS-KEY-1 NOT = "0"
               MOVE SPACE                 TO EX-RECORD-BUFFER
               CALL "EXTFH" USING OPCODE, FCD
               DISPLAY "READ NEXT STATUS:"
                                      FCD-STATUS-KEY-1 "/" FCD-BINARY
               DISPLAY "DATA:" EX-RECORD-BUFFER(1:10) '-'
           END-PERFORM.

      *    CLOSE FILE
           MOVE OP-CLOSE              TO OPCODE.
           CALL "EXTFH" USING OPCODE, FCD.
           DISPLAY "CLOSE STATUS:"  
                                      FCD-STATUS-KEY-1 "/" FCD-BINARY.

      *    OPEN second file
           MOVE fcd--line-sequential-org   TO FCD-ORGANIZATION.
           MOVE "F-TXT"               TO EX-FILENAME.
           MOVE OP-OPEN-INPUT         TO OPCODE.
           MOVE FCD--DYNAMIC-ACCESS   TO FCD-ACCESS-MODE.
           MOVE 10                    TO FCD-CURRENT-REC-LEN.
           MOVE 10                    TO FCD-MIN-REC-LENGTH.
           MOVE 10                    TO FCD-MAX-REC-LENGTH.
           CALL "EXTFH" USING OPCODE, FCD.
           DISPLAY "OPEN STATUS:"  
                                      FCD-STATUS-KEY-1 "/" FCD-BINARY.

      *    READ RECORD
           MOVE OP-READ-NEXT          TO OPCODE.
           MOVE "00" TO FCD-FILE-STATUS.
           PERFORM UNTIL FCD-STATUS-KEY-1 NOT = "0"
               MOVE SPACE                 TO EX-RECORD-BUFFER
               CALL "EXTFH" USING OPCODE, FCD
               DISPLAY "READ NEXT STATUS:"
                                      FCD-STATUS-KEY-1 "/" FCD-BINARY
               DISPLAY "DATA:" EX-RECORD-BUFFER(1:10) '-'
           END-PERFORM.

      *    CLOSE FILE
           MOVE OP-CLOSE              TO OPCODE.
           CALL "EXTFH" USING OPCODE, FCD.
           DISPLAY "CLOSE STATUS:"  
                                      FCD-STATUS-KEY-1 "/" FCD-BINARY.

       MAIN-EXT.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[OPEN STATUS:0/48
READ NEXT STATUS:0/48
DATA:SEQ01     -
READ NEXT STATUS:0/48
DATA:SEQ02     -
READ NEXT STATUS:0/48
DATA:SEQ03     -
READ NEXT STATUS:0/48
DATA:SEQ04     -
READ NEXT STATUS:0/48
DATA:SEQ05     -
READ NEXT STATUS:1/48
DATA:          -
CLOSE STATUS:0/48
OPEN STATUS:0/48
READ NEXT STATUS:0/48
DATA:TXTA123456-
READ NEXT STATUS:0/48
DATA:TXTB123456-
READ NEXT STATUS:0/48
DATA:TXTC123456-
READ NEXT STATUS:0/48
DATA:TXTD123456-
READ NEXT STATUS:1/48
DATA:          -
CLOSE STATUS:0/48
], [])

AT_CLEANUP


AT_SETUP([EXTFH: auto-conversion FCD2 <-> FCD3 on 32bit])

# FIXME: check for missing record / file pointer address should be
#        moved to general EXTFH test

AT_SKIP_IF([test "$COB_HAS_64_BIT_POINTER" = "yes"])
AT_KEYWORDS([runfile EXTFH])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
       DATA DIVISION.
       FILE SECTION.
       WORKING-STORAGE SECTION.

       01  I                       PIC XX COMP-X.

       01  WS-FCD-DDNAME           PIC X(10) VALUE SPACES.
       01  WS-FCD-PTR              POINTER   VALUE NULL.

       01  WS-FCD-SIZE             PIC 9(04) VALUE   0       COMP-5.
       01  WS-FCD-FLAGS            PIC 9(04) VALUE   0       COMP-5.

       01  DISPLAY-BYTE.
          05  DISPLAY-XXX             PIC X(03).
          05  DISPLAY-ZZ9             REDEFINES DISPLAY-XXX
                                      PIC ZZ9.
       01  ACTION-CODE                 pic x(2).
          78  OP-OPEN-INPUT           value x"fa00".
          78  OP-OPEN-OUTPUT          value x"fa01".
          78  OP-OPEN-I-O             value x"fa02".
          78  OP-WRITE                value x"faf3".
          78  OP-RELEASE              value x"faf3".
          78  OP-REWRITE              value x"faf4".
          78  OP-READ-NEXT            value x"faf5".
          78  OP-START-EQUAL          value x"fae9".
          78  OP-CLOSE                value x"fa80".
          78  OP-QUERY-FILE           value x"0006".

       01  DISPLAY-A1-XXX              PIC X(03).
       01  DISPLAY-A1-ZZ9              REDEFINES DISPLAY-A1-XXX
                                      PIC ZZ9.
       01  DISPLAY-A2-XXX              PIC X(03).
       01  DISPLAY-A2-ZZ9              REDEFINES DISPLAY-A2-XXX
                                       PIC ZZ9.

       01  FCD-FILENAME               PIC X(80) value "test.out".
       01  FCD-RECORD                 PIC X(512) value spaces.

       LINKAGE SECTION.

       01  FCD-MAP.
      *********************************************
      * FCD2 definition for Callable File Handler *
      *********************************************
           05  FCD-FILE-STATUS.
               10  FCD-STATUS-KEY-1 PIC X.
               10  FCD-STATUS-KEY-2 PIC X.
               10  FCD-BINARY       REDEFINES FCD-STATUS-KEY-2
                                    PIC X COMP-X.
           05  FCD-LENGTH            PIC XX COMP-X.
           05  FCD-VERSION           PIC X COMP-X.
              78 FCD-VERSION-NUMBER           VALUE 0.

           05  FCD-ORGANIZATION     PIC 9(2) COMP-X.
             78 fcd--line-sequential-org      value 0.
             78 fcd--sequential-org           value 1.
             78 fcd--indexed-org              value 2.
             78 fcd--relative-org             value 3.
             78 fcd--determine-org            value 255. *> see opcode 0006
           05  FCD-ACCESS-MODE      PIC 9(2) COMP-X.
             78 fcd--sequential-access        value 0.
             78 fcd--dup-prime-access         value 1.
             78 fcd--random-access            value 4.
             78 fcd--dynamic-access           value 8.
             78 fcd--status-defined           value h"80".
           05  FCD-OPEN-MODE        PIC 9(2) COMP-X.
             78 fcd--open-input               value 0.
             78 fcd--open-output              value 1.
             78 fcd--open-i-o                 value 2.
             78 fcd--open-extend              value 3.
             78 fcd--open-max                 value 3.
             78 fcd--open-closed              value 128.
           05  FILLER               PIC X(2).
           05  FCD-BLOCK-SIZE       PIC 9(2) COMP-X.
           05  FCD-NAME-LENGTH      PIC 9(4) COMP-X.
           05  FCD-RELADDR-BIG      PIC X(8) COMP-X.
           05  FILLER               PIC X.
           05  FCD-TRANS-LOG        PIC 9(2) COMP-X.
           05  FILLER               PIC X(1).
           05  FCD-LOCK-MODE        PIC 9(2) COMP-X.
             78 fcd--multilock-bit            value h"80".
             78 fcd--writelock-bit            value h"40".
             78 fcd--retry-open-bit           value h"20".
             78 fcd--skip-lock-bit            value h"10".
             78 fcd--retry-lock-bit           value h"08".
             78 fcd--manual-lock-bit          value h"04".
             78 fcd--auto-lock-bit            value h"02".
             78 fcd--exclusive-bit            value h"01".
             78 fcd--sharing-bits
             value fcd--manual-lock-bit + fcd--auto-lock-bit.
           05  FCD-OTHER-FLAGS      PIC 9(2) COMP-X.
             78 fcd--optional-file            value h"80".
             78 fcd--nodetectlock-input       value h"40".
             78 fcd--not-optional             value h"20".
             78 fcd--external-name            value h"10".
             78 fcd--get-info                 value h"08".
             78 fcd--nodetectlock             value h"04".
             78 fcd--multiple-reel            value h"02".
             78 fcd--line-advancing           value h"01".
             78 fcd--special-sequential
             value fcd--optional-file
             + fcd--multiple-reel + fcd--line-advancing.
           05  FILLER               PIC X(2).
           05  FCD-HANDLE           USAGE POINTER.
           05  FCD-PERCENT          PIC 9(2) COMP-X.
           05  FCD-REC-COUNT-SET    REDEFINES FCD-PERCENT
                                    PIC 9(2) COMP-X.
           05  FCD-STATUS-TYPE      PIC 9(2) COMP-X.
           05  FCD-FILE-FORMAT      PIC 9(2) COMP-X.
           05  FILLER               PIC X(3).
           05  FCD-MAX-REC-LENGTH   PIC XX   COMP-X.
           05  FILLER               PIC X(2).
           05  FCD-MVS-FLAGS        PIC 9(2) COMP-X.
           05  FCD-RELATIVE-KEY     PIC 9(9) COMP-X.
           05  FCD-RECORDING-MODE   PIC 9(2) COMP-X.
               78 fcd--recmode-fixed            value 0.
               78 fcd--recmode-variable         value 1.
           05  FCD-CURRENT-REC-LEN  PIC XX   COMP-X.
           05  FCD-MIN-REC-LENGTH   PIC XX   COMP-X.
           05  FCD-KEY-ID           PIC 9(4) COMP-X.
           05  FCD-LINE-COUNT       REDEFINES FCD-KEY-ID
                                    PIC 9(4) COMP-X.
           05                       REDEFINES FCD-KEY-ID.
               10  FCD-USE-FILES    PIC X COMP-X.
               10  FCD-GIVE-FILES   PIC X COMP-X.
           05  FCD-KEY-LENGTH       PIC 9(4) COMP-X.
           05  FCD-RECORD-ADDRESS   USAGE POINTER.
           05  FCD-FILENAME-ADDRESS USAGE POINTER.
           05  FCD-KEY-DEF-ADDRESS  USAGE POINTER.
           05  FCD-COL-SEQ-ADDRESS  USAGE POINTER.
           05  FCD-RELADDR-OFFSET   PIC 9(9) COMP-X.
           05  FCD-RELADDR          REDEFINES FCD-RELADDR-OFFSET
                                    PIC 9(9) COMP-X.
           05  FCD-FILDEF-ADDRESS   REDEFINES FCD-RELADDR-OFFSET
                                    USAGE POINTER.
           05  FCD-NLS-ID           PIC 9(4) COMP-X.
           05  FCD-DATA-COMPRESS    PIC 9(2) COMP-X.
           05  FCD-SESSION-ID       PIC 9(9) COMP-X.
           05  FCD-FS-FILE-ID       PIC 9(4) COMP-X.
           05  FCD-MAX-REL-KEY      PIC 9(9) COMP-X.
           05  FCD-FLAGS-1          PIC 99   COMP-X.
           05  FCD-BLOCKING         PIC 99   COMP-X.
           05  FCD-ADDITIONAL-STATUS REDEFINES FCD-BLOCKING
                                    PIC X    COMP-X.
           05  FCD-LOCKTYPES        PIC 99   COMP-X.
             78 fcd--interlang-locking        value h"80".
             78 fcd--allow-readers            value h"40".
             78 fcd--separate-lock-file       value h"20".
             78 fcd--single-open              value h"10".
             78 fcd--nfs-file-lock            value h"08".
             78 fcd--nfs-file-lock-hp         value h"04".
             78 fcd--nfs-file-locks
             value fcd--nfs-file-lock + fcd--nfs-file-lock-hp.
           05  FCD-FS-FLAGS         PIC 99   COMP-X.
           05  FCD-CONFIG-FLAGS     PIC 99   COMP-X.
           05  FCD-MISC-FLAGS       PIC 99   COMP-X.
           05  FCD-CONFIG-FLAGS2    PIC 99   COMP-X.
           05  FCD-IDXCACHE-SIZE    PIC 99   COMP-X.
           05  FCD-IDXCACHE-BUFFS   PIC 99   COMP-X.
           05  FCD-INTERNAL-FLAGS-1   PIC X COMP-X.
           05  FCD-INTERNAL-FLAGS-2   PIC X COMP-X.

      *================================================================*
       PROCEDURE DIVISION.
      *----------------------------------------------------------------*
       000-MAIN.

          PERFORM 100-OPEN.

          PERFORM VARYING I FROM 1 BY 1 UNTIL I > 10
            MOVE I TO DISPLAY-A1-ZZ9
            MOVE DISPLAY-A1-ZZ9 TO FCD-RECORD
            MOVE 10 TO FCD-CURRENT-REC-LEN
            IF I = 3 OR 5
                MOVE "Have a great day" TO FCD-RECORD (5:20)
                MOVE 25 TO FCD-CURRENT-REC-LEN
            END-IF
            IF I = 8
                MOVE "Enjoy the show" TO FCD-RECORD (5:20)
                MOVE 19 TO FCD-CURRENT-REC-LEN
            END-IF
            PERFORM 300-WRITE
          END-PERFORM.

          PERFORM 400-CLOSE.

          MOVE OP-OPEN-INPUT TO ACTION-CODE
          PERFORM 800-CALL-EXTFH
          DISPLAY "Listing " WS-FCD-DDNAME '.'.
          PERFORM VARYING I FROM 1 BY 1 UNTIL I > 10
            PERFORM 350-READ
            DISPLAY FCD-CURRENT-REC-LEN ": "
                    FCD-RECORD (1:FCD-CURRENT-REC-LEN) " :"
          END-PERFORM.
          PERFORM 400-CLOSE.
          STOP RUN.

      *----------------------------------------------------------------*
      *    Process the open request
      *
       100-OPEN.

          MOVE "TESTOUT" TO WS-FCD-DDNAME

          MOVE LENGTH OF FCD-MAP TO WS-FCD-SIZE
          DISPLAY "FCD SIZE " WS-FCD-SIZE '.'.
          DISPLAY "Writing " WS-FCD-DDNAME '.'.

          IF WS-FCD-PTR EQUAL NULL
             ALLOCATE ws-fcd-size CHARACTERS
                           returning WS-FCD-PTR

             SET  ADDRESS OF FCD-MAP  TO WS-FCD-PTR
             MOVE LOW-VALUES          TO FCD-MAP
             MOVE WS-FCD-SIZE         TO FCD-LENGTH
             MOVE FCD-VERSION-NUMBER  TO FCD-VERSION
             MOVE "00"                TO FCD-FILE-STATUS
             MOVE FCD--STATUS-DEFINED TO FCD-ACCESS-MODE
             MOVE FCD--OPEN-CLOSED    TO FCD-OPEN-MODE
             MOVE FCD--EXTERNAL-NAME  TO FCD-OTHER-FLAGS
             SET  FCD-HANDLE          TO NULL
             MOVE 8                   TO FCD-NAME-LENGTH
             SET  FCD-FILENAME-ADDRESS TO ADDRESS
                                       OF WS-FCD-DDNAME
             SET  FCD-KEY-DEF-ADDRESS TO NULL
             MOVE FCD--ALLOW-READERS  TO FCD-LOCKTYPES
          ELSE
             SET  ADDRESS OF FCD-MAP  TO WS-FCD-PTR
             IF FCD-OPEN-MODE NOT = fcd--open-closed
                DISPLAY "ERRROR - FILE ALREADY OPEN"
                STOP RUN
             END-IF
          END-IF

          MOVE FCD--LINE-SEQUENTIAL-ORG TO FCD-ORGANIZATION
          MOVE FCD--RECMODE-FIXED       TO FCD-RECORDING-MODE
          MOVE 10 TO FCD-MIN-REC-LENGTH
          MOVE 50 TO FCD-MAX-REC-LENGTH

      *  Check for missing record address
      *   MOVE OP-OPEN-OUTPUT TO ACTION-CODE
      *   PERFORM 800-CALL-EXTFH

          SET  FCD-RECORD-ADDRESS    TO ADDRESS OF FCD-RECORD
          SET  FCD-FILENAME-ADDRESS  TO NULL
      *  Check for missing filename address
          MOVE OP-OPEN-OUTPUT TO ACTION-CODE
          PERFORM 800-CALL-EXTFH

      *  Now set record address
          SET  FCD-RECORD-ADDRESS    TO ADDRESS OF FCD-RECORD
          SET  FCD-FILENAME-ADDRESS  TO ADDRESS OF WS-FCD-DDNAME
          MOVE OP-OPEN-OUTPUT TO ACTION-CODE
          PERFORM 800-CALL-EXTFH
          .

      *----------------------------------------------------------------*
      *    Process the write request
      *----------------------------------------------------------------*
       300-WRITE.
          MOVE OP-WRITE TO ACTION-CODE
          PERFORM 800-CALL-EXTFH
          .

      *----------------------------------------------------------------*
      *    Process the read request
      *----------------------------------------------------------------*
       350-READ.
          MOVE OP-READ-NEXT TO ACTION-CODE
          PERFORM 800-CALL-EXTFH
          .

      *----------------------------------------------------------------*
      *    Process the close request
      *----------------------------------------------------------------*
       400-CLOSE.
          MOVE OP-CLOSE               TO ACTION-CODE
          PERFORM 800-CALL-EXTFH
          .
      *----------------------------------------------------------------*
      *    External file handler interface -- all I/O goes through here
      *
        800-CALL-EXTFH.

           MOVE "00"                   TO FCD-FILE-STATUS
           CALL "EXTFH" USING ACTION-CODE, FCD-MAP

           IF FCD-STATUS-KEY-1 NOT = "0"
               IF FCD-STATUS-KEY-1 = "9"
                  IF FCD-BINARY = 161
                      DISPLAY "EXTFH Status: 9/" FCD-BINARY
                      DISPLAY "FCD2 is not accepted!"
                      STOP RUN
                  END-IF
                  DISPLAY "EXTFH Status: 9/" FCD-BINARY
                  IF FCD-BINARY = 141
                      DISPLAY "FCD2 is missing value(s)!"
                  END-IF
               ELSE
                  DISPLAY "EXTFH Status: " FCD-FILE-STATUS
               END-IF
            END-IF
            IF FCD-STATUS-KEY-1 = "9" AND FCD-BINARY = 199
               MOVE "10" TO FCD-FILE-STATUS
            END-IF
            .
])

# FIXME: by default comp-x should not be truncated (see trunk)
AT_CHECK([$COMPILE -fnotrunc prog.cob], [0], [], [])

AT_CHECK([TESTOUT=TEST-OUT $COBCRUN_DIRECT ./prog], [0],
[FCD SIZE 00100.
Writing TESTOUT   .
EXTFH Status: 9/141
FCD2 is missing value(s)!
Listing TESTOUT   .
00003:   1 :
00003:   2 :
00020:   3 Have a great day :
00003:   4 :
00020:   5 Have a great day :
00003:   6 :
00003:   7 :
00018:   8 Enjoy the show :
00003:   9 :
00003:  10 :
], [libcob: prog.cob:293: warning: ERROR: EXTFH called with no filename pointer
])


AT_CAPTURE_FILE([TEST-OUT])

AT_DATA([reference],
[  1
  2
  3 Have a great day
  4
  5 Have a great day
  6
  7
  8 Enjoy the show
  9
 10
])

AT_CHECK([diff reference TEST-OUT], [0], [], [])

AT_CLEANUP


AT_SETUP([RELATIVE Multi-Record])
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.

       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT FLATFILE ASSIGN EXTERNAL RELVAR
           ORGANIZATION RELATIVE
           ACCESS IS SEQUENTIAL
           RELATIVE KEY IS REC-NUM
           FILE STATUS IS CUST-STAT.

       DATA  DIVISION.
       FILE SECTION.
       FD  FLATFILE
           BLOCK CONTAINS 5 RECORDS.

       01  TSPFL-RECORD.
           10  CM-CUST-NUM                     PICTURE X(8).
           10  CM-TYPE                         PICTURE X.
           10  CM-COMPANY                      PICTURE X(25).
           10  CM-DISK                         PICTURE X(8).
           10  CM-NO-TERMINALS                 PICTURE 9(4) COMP-4.
           10  CM-PK-DATE                      PICTURE S9(14) COMP-3.
           10  CM-TRAILER                      PICTURE X(251).

       01  TSP2-RECORD.
           10  C2-CUST-NUM                     PICTURE X(8).
           10  C2-TYPE                         PICTURE X.
           10  C2-COMPANY                      PICTURE X(25).
           10  C2-ADDRESS                      PICTURE X(25).
           10  C2-DISK                         PICTURE X(8).
           10  C2-NO-TERMINALS                 PICTURE 9(4) COMP-4.
           10  C2-PK-DATE                      PICTURE S9(14) COMP-3.


       WORKING-STORAGE SECTION.

       78  MAX-SUB           VALUE  6.
       77  CUST-STAT                           PICTURE X(2).
       77  REC-NUM           VALUE  1          BINARY-SHORT UNSIGNED.

       01  TEST-DATA.

         02  DATA-CUST-NUM-TBL.

           05  FILLER PIC X(8) VALUE "ALP00000".
           05  FILLER PIC X(8) VALUE "BET00000".
           05  FILLER PIC X(8) VALUE "GAM00000".
           05  FILLER PIC X(8) VALUE "DEL00000".
           05  FILLER PIC X(8) VALUE "EPS00000".
           05  FILLER PIC X(8) VALUE "FOR00000".

         02  DATA-CUST-NUM REDEFINES DATA-CUST-NUM-TBL
                                       PIC X(8) OCCURS MAX-SUB.
         02  DATA-COMPANY-TBL.

           05  FILLER PIC X(25) VALUE "ALPHA ELECTRICAL CO. LTD.".
           05  FILLER PIC X(25) VALUE "BETA SHOE MFG. INC.      ".
           05  FILLER PIC X(25) VALUE "GAMMA X-RAY TECHNOLOGY   ".
           05  FILLER PIC X(25) VALUE "DELTA LUGGAGE REPAIRS    ".
           05  FILLER PIC X(25) VALUE "EPSILON EQUIPMENT SUPPLY ".
           05  FILLER PIC X(25) VALUE "FORTUNE COOKIE COMPANY   ".
         02  DATA-COMPANY  REDEFINES DATA-COMPANY-TBL
                                       PIC X(25) OCCURS MAX-SUB.
         02  DATA-ADDRESS-2-TBL.

           05  FILLER PIC X(10) VALUE "NEW YORK  ".
           05  FILLER PIC X(10) VALUE "ATLANTA   ".
           05  FILLER PIC X(10) VALUE "WASHINGTON".
           05  FILLER PIC X(10) VALUE "TORONTO   ".
           05  FILLER PIC X(10) VALUE "CALGARY   ".
           05  FILLER PIC X(10) VALUE "WHITEPLAIN".

         02  DATA-ADDRESS   REDEFINES DATA-ADDRESS-2-TBL
                                       PIC X(10) OCCURS MAX-SUB.

         02  DATA-NO-TERMINALS-TBL.

           05  FILLER PIC 9(3) COMP-3 VALUE 10.
           05  FILLER PIC 9(3) COMP-3 VALUE 13.
           05  FILLER PIC 9(3) COMP-3 VALUE 75.
           05  FILLER PIC 9(3) COMP-3 VALUE 10.
           05  FILLER PIC 9(3) COMP-3 VALUE 90.
           05  FILLER PIC 9(3) COMP-3 VALUE 254.

         02  DATA-NO-TERMINALS REDEFINES DATA-NO-TERMINALS-TBL
                                       PIC 9(3) COMP-3 OCCURS MAX-SUB.
       01  WORK-AREA.
           05  SUB                             BINARY-SHORT UNSIGNED.
               88  ODD-RECORD                  VALUE 1 3 5.


       PROCEDURE DIVISION.

           PERFORM LOADFILE.
           OPEN INPUT FLATFILE.
           DISPLAY "Initial Re-Read Open Sts:" CUST-STAT
           PERFORM UNTIL CUST-STAT NOT = "00"
               PERFORM READ-RECORD
           END-PERFORM.
           IF CUST-STAT = "30"
               CLOSE FLATFILE
           STOP RUN
           END-IF
           CLOSE FLATFILE.

           OPEN I-O FLATFILE.
           DISPLAY "For Rewrite Open I-O Sts:" CUST-STAT
           PERFORM READ-RECORD
           ADD 1 TO C2-NO-TERMINALS
           REWRITE TSP2-RECORD
           DISPLAY "REWRITE " CM-CUST-NUM " Sts " CUST-STAT
                   " Trms:" C2-NO-TERMINALS.
           CLOSE FLATFILE.

           OPEN I-O FLATFILE.
           DISPLAY "For Rewrite/Delete Open I-O Sts:" CUST-STAT
           PERFORM READ-RECORD
           ADD 1 TO C2-NO-TERMINALS
           REWRITE TSP2-RECORD
           DISPLAY "REWRITE " CM-CUST-NUM " Sts " CUST-STAT
                   " Trms:" C2-NO-TERMINALS.
           PERFORM READ-RECORD
           DELETE FLATFILE
           DISPLAY "DELETE " CM-CUST-NUM " Sts " CUST-STAT.
           CLOSE FLATFILE.

           OPEN INPUT FLATFILE.
           DISPLAY "Re-list Open Sts:" CUST-STAT
           PERFORM UNTIL CUST-STAT NOT = "00"
               PERFORM READ-RECORD
           END-PERFORM.
           CLOSE FLATFILE.

           OPEN EXTEND FLATFILE.
           PERFORM LOAD-RECORD
                        VARYING SUB FROM 1 BY 1
                          UNTIL SUB > 2.
           CLOSE FLATFILE.

           OPEN INPUT FLATFILE.
           DISPLAY "Re-list afer Extend Open Sts:" CUST-STAT
           PERFORM UNTIL CUST-STAT NOT = "00"
               PERFORM READ-RECORD
           END-PERFORM.
           CLOSE FLATFILE.
           STOP RUN RETURNING 0.

       LOADFILE.
           DISPLAY "Loading sample program data file."
                            UPON CONSOLE.

           OPEN OUTPUT FLATFILE.

           PERFORM LOAD-RECORD
                        VARYING SUB FROM 1 BY 1
                          UNTIL SUB > MAX-SUB.

           DISPLAY "Sample program data file load complete."
                            UPON CONSOLE.
           CLOSE FLATFILE.

       READ-RECORD.
           MOVE SPACES                       TO TSPFL-RECORD.
           MOVE SPACES                       TO TSP2-RECORD.
           READ FLATFILE
           IF CUST-STAT NOT = "00"
             DISPLAY "Read Status: " CUST-STAT
           ELSE
           IF CM-TYPE = SPACES
             DISPLAY "Read  " CM-CUST-NUM " #:" REC-NUM
                     " Trms:" CM-NO-TERMINALS
           ELSE
             DISPLAY "Read2 " C2-CUST-NUM " #:" REC-NUM
                     " Trms:" C2-NO-TERMINALS
           END-IF.
      *
       LOAD-RECORD.
           MOVE SPACES                       TO TSPFL-RECORD.
           MOVE SPACES                       TO TSP2-RECORD.
           MOVE DATA-CUST-NUM      (SUB)     TO CM-CUST-NUM.
           MOVE DATA-COMPANY       (SUB)     TO CM-COMPANY.
           MOVE DATA-NO-TERMINALS  (SUB)     TO CM-NO-TERMINALS.
           MOVE 20070319                     TO CM-PK-DATE.
           IF SUB = 1 OR 4 OR 6
               MOVE -20070319                 TO CM-PK-DATE.
      *
           IF ODD-RECORD
               MOVE "8417"                   TO C2-DISK
      *        MOVE CM-CUST-NUM              TO C2-CUST-NUM
               MOVE '2'                      TO C2-TYPE
      *        MOVE CM-COMPANY               TO C2-COMPANY
               MOVE CM-PK-DATE               TO C2-PK-DATE
               MOVE CM-NO-TERMINALS          TO C2-NO-TERMINALS
               MOVE DATA-ADDRESS (SUB)       TO C2-ADDRESS
               WRITE TSP2-RECORD
           ELSE
               MOVE "8470"                   TO CM-DISK
               MOVE ' '                      TO CM-TYPE
               WRITE TSPFL-RECORD.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[Loading sample program data file.
Sample program data file load complete.
Initial Re-Read Open Sts:00
Read2 ALP00000 #:00001 Trms:0010
Read  BET00000 #:00002 Trms:0013
Read2 GAM00000 #:00003 Trms:0075
Read  DEL00000 #:00004 Trms:0010
Read2 EPS00000 #:00005 Trms:0090
Read  FOR00000 #:00006 Trms:0254
Read Status: 10
For Rewrite Open I-O Sts:00
Read2 ALP00000 #:00001 Trms:0010
REWRITE ALP00000 Sts 00 Trms:0011
For Rewrite/Delete Open I-O Sts:00
Read2 ALP00000 #:00001 Trms:0011
REWRITE ALP00000 Sts 00 Trms:0012
Read  BET00000 #:00002 Trms:0013
DELETE BET00000 Sts 00
Re-list Open Sts:00
Read2 ALP00000 #:00001 Trms:0012
Read2 GAM00000 #:00003 Trms:0075
Read  DEL00000 #:00004 Trms:0010
Read2 EPS00000 #:00005 Trms:0090
Read  FOR00000 #:00006 Trms:0254
Read Status: 10
Re-list afer Extend Open Sts:00
Read2 ALP00000 #:00001 Trms:0012
Read2 GAM00000 #:00003 Trms:0075
Read  DEL00000 #:00004 Trms:0010
Read2 EPS00000 #:00005 Trms:0090
Read  FOR00000 #:00006 Trms:0254
Read2 ALP00000 #:00007 Trms:0010
Read  BET00000 #:00008 Trms:0013
Read Status: 10
], [])

AT_CLEANUP


AT_SETUP([INDEXED File READ/DELETE/READ])
AT_KEYWORDS([runfile READ DELETE EXTFH])

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.

       PROGRAM-ID. prog.

       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.

       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT TSPFILE
           ASSIGN TO EXTERNAL TSPFILE
           ORGANIZATION INDEXED ACCESS DYNAMIC
           RECORD KEY IS CM-CUST-NUM

           ALTERNATE RECORD KEY IS SPLIT-KEY2
           SOURCE IS CM-TELEPHONE WITH DUPLICATES

           ALTERNATE RECORD KEY IS SPLIT-KEY3
           SOURCE IS CM-DISK,CM-TAPE WITH DUPLICATES
      *         SUPPRESS WHEN ALL "*"
           FILE STATUS IS CUST-STAT
           .

       DATA  DIVISION.
       FILE SECTION.
       FD  TSPFILE
           BLOCK CONTAINS 5 RECORDS.

       01  TSPFL-RECORD.
           05  TSPFL-REC.
           10  CM-CUST-NUM.
             15  CM-CUST-PRE                   PICTURE X(3).
             15  CM-CUST-NNN                   PICTURE X(5).
           10  CM-STATUS                       PICTURE X.
           10  CM-COMPANY                      PICTURE X(25).
           10  CM-ADDRESS-1                    PICTURE X(25).
           10  CM-ADDRESS-2                    PICTURE X(25).
           10  CM-ADDRESS-3                    PICTURE X(25).
           10  CM-TELEPHONE                    PICTURE 9(10).
           10  CM-DP-MGR                       PICTURE X(25).
           10  CM-MACHINE                      PICTURE X(8).
           10  CM-MEMORY                       PICTURE X(4).
           10  CM-DISK                         PICTURE X(8).
           10  CM-TAPE                         PICTURE X(8).
           10  CM-NO-TERMINALS                 PICTURE 9(5).

       WORKING-STORAGE SECTION.

       01  CUST-STAT.
           05  STAT-1 PICTURE 9(4) COMP SYNC.
           05  FILLER REDEFINES STAT-1.
               10  STAT-X1 PIC X COMP-X.
               10  STAT-X2 PIC X COMP-X.
       77  DATA-STAT                      PICTURE XX.
       77  ISAM-STAT                      PICTURE XX.
       77  BYTE-1  PICTURE 9(3).
       77  BYTE-2  PICTURE 9(3).
       78  MAX-SUB           VALUE  16.
       77  SAV-KEY   PIC X(8).

       01  TEST-DATA.

         02  DATA-CUST-NUM-TBL.

           05  FILLER PIC X(8) VALUE "ALP00000".
           05  FILLER PIC X(8) VALUE "BET00000".
           05  FILLER PIC X(8) VALUE "GAM00000".
           05  FILLER PIC X(8) VALUE "DEL00000".
           05  FILLER PIC X(8) VALUE "EPS00000".
           05  FILLER PIC X(8) VALUE "FOR00000".
           05  FILLER PIC X(8) VALUE "GIB00000".
           05  FILLER PIC X(8) VALUE "H&J00000".
           05  FILLER PIC X(8) VALUE "INC00000".
           05  FILLER PIC X(8) VALUE "JOH00000".
           05  FILLER PIC X(8) VALUE "KON00000".
           05  FILLER PIC X(8) VALUE "LEW00000".
           05  FILLER PIC X(8) VALUE "MOR00000".
           05  FILLER PIC X(8) VALUE "NEW00000".
           05  FILLER PIC X(8) VALUE "OLD00000".
           05  FILLER PIC X(8) VALUE "PRE00000".

         02  DATA-CUST-NUM REDEFINES DATA-CUST-NUM-TBL
                                       PIC X(8) OCCURS MAX-SUB.
         02  DATA-COMPANY-TBL.

           05  FILLER PIC X(25) VALUE "ALPHA ELECTRICAL CO. LTD.".
           05  FILLER PIC X(25) VALUE "BETA SHOE MFG. INC.      ".
           05  FILLER PIC X(25) VALUE "GAMMA X-RAY TECHNOLOGY   ".
           05  FILLER PIC X(25) VALUE "DELTA LUGGAGE REPAIRS    ".
           05  FILLER PIC X(25) VALUE "EPSILON EQUIPMENT SUPPLY ".
           05  FILLER PIC X(25) VALUE "FORTUNE COOKIE COMPANY   ".
           05  FILLER PIC X(25) VALUE "GIBRALTER LIFE INSURANCE ".
           05  FILLER PIC X(25) VALUE "H & J PLUMBING SUPPLIES  ".
           05  FILLER PIC X(25) VALUE "INCREMENTAL BACKUP CORP. ".
           05  FILLER PIC X(25) VALUE "JOHNSON BOATING SUPPLIES ".
           05  FILLER PIC X(25) VALUE "KONFLAB PLASTIC PRODUCTS.".
           05  FILLER PIC X(25) VALUE "LEWISTON GRAPHICS LTD.   ".
           05  FILLER PIC X(25) VALUE "MORNINGSIDE CARPENTRY.   ".
           05  FILLER PIC X(25) VALUE "NEW WAVE SURF SHOPS INC. ".
           05  FILLER PIC X(25) VALUE "OLD TYME PIZZA MFG. CO.  ".
           05  FILLER PIC X(25) VALUE "PRESTIGE OFFICE FURNITURE".

         02  DATA-COMPANY  REDEFINES DATA-COMPANY-TBL
                                       PIC X(25) OCCURS MAX-SUB.
         02  DATA-ADDRESS-1-TBL.

           05  FILLER PIC X(25) VALUE "123 MAIN STREET          ".
           05  FILLER PIC X(25) VALUE "1090 2ND AVE. WEST       ".
           05  FILLER PIC X(25) VALUE "1401 JEFFERSON BLVD.     ".
           05  FILLER PIC X(25) VALUE "1620 ARIZONA WAY         ".
           05  FILLER PIC X(25) VALUE "1184 EAST FIRST STREET   ".
           05  FILLER PIC X(25) VALUE "114 JOHN F. KENNEDY AVE. ".
           05  FILLER PIC X(25) VALUE "650 LIBERTY CRESCENT     ".
           05  FILLER PIC X(25) VALUE "77 SUNSET BLVD.          ".
           05  FILLER PIC X(25) VALUE "10908 SANTA MONICA BLVD. ".
           05  FILLER PIC X(25) VALUE "1134 PARIS ROAD          ".
           05  FILLER PIC X(25) VALUE "808 NORTHWEST MAIN ST.   ".
           05  FILLER PIC X(25) VALUE "9904 QUEEN STREET        ".
           05  FILLER PIC X(25) VALUE "1709 DUNDAS CRESCENT W.  ".
           05  FILLER PIC X(25) VALUE "3240 MARIS AVENUE        ".
           05  FILLER PIC X(25) VALUE "1705 WISCONSIN ROAD      ".
           05  FILLER PIC X(25) VALUE "114A MAPLE GROVE         ".

         02  DATA-ADDRESS-1 REDEFINES DATA-ADDRESS-1-TBL
                                       PIC X(25) OCCURS MAX-SUB.
         02  DATA-ADDRESS-2-TBL.

           05  FILLER PIC X(10) VALUE "NEW YORK  ".
           05  FILLER PIC X(10) VALUE "ATLANTA   ".
           05  FILLER PIC X(10) VALUE "WASHINGTON".
           05  FILLER PIC X(10) VALUE "TORONTO   ".
           05  FILLER PIC X(10) VALUE "CALGARY   ".
           05  FILLER PIC X(10) VALUE "SAN DIEGO ".
           05  FILLER PIC X(10) VALUE "LOS RIOS  ".
           05  FILLER PIC X(10) VALUE "MADISON   ".
           05  FILLER PIC X(10) VALUE "WILBUR    ".
           05  FILLER PIC X(10) VALUE "TOPEKA    ".
           05  FILLER PIC X(10) VALUE "SEATTLE   ".
           05  FILLER PIC X(10) VALUE "NEW JERSEY".
           05  FILLER PIC X(10) VALUE "FORT WAYNE".
           05  FILLER PIC X(10) VALUE "COLUMBUS  ".
           05  FILLER PIC X(10) VALUE "RICHMOND  ".
           05  FILLER PIC X(10) VALUE "WHITEPLAIN".

         02  DATA-ADDRESS-2 REDEFINES DATA-ADDRESS-2-TBL
                                       PIC X(10) OCCURS MAX-SUB.
         02  DATA-ADDRESS-3-TBL.

           05  FILLER PIC X(10) VALUE "N.Y.      ".
           05  FILLER PIC X(10) VALUE "GEORGIA   ".
           05  FILLER PIC X(10) VALUE "D.C.      ".
           05  FILLER PIC X(10) VALUE "CANADA    ".
           05  FILLER PIC X(10) VALUE "CANADA    ".
           05  FILLER PIC X(10) VALUE "CALIFORNIA".
           05  FILLER PIC X(10) VALUE "NEW MEXICO".
           05  FILLER PIC X(10) VALUE "WISCONSIN ".
           05  FILLER PIC X(10) VALUE "DELAWARE  ".
           05  FILLER PIC X(10) VALUE "KANSAS    ".
           05  FILLER PIC X(10) VALUE "WASHINGTON".
           05  FILLER PIC X(10) VALUE "N.J.      ".
           05  FILLER PIC X(10) VALUE "COLORADO  ".
           05  FILLER PIC X(10) VALUE "OHIO      ".
           05  FILLER PIC X(10) VALUE "VIRGINIA  ".
           05  FILLER PIC X(10) VALUE "N.Y.      ".

         02  DATA-ADDRESS-3 REDEFINES DATA-ADDRESS-3-TBL
                                       PIC X(10) OCCURS MAX-SUB.
         02  DATA-TELEPHONE-TBL.

           05  FILLER PIC 9(10) VALUE 3131234432.
           05  FILLER PIC 9(10) VALUE 4169898509.
           05  FILLER PIC 9(10) VALUE 8372487274.
           05  FILLER PIC 9(10) VALUE 4169898509.
           05  FILLER PIC 9(10) VALUE 5292398745.
           05  FILLER PIC 9(10) VALUE 8009329492.
           05  FILLER PIC 9(10) VALUE 6456445643.
           05  FILLER PIC 9(10) VALUE 6546456333.
           05  FILLER PIC 9(10) VALUE 3455445444.
           05  FILLER PIC 9(10) VALUE 6456445643.
           05  FILLER PIC 9(10) VALUE 7456434355.
           05  FILLER PIC 9(10) VALUE 6554456433.
           05  FILLER PIC 9(10) VALUE 4169898509.
           05  FILLER PIC 9(10) VALUE 7534587453.
           05  FILLER PIC 9(10) VALUE 8787458374.
           05  FILLER PIC 9(10) VALUE 4169898509.

         02  DATA-TELEPHONE REDEFINES DATA-TELEPHONE-TBL
                                       PIC 9(10) OCCURS MAX-SUB.
         02  DATA-DP-MGR-TBL.

           05  FILLER PIC X(20) VALUE "MR. DAVE HARRIS     ".
           05  FILLER PIC X(20) VALUE "MS. JANICE SILCOX   ".
           05  FILLER PIC X(20) VALUE "MR. ALLAN JONES     ".
           05  FILLER PIC X(20) VALUE "MR. PETER MACKAY    ".
           05  FILLER PIC X(20) VALUE "MRS. DONNA BREWER   ".
           05  FILLER PIC X(20) VALUE "MR. MICHAEL SMYTHE  ".
           05  FILLER PIC X(20) VALUE "MR. D.A. MORRISON   ".
           05  FILLER PIC X(20) VALUE "MR. BRIAN PATTERSON ".
           05  FILLER PIC X(20) VALUE "MR. DARRYL TOWNSEND ".
           05  FILLER PIC X(20) VALUE "MS. VALERIE HARPER  ".
           05  FILLER PIC X(20) VALUE "MR. FRED MILLER     ".
           05  FILLER PIC X(20) VALUE "MR. DONALD FISCHER  ".
           05  FILLER PIC X(20) VALUE "MR. STEVEN YOURDIN  ".
           05  FILLER PIC X(20) VALUE "MS. Goldie Hawn     ".
           05  FILLER PIC X(20) VALUE "MS. ALICE WINSTON   ".
           05  FILLER PIC X(20) VALUE "MR. THOMAS JEFFERSON".

         02  DATA-DP-MGR    REDEFINES DATA-DP-MGR-TBL
                                       PIC X(20) OCCURS MAX-SUB.
         02  DATA-MACHINE-TBL.

           05  FILLER PIC X(8) VALUE "UNI-9030".
           05  FILLER PIC X(8) VALUE "UNI-9040".
           05  FILLER PIC X(8) VALUE "UNI-80/3".
           05  FILLER PIC X(8) VALUE "UNI-80/5".
           05  FILLER PIC X(8) VALUE "UNI-80/6".
           05  FILLER PIC X(8) VALUE "UNI-80/6".
           05  FILLER PIC X(8) VALUE "UNI-80/6".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-9040".
           05  FILLER PIC X(8) VALUE "UNI-9040".

         02  DATA-MACHINE   REDEFINES DATA-MACHINE-TBL
                                       PIC X(8) OCCURS MAX-SUB.
         02  DATA-NO-TERMINALS-TBL.

           05  FILLER PIC 9(3) COMP-3 VALUE 85.
           05  FILLER PIC 9(3) COMP-3 VALUE 34.
           05  FILLER PIC 9(3) COMP-3 VALUE 75.
           05  FILLER PIC 9(3) COMP-3 VALUE 45.
           05  FILLER PIC 9(3) COMP-3 VALUE 90.
           05  FILLER PIC 9(3) COMP-3 VALUE 107.
           05  FILLER PIC 9(3) COMP-3 VALUE 67.
           05  FILLER PIC 9(3) COMP-3 VALUE 32.
           05  FILLER PIC 9(3) COMP-3 VALUE 16.
           05  FILLER PIC 9(3) COMP-3 VALUE 34.
           05  FILLER PIC 9(3) COMP-3 VALUE 128.
           05  FILLER PIC 9(3) COMP-3 VALUE 64.
           05  FILLER PIC 9(3) COMP-3 VALUE 110.
           05  FILLER PIC 9(3) COMP-3 VALUE 324.
           05  FILLER PIC 9(3) COMP-3 VALUE 124.
           05  FILLER PIC 9(3) COMP-3 VALUE 86.

         02  DATA-NO-TERMINALS REDEFINES DATA-NO-TERMINALS-TBL
                                       PIC 9(3) COMP-3 OCCURS MAX-SUB.

       78  REC-MAX                    VALUE MAX-SUB.
       01  WORK-AREA.
           05  REC-NUM                BINARY-SHORT UNSIGNED VALUE 0.
           05  SUB                    BINARY-SHORT UNSIGNED.
               88  ODD-RECORD         VALUE 1 3 5 7 9 10 11.
               88  NULL-KEY           VALUE 4 5 8 12 14.

           05  TSPFL-KEY              PICTURE X(8).

       PROCEDURE DIVISION.

       MAINFILE.
           DISPLAY "Loading sample data file."
                            UPON CONSOLE.
           PERFORM LOADFILE.
           DISPLAY "Sample data file load complete."
                            UPON CONSOLE.
           PERFORM LIST-FILE.
           PERFORM LIST-PHONE.
           PERFORM DELSEQ-FILE.
           PERFORM LIST-PHONE.
           PERFORM LOADFILE.
           PERFORM LIST-PHONE.
           PERFORM DELPRV-FILE.
           PERFORM LIST-PHONE.
      *    PERFORM DEL-FILE.
           STOP RUN.

       LOADFILE.
           OPEN OUTPUT TSPFILE
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "05"
               DIVIDE STAT-1 BY 256 GIVING BYTE-1 REMAINDER BYTE-2
               DISPLAY "Error " CUST-STAT " " BYTE-1 " " BYTE-2
               " opening 'testisam' file"
                                UPON CONSOLE
               STOP RUN
           END-IF.

           PERFORM 1000-LOAD-RECORD
                        VARYING SUB FROM 1 BY 1
                          UNTIL SUB > MAX-SUB.

           CLOSE TSPFILE.

       DEL-FILE.
           DISPLAY "Rewrite sample data file: " CUST-STAT
                            UPON CONSOLE.

           OPEN I-O TSPFILE
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "05"
               DIVIDE STAT-1 BY 256 GIVING BYTE-1 REMAINDER BYTE-2
               DISPLAY "Error " CUST-STAT " " BYTE-1 " " BYTE-2
               " opening 'testisam' file"
                                UPON CONSOLE
               STOP RUN
           END-IF.
           MOVE "DEL00000" TO CM-CUST-NUM
           READ TSPFILE
           IF  CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " read lock " CM-CUST-NUM
           END-IF
           DELETE TSPFILE
           IF  CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " delete " CM-CUST-NUM
           END-IF
           MOVE "INC00000" TO CM-CUST-NUM
           READ TSPFILE
           IF  CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " read lock " CM-CUST-NUM
           END-IF
           DELETE TSPFILE
           IF  CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " delete " CM-CUST-NUM
           END-IF

           DISPLAY "Sample data file rewrite complete."
                            UPON CONSOLE.
           CLOSE TSPFILE.

       DELSEQ-FILE.
           DISPLAY "Test Read/Delete" UPON CONSOLE.
           MOVE "00" TO  CUST-STAT.
           OPEN I-O TSPFILE
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "05"
               DIVIDE STAT-1 BY 256 GIVING BYTE-1 REMAINDER BYTE-2
               DISPLAY "Error " CUST-STAT " " BYTE-1 " " BYTE-2
               " opening 'testisam' file"
                                UPON CONSOLE
               STOP RUN
           END-IF.
           MOVE "INC00000" TO CM-CUST-NUM
           READ TSPFILE
           IF  CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " read " CM-CUST-NUM
           END-IF
           DELETE TSPFILE
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " delete " CM-CUST-NUM
           ELSE
               DISPLAY " Delete: " CM-CUST-NUM " random"
           END-IF
           MOVE "ALP00000" TO CM-CUST-NUM
           READ TSPFILE
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " read " CM-CUST-NUM
           END-IF
           DELETE TSPFILE
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " delete " CM-CUST-NUM
           ELSE
               DISPLAY " Delete: " CM-CUST-NUM " random"
           END-IF
           READ TSPFILE NEXT RECORD
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " read " CM-CUST-NUM
           ELSE
               DISPLAY "   Read: " CM-CUST-NUM " " CM-TELEPHONE
           END-IF
           MOVE "PRE00000" TO CM-CUST-NUM
           READ TSPFILE
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " read " CM-CUST-NUM
           END-IF
           DELETE TSPFILE
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " delete " CM-CUST-NUM
           ELSE
               DISPLAY " Delete: " CM-CUST-NUM " random"
           END-IF
           READ TSPFILE NEXT RECORD
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Expected " CUST-STAT
                       " after delete " CM-CUST-NUM
           ELSE
               DISPLAY "   Read: " CM-CUST-NUM " " CM-TELEPHONE
           END-IF

           MOVE SPACES TO TSPFL-RECORD
           MOVE '4169898509' TO CM-TELEPHONE
           START TSPFILE KEY GREATER THAN OR EQUAL TO SPLIT-KEY2
           IF  CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " read " CM-CUST-NUM
           END-IF
           PERFORM 4 TIMES
             READ TSPFILE NEXT RECORD
             IF  CUST-STAT NOT = "00"
             AND CUST-STAT NOT = "02"
                 DISPLAY "Error " CUST-STAT " start " CM-CUST-NUM
             ELSE
                 DISPLAY "Initial: " CM-CUST-NUM " " CM-TELEPHONE
                 IF CM-TELEPHONE = '4169898509'
                    MOVE CM-CUST-NUM TO SAV-KEY
                 END-IF
             END-IF
           END-PERFORM
           MOVE SPACES TO TSPFL-RECORD
           MOVE '4169898509' TO CM-TELEPHONE
           START TSPFILE KEY GREATER THAN OR EQUAL TO SPLIT-KEY2
           IF  CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " read " CM-CUST-NUM
           END-IF
           READ TSPFILE NEXT RECORD
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " start " CM-CUST-NUM
           ELSE
               DISPLAY "  Start: " CM-CUST-NUM " " CM-TELEPHONE
           END-IF
           READ TSPFILE NEXT RECORD
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " read " CM-CUST-NUM
           ELSE
               DISPLAY "   Next: " CM-CUST-NUM " " CM-TELEPHONE
           END-IF
           DELETE TSPFILE
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " delete " CM-CUST-NUM
           ELSE
               DISPLAY " Delete: " CM-CUST-NUM " sequential"
           END-IF
           READ TSPFILE NEXT RECORD
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " read " CM-CUST-NUM
           ELSE
               DISPLAY "   Next: " CM-CUST-NUM " " CM-TELEPHONE
               IF CM-CUST-NUM NOT = SAV-KEY
                  DISPLAY "Problem! Expected:" SAV-KEY
               END-IF
           END-IF
           READ TSPFILE NEXT RECORD
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " read " CM-CUST-NUM
           ELSE
               DISPLAY "   Next: " CM-CUST-NUM " " CM-TELEPHONE
           END-IF
           DELETE TSPFILE
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " delete " CM-CUST-NUM
           ELSE
               DISPLAY " Delete: " CM-CUST-NUM " sequential"
           END-IF

           CLOSE TSPFILE.

       DELPRV-FILE.
           DISPLAY "Read Prev/Delete" UPON CONSOLE.
           MOVE "00" TO  CUST-STAT.
           OPEN I-O TSPFILE
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "05"
               DIVIDE STAT-1 BY 256 GIVING BYTE-1 REMAINDER BYTE-2
               DISPLAY "Error " CUST-STAT " " BYTE-1 " " BYTE-2
               " opening 'testisam' file"
                                UPON CONSOLE
               STOP RUN
           END-IF.

           MOVE SPACES TO TSPFL-RECORD
           MOVE '5292398745' TO CM-TELEPHONE
           START TSPFILE KEY LESS THAN SPLIT-KEY2
           IF  CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " read " CM-CUST-NUM
           END-IF
           PERFORM VARYING REC-NUM FROM 1 BY 1
                     UNTIL REC-NUM > 4
             READ TSPFILE PREVIOUS RECORD
             IF  CUST-STAT NOT = "00"
             AND CUST-STAT NOT = "02"
                 DISPLAY "Error " CUST-STAT " start " CM-CUST-NUM
             ELSE
                 DISPLAY REC-NUM " Initial: " CM-CUST-NUM
                         " " CM-TELEPHONE
                 IF REC-NUM = 3
                    MOVE CM-CUST-NUM TO SAV-KEY
                 END-IF
             END-IF
           END-PERFORM
           MOVE SPACES TO TSPFL-RECORD
           MOVE '5292398745' TO CM-TELEPHONE
           START TSPFILE KEY LESS THAN SPLIT-KEY2
           IF  CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " read " CM-CUST-NUM
           END-IF
           READ TSPFILE PREVIOUS RECORD
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " start " CM-CUST-NUM
           ELSE
               DISPLAY "  Start: " CM-CUST-NUM " " CM-TELEPHONE
           END-IF
           READ TSPFILE PREVIOUS RECORD
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " read " CM-CUST-NUM
           ELSE
               DISPLAY "   Prev: " CM-CUST-NUM " " CM-TELEPHONE
           END-IF
           DELETE TSPFILE
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " delete " CM-CUST-NUM
           ELSE
               DISPLAY " Delete: " CM-CUST-NUM " sequential"
           END-IF
           READ TSPFILE PREVIOUS RECORD
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " read prev " CM-CUST-NUM
               CLOSE TSPFILE
               STOP RUN
           ELSE
               DISPLAY "   Prev: " CM-CUST-NUM " " CM-TELEPHONE
               IF CM-CUST-NUM NOT = SAV-KEY
                  DISPLAY "Problem! Expected:" SAV-KEY
                  CLOSE TSPFILE
                  STOP RUN
               END-IF
           END-IF
           READ TSPFILE PREVIOUS RECORD
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " read prev " CM-CUST-NUM
           ELSE
               DISPLAY "   Prev: " CM-CUST-NUM " " CM-TELEPHONE
           END-IF
           DELETE TSPFILE
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " delete " CM-CUST-NUM
           ELSE
               DISPLAY " Delete: " CM-CUST-NUM " sequential"
           END-IF

           CLOSE TSPFILE.

       LIST-FILE.
           DISPLAY "List sample data file"
                            UPON CONSOLE.
           MOVE "00" TO  CUST-STAT.
           MOVE 0 TO REC-NUM.
           OPEN I-O TSPFILE
           MOVE "        " TO CM-CUST-NUM
           START TSPFILE KEY GREATER THAN OR EQUAL TO CM-CUST-NUM
           IF  CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " read " CM-CUST-NUM
           END-IF
           READ TSPFILE NEXT RECORD
                AT END
                    MOVE "99" TO CUST-STAT
           END-READ.
           IF  CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " first read " CM-CUST-NUM
           END-IF
           PERFORM UNTIL CUST-STAT NOT = "00"
                      OR REC-NUM > REC-MAX
               DISPLAY "Key: " CM-CUST-NUM " is " CM-COMPANY
                        " Disk=" CM-DISK
                        "." UPON CONSOLE
               READ TSPFILE NEXT RECORD
                    AT END
                        MOVE "99" TO CUST-STAT
               END-READ
               ADD 1 TO REC-NUM
           END-PERFORM.
           IF CUST-STAT = "99"
               DISPLAY "Hit End of File" UPON CONSOLE
           END-IF.
           CLOSE TSPFILE.

       LIST-PHONE.
           DISPLAY "List sample data file by Phone"
                            UPON CONSOLE.
           MOVE "00" TO  CUST-STAT.
           MOVE 0 TO REC-NUM.
           OPEN I-O TSPFILE
           MOVE SPACES TO TSPFL-RECORD
           START TSPFILE KEY GREATER THAN OR EQUAL TO SPLIT-KEY2
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " read " CM-CUST-NUM
           END-IF
           READ TSPFILE NEXT RECORD
                AT END
                    MOVE "99" TO CUST-STAT
           END-READ.
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " first read " CM-CUST-NUM
           END-IF
           PERFORM UNTIL CUST-STAT NOT = "00"
                     AND CUST-STAT NOT = "02"
               DISPLAY "Ph=" CM-TELEPHONE
                       " Key: " CM-CUST-NUM " is " CM-COMPANY
                       "." UPON CONSOLE
               READ TSPFILE NEXT RECORD
                    AT END
                        MOVE "99" TO CUST-STAT
               END-READ
               ADD 1 TO REC-NUM
           END-PERFORM.
           IF CUST-STAT = "99"
               DISPLAY "Hit End of File" UPON CONSOLE
           END-IF.
           CLOSE TSPFILE.

      *---------------------------------------------------------------*
      *         LOAD A RECORD FROM DATA TABLES                        *
      *---------------------------------------------------------------*

       1000-LOAD-RECORD.

           MOVE SPACES                       TO TSPFL-RECORD.
           MOVE DATA-CUST-NUM      (SUB)     TO CM-CUST-NUM.
           MOVE CM-CUST-NUM                  TO TSPFL-KEY.
           MOVE DATA-COMPANY       (SUB)     TO CM-COMPANY.
           MOVE DATA-ADDRESS-1     (SUB)     TO CM-ADDRESS-1.
           MOVE DATA-ADDRESS-2     (SUB)     TO CM-ADDRESS-2.
           MOVE DATA-ADDRESS-3     (SUB)     TO CM-ADDRESS-3.
           MOVE DATA-TELEPHONE     (SUB)     TO CM-TELEPHONE.
           MOVE DATA-DP-MGR        (SUB)     TO CM-DP-MGR.
           MOVE DATA-MACHINE       (SUB)     TO CM-MACHINE.
           MOVE DATA-NO-TERMINALS  (SUB)     TO CM-NO-TERMINALS.

           IF  ODD-RECORD
               MOVE "8417"                   TO CM-DISK
               MOVE "1600 BPI"               TO CM-TAPE
               MOVE "1MEG"                   TO CM-MEMORY
           ELSE
               MOVE "8470"                   TO CM-DISK
               MOVE "6250 BPI"               TO CM-TAPE
               MOVE "3MEG"                   TO CM-MEMORY.
           IF  NULL-KEY
               MOVE ALL "*"                  TO CM-DISK
               MOVE ALL "*"                  TO CM-TAPE.

           WRITE TSPFL-RECORD
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "WRITE: " TSPFL-KEY ", Status: "
                       CUST-STAT UPON CONSOLE
           END-IF.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])

AT_CAPTURE_FILE([prog.out])

AT_CHECK([$COBCRUN_DIRECT ./prog 1>prog.out], [0], [], [])

AT_DATA([reference], [Loading sample data file.
Sample data file load complete.
List sample data file
Key: ALP00000 is ALPHA ELECTRICAL CO. LTD. Disk=8417    .
Key: BET00000 is BETA SHOE MFG. INC.       Disk=8470    .
Key: DEL00000 is DELTA LUGGAGE REPAIRS     Disk=********.
Key: EPS00000 is EPSILON EQUIPMENT SUPPLY  Disk=********.
Key: FOR00000 is FORTUNE COOKIE COMPANY    Disk=8470    .
Key: GAM00000 is GAMMA X-RAY TECHNOLOGY    Disk=8417    .
Key: GIB00000 is GIBRALTER LIFE INSURANCE  Disk=8417    .
Key: H&J00000 is H & J PLUMBING SUPPLIES   Disk=********.
Key: INC00000 is INCREMENTAL BACKUP CORP.  Disk=8417    .
Key: JOH00000 is JOHNSON BOATING SUPPLIES  Disk=8417    .
Key: KON00000 is KONFLAB PLASTIC PRODUCTS. Disk=8417    .
Key: LEW00000 is LEWISTON GRAPHICS LTD.    Disk=********.
Key: MOR00000 is MORNINGSIDE CARPENTRY.    Disk=8470    .
Key: NEW00000 is NEW WAVE SURF SHOPS INC.  Disk=********.
Key: OLD00000 is OLD TYME PIZZA MFG. CO.   Disk=8470    .
Key: PRE00000 is PRESTIGE OFFICE FURNITURE Disk=8470    .
Hit End of File
List sample data file by Phone
Ph=3131234432 Key: ALP00000 is ALPHA ELECTRICAL CO. LTD..
Ph=3455445444 Key: INC00000 is INCREMENTAL BACKUP CORP. .
Ph=4169898509 Key: BET00000 is BETA SHOE MFG. INC.      .
Ph=4169898509 Key: DEL00000 is DELTA LUGGAGE REPAIRS    .
Ph=4169898509 Key: MOR00000 is MORNINGSIDE CARPENTRY.   .
Ph=4169898509 Key: PRE00000 is PRESTIGE OFFICE FURNITURE.
Ph=5292398745 Key: EPS00000 is EPSILON EQUIPMENT SUPPLY .
Ph=6456445643 Key: GIB00000 is GIBRALTER LIFE INSURANCE .
Ph=6456445643 Key: JOH00000 is JOHNSON BOATING SUPPLIES .
Ph=6546456333 Key: H&J00000 is H & J PLUMBING SUPPLIES  .
Ph=6554456433 Key: LEW00000 is LEWISTON GRAPHICS LTD.   .
Ph=7456434355 Key: KON00000 is KONFLAB PLASTIC PRODUCTS..
Ph=7534587453 Key: NEW00000 is NEW WAVE SURF SHOPS INC. .
Ph=8009329492 Key: FOR00000 is FORTUNE COOKIE COMPANY   .
Ph=8372487274 Key: GAM00000 is GAMMA X-RAY TECHNOLOGY   .
Ph=8787458374 Key: OLD00000 is OLD TYME PIZZA MFG. CO.  .
Hit End of File
Test Read/Delete
 Delete: INC00000 random
 Delete: ALP00000 random
   Read: BET00000 4169898509
 Delete: PRE00000 random
Expected 10 after delete PRE00000
Initial: BET00000 4169898509
Initial: DEL00000 4169898509
Initial: MOR00000 4169898509
Initial: EPS00000 5292398745
  Start: BET00000 4169898509
   Next: DEL00000 4169898509
 Delete: DEL00000 sequential
   Next: MOR00000 4169898509
   Next: EPS00000 5292398745
 Delete: EPS00000 sequential
List sample data file by Phone
Ph=4169898509 Key: BET00000 is BETA SHOE MFG. INC.      .
Ph=4169898509 Key: MOR00000 is MORNINGSIDE CARPENTRY.   .
Ph=6456445643 Key: GIB00000 is GIBRALTER LIFE INSURANCE .
Ph=6456445643 Key: JOH00000 is JOHNSON BOATING SUPPLIES .
Ph=6546456333 Key: H&J00000 is H & J PLUMBING SUPPLIES  .
Ph=6554456433 Key: LEW00000 is LEWISTON GRAPHICS LTD.   .
Ph=7456434355 Key: KON00000 is KONFLAB PLASTIC PRODUCTS..
Ph=7534587453 Key: NEW00000 is NEW WAVE SURF SHOPS INC. .
Ph=8009329492 Key: FOR00000 is FORTUNE COOKIE COMPANY   .
Ph=8372487274 Key: GAM00000 is GAMMA X-RAY TECHNOLOGY   .
Ph=8787458374 Key: OLD00000 is OLD TYME PIZZA MFG. CO.  .
Hit End of File
List sample data file by Phone
Ph=3131234432 Key: ALP00000 is ALPHA ELECTRICAL CO. LTD..
Ph=3455445444 Key: INC00000 is INCREMENTAL BACKUP CORP. .
Ph=4169898509 Key: BET00000 is BETA SHOE MFG. INC.      .
Ph=4169898509 Key: DEL00000 is DELTA LUGGAGE REPAIRS    .
Ph=4169898509 Key: MOR00000 is MORNINGSIDE CARPENTRY.   .
Ph=4169898509 Key: PRE00000 is PRESTIGE OFFICE FURNITURE.
Ph=5292398745 Key: EPS00000 is EPSILON EQUIPMENT SUPPLY .
Ph=6456445643 Key: GIB00000 is GIBRALTER LIFE INSURANCE .
Ph=6456445643 Key: JOH00000 is JOHNSON BOATING SUPPLIES .
Ph=6546456333 Key: H&J00000 is H & J PLUMBING SUPPLIES  .
Ph=6554456433 Key: LEW00000 is LEWISTON GRAPHICS LTD.   .
Ph=7456434355 Key: KON00000 is KONFLAB PLASTIC PRODUCTS..
Ph=7534587453 Key: NEW00000 is NEW WAVE SURF SHOPS INC. .
Ph=8009329492 Key: FOR00000 is FORTUNE COOKIE COMPANY   .
Ph=8372487274 Key: GAM00000 is GAMMA X-RAY TECHNOLOGY   .
Ph=8787458374 Key: OLD00000 is OLD TYME PIZZA MFG. CO.  .
Hit End of File
Read Prev/Delete
00001 Initial: PRE00000 4169898509
00002 Initial: MOR00000 4169898509
00003 Initial: DEL00000 4169898509
00004 Initial: BET00000 4169898509
  Start: PRE00000 4169898509
   Prev: MOR00000 4169898509
 Delete: MOR00000 sequential
   Prev: DEL00000 4169898509
   Prev: BET00000 4169898509
 Delete: BET00000 sequential
List sample data file by Phone
Ph=3131234432 Key: ALP00000 is ALPHA ELECTRICAL CO. LTD..
Ph=3455445444 Key: INC00000 is INCREMENTAL BACKUP CORP. .
Ph=4169898509 Key: DEL00000 is DELTA LUGGAGE REPAIRS    .
Ph=4169898509 Key: PRE00000 is PRESTIGE OFFICE FURNITURE.
Ph=5292398745 Key: EPS00000 is EPSILON EQUIPMENT SUPPLY .
Ph=6456445643 Key: GIB00000 is GIBRALTER LIFE INSURANCE .
Ph=6456445643 Key: JOH00000 is JOHNSON BOATING SUPPLIES .
Ph=6546456333 Key: H&J00000 is H & J PLUMBING SUPPLIES  .
Ph=6554456433 Key: LEW00000 is LEWISTON GRAPHICS LTD.   .
Ph=7456434355 Key: KON00000 is KONFLAB PLASTIC PRODUCTS..
Ph=7534587453 Key: NEW00000 is NEW WAVE SURF SHOPS INC. .
Ph=8009329492 Key: FOR00000 is FORTUNE COOKIE COMPANY   .
Ph=8372487274 Key: GAM00000 is GAMMA X-RAY TECHNOLOGY   .
Ph=8787458374 Key: OLD00000 is OLD TYME PIZZA MFG. CO.  .
Hit End of File
])

AT_CHECK([diff reference prog.out], [0], [], [])

AT_CHECK([$COMPILE -fcallfh=EXTFH -o extfh prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./extfh 1>prog.out], [0], [], [])

AT_CHECK([diff reference prog.out], [0], [], [])

AT_CLEANUP


AT_SETUP([TURN EC-I-O])
AT_KEYWORDS([runfile directive])

AT_XFAIL_IF([true])
# FIXME: FUNCTION EXCEPTION-STATUS should be empty when an EC occurs but has been
#   >>TURN'd off.

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.

       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT OPTIONAL f ASSIGN "out.txt"
               SEQUENTIAL
               FILE STATUS f-status.

           SELECT g ASSIGN "out.txt"
               SEQUENTIAL.

       DATA DIVISION.
       FILE SECTION.
       FD  f.
       01  f-rec PIC X.

       FD  g.
       01  g-rec PIC X.

       WORKING-STORAGE SECTION.
       01  f-status PIC XX.

       PROCEDURE DIVISION.
           OPEN OUTPUT f
           WRITE f-rec FROM "a"
           CLOSE f

           SET LAST EXCEPTION TO OFF
           >>TURN EC-I-O CHECKING ON
           *> Read f too many times without libcob error
           OPEN INPUT f
           PERFORM 2 TIMES
               READ f
               DISPLAY f-rec
           END-PERFORM

           DISPLAY f-status
           DISPLAY FUNCTION TRIM(FUNCTION EXCEPTION-STATUS)
           SET LAST EXCEPTION TO OFF

           CLOSE f

           >>TURN EC-I-O g CHECKING ON

           *> Read f too many times without libcob error
           OPEN INPUT f
           PERFORM 2 TIMES
               READ f
               DISPLAY f-rec
           END-PERFORM

           DISPLAY f-status
           DISPLAY FUNCTION TRIM(FUNCTION EXCEPTION-STATUS)
           SET LAST EXCEPTION TO OFF

           CLOSE f

           *> Read g too many times with libcob error
           OPEN INPUT g
           PERFORM 2 TIMES
               READ g
               DISPLAY g-rec
           END-PERFORM

           CLOSE g
           .
])

AT_CHECK([$COMPILE prog.cob ], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [1],
[a
a
10

a
a
10

a
],
[libcob: prog.cob:61: error: end of file (status = 10) for file g ('out.txt') on READ
libcob: prog.cob:61: warning: implicit CLOSE of g ('out.txt')
])

AT_CLEANUP


AT_SETUP([LINE SEQUENTIAL REWRITE])
AT_KEYWORDS([runfile COB_SYNC READ WRITE])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.

       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.

       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT FLATFILE ASSIGN EXTERNAL SEQFIX
           ORGANIZATION LINE SEQUENTIAL
           FILE STATUS IS CUST-STAT .

       DATA  DIVISION.
       FILE SECTION.
       FD  FLATFILE
           BLOCK CONTAINS 5 RECORDS.

       01  TSPFL-RECORD.
           10  CM-CUST-NUM                     PICTURE X(8).
           10  CM-COMPANY                      PICTURE X(25).
           10  CM-DISK                         PICTURE X(8).
           10  CM-NO-TERMINALS                 PICTURE 9(5).
           10  CM-PK-DATE                      PICTURE S9(14).
           10  CM-TRAILER                      PICTURE X(52).

       WORKING-STORAGE SECTION.

       78  MAX-SUB           VALUE  6.
       77  CUST-STAT                           PICTURE X(2).

       01  TEST-DATA.

         02  DATA-CUST-NUM-TBL.

           05  FILLER PIC X(8) VALUE "ALP00000".
           05  FILLER PIC X(8) VALUE "BET00000".
           05  FILLER PIC X(8) VALUE "GAM00000".
           05  FILLER PIC X(8) VALUE "DEL00000".
           05  FILLER PIC X(8) VALUE "EPS00000".
           05  FILLER PIC X(8) VALUE "FOR00000".

         02  DATA-CUST-NUM REDEFINES DATA-CUST-NUM-TBL
                                       PIC X(8) OCCURS MAX-SUB.
         02  DATA-COMPANY-TBL.

           05  FILLER PIC X(25) VALUE "ALPHA ELECTRICAL CO. LTD.".
           05  FILLER PIC X(25) VALUE "BETA SHOE MFG. INC.      ".
           05  FILLER PIC X(25) VALUE "GAMMA X-RAY TECHNOLOGY   ".
           05  FILLER PIC X(25) VALUE "DELTA LUGGAGE REPAIRS    ".
           05  FILLER PIC X(25) VALUE "EPSILON EQUIPMENT SUPPLY ".
           05  FILLER PIC X(25) VALUE "FORTUNE COOKIE COMPANY   ".
         02  DATA-COMPANY  REDEFINES DATA-COMPANY-TBL
                                       PIC X(25) OCCURS MAX-SUB.
         02  DATA-ADDRESS-2-TBL.

           05  FILLER PIC X(10) VALUE "NEW YORK  ".
           05  FILLER PIC X(10) VALUE "ATLANTA   ".
           05  FILLER PIC X(10) VALUE "WASHINGTON".
           05  FILLER PIC X(10) VALUE "TORONTO   ".
           05  FILLER PIC X(10) VALUE "CALGARY   ".
           05  FILLER PIC X(10) VALUE "WHITEPLAIN".

         02  DATA-ADDRESS   REDEFINES DATA-ADDRESS-2-TBL
                                       PIC X(10) OCCURS MAX-SUB.

         02  DATA-NO-TERMINALS-TBL.

           05  FILLER PIC 9(5) VALUE 8240.
           05  FILLER PIC 9(5) VALUE 10.
           05  FILLER PIC 9(5) VALUE 13.
           05  FILLER PIC 9(5) VALUE 65535.
           05  FILLER PIC 9(5) VALUE 10.
           05  FILLER PIC 9(5) VALUE 254.

         02  DATA-NO-TERMINALS REDEFINES DATA-NO-TERMINALS-TBL
                                       PIC 9(5) OCCURS MAX-SUB.
       01  WORK-AREA.
           05  SUB                     USAGE BINARY-SHORT UNSIGNED.
               88  ODD-RECORD          VALUE 1 3 5.


       PROCEDURE DIVISION.

           PERFORM LOADFILE.
           OPEN INPUT FLATFILE.
           DISPLAY "Open Sts:" CUST-STAT
           PERFORM READ-RECORD
           PERFORM READ-RECORD
           PERFORM READ-RECORD
           PERFORM READ-RECORD
           CLOSE FLATFILE.

           OPEN I-O FLATFILE.
           PERFORM READ-RECORD
           MOVE 10 TO CM-NO-TERMINALS
           MOVE "STUFF" TO CM-TRAILER
           REWRITE TSPFL-RECORD
           DISPLAY "REWRITE " CM-CUST-NUM " Sts " CUST-STAT
                   " Trms:" CM-NO-TERMINALS.
           CLOSE FLATFILE.

           OPEN I-O FLATFILE.
           PERFORM READ-RECORD
           PERFORM READ-RECORD
           ADD 1 TO CM-NO-TERMINALS
           REWRITE TSPFL-RECORD
           DISPLAY "REWRITE " CM-CUST-NUM " Sts " CUST-STAT
                   " Trms:" CM-NO-TERMINALS.
           PERFORM READ-RECORD
           CLOSE FLATFILE.

           OPEN I-O FLATFILE.
           READ FLATFILE
           READ FLATFILE
           READ FLATFILE
           READ FLATFILE
           READ FLATFILE
           DISPLAY "Read " CM-CUST-NUM " Sts:" CUST-STAT.
           MOVE 8240 TO CM-NO-TERMINALS
           REWRITE TSPFL-RECORD
           DISPLAY "REWRITE " CM-CUST-NUM " Sts " CUST-STAT
                   " Trms:" CM-NO-TERMINALS.
           CLOSE FLATFILE.

           OPEN INPUT FLATFILE.
           DISPLAY "List back Open Sts:" CUST-STAT
           PERFORM UNTIL CUST-STAT NOT = "00"
             PERFORM READ-RECORD
           END-PERFORM.
           CLOSE FLATFILE.

           OPEN EXTEND FLATFILE.
           PERFORM LOAD-RECORD
                        VARYING SUB FROM 1 BY 1
                          UNTIL SUB > 2
           CLOSE FLATFILE.

           OPEN INPUT FLATFILE.
           DISPLAY "List after extend Open Sts:" CUST-STAT
           PERFORM UNTIL CUST-STAT NOT = "00"
             PERFORM READ-RECORD
           END-PERFORM.
           CLOSE FLATFILE.
           STOP RUN RETURNING 0.

       READ-RECORD.
           MOVE SPACES                       TO TSPFL-RECORD.
           READ FLATFILE
           IF CUST-STAT NOT = "00"
             DISPLAY "Read Status: " CUST-STAT
           ELSE
             DISPLAY "Read  " CM-CUST-NUM
                     " Trms:" CM-NO-TERMINALS
           END-IF.

       LOADFILE.
           DISPLAY "Loading sample program data file."
                            UPON CONSOLE.

           OPEN OUTPUT FLATFILE.

           PERFORM LOAD-RECORD
                        VARYING SUB FROM 1 BY 1
                          UNTIL SUB > MAX-SUB.

           DISPLAY "Sample program data file load complete."
                            UPON CONSOLE.
           CLOSE FLATFILE.

       LOAD-RECORD.

           MOVE SPACES                       TO TSPFL-RECORD.
           MOVE DATA-CUST-NUM      (SUB)     TO CM-CUST-NUM.
           MOVE DATA-COMPANY       (SUB)     TO CM-COMPANY.
           MOVE DATA-NO-TERMINALS  (SUB)     TO CM-NO-TERMINALS.
           MOVE 20070319                     TO CM-PK-DATE.
           IF SUB = 5
              MOVE "Freddy Kruger"  TO CM-TRAILER.
           IF SUB = 1 OR 4 OR 6
               MOVE -20070319                 TO CM-PK-DATE.

           IF  ODD-RECORD
               MOVE "8417"                   TO CM-DISK
           ELSE
               MOVE "8470"                   TO CM-DISK.
           WRITE TSPFL-RECORD.
           IF CUST-STAT NOT = "00"
               DISPLAY "Write Error " CUST-STAT.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[Loading sample program data file.
Sample program data file load complete.
Open Sts:00
Read  ALP00000 Trms:08240
Read  BET00000 Trms:00010
Read  GAM00000 Trms:00013
Read  DEL00000 Trms:65535
Read  ALP00000 Trms:08240
REWRITE ALP00000 Sts 44 Trms:00010
Read  ALP00000 Trms:08240
Read  BET00000 Trms:00010
REWRITE BET00000 Sts 00 Trms:00011
Read  GAM00000 Trms:00013
Read EPS00000 Sts:00
REWRITE EPS00000 Sts 00 Trms:08240
List back Open Sts:00
Read  ALP00000 Trms:08240
Read  BET00000 Trms:00011
Read  GAM00000 Trms:00013
Read  DEL00000 Trms:65535
Read  EPS00000 Trms:08240
Read  FOR00000 Trms:00254
Read Status: 10
List after extend Open Sts:00
Read  ALP00000 Trms:08240
Read  BET00000 Trms:00011
Read  GAM00000 Trms:00013
Read  DEL00000 Trms:65535
Read  EPS00000 Trms:08240
Read  FOR00000 Trms:00254
Read  ALP00000 Trms:08240
Read  BET00000 Trms:00010
Read Status: 10
], [])

# recheck with COB_SYNC to cover additional code paths
AT_CHECK([COB_SYNC=Y $COBCRUN_DIRECT ./prog], [0],
[Loading sample program data file.
Sample program data file load complete.
Open Sts:00
Read  ALP00000 Trms:08240
Read  BET00000 Trms:00010
Read  GAM00000 Trms:00013
Read  DEL00000 Trms:65535
Read  ALP00000 Trms:08240
REWRITE ALP00000 Sts 44 Trms:00010
Read  ALP00000 Trms:08240
Read  BET00000 Trms:00010
REWRITE BET00000 Sts 00 Trms:00011
Read  GAM00000 Trms:00013
Read EPS00000 Sts:00
REWRITE EPS00000 Sts 00 Trms:08240
List back Open Sts:00
Read  ALP00000 Trms:08240
Read  BET00000 Trms:00011
Read  GAM00000 Trms:00013
Read  DEL00000 Trms:65535
Read  EPS00000 Trms:08240
Read  FOR00000 Trms:00254
Read Status: 10
List after extend Open Sts:00
Read  ALP00000 Trms:08240
Read  BET00000 Trms:00011
Read  GAM00000 Trms:00013
Read  DEL00000 Trms:65535
Read  EPS00000 Trms:08240
Read  FOR00000 Trms:00254
Read  ALP00000 Trms:08240
Read  BET00000 Trms:00010
Read Status: 10
], [])

AT_CLEANUP


AT_SETUP([LINE SEQUENTIAL data])
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.

       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.

       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT FLATFILE ASSIGN "LS-TEST"
           ORGANIZATION LINE SEQUENTIAL
           FILE STATUS IS CUST-STAT .

       DATA  DIVISION.
       FILE SECTION.
       FD  FLATFILE
           BLOCK CONTAINS 5 RECORDS.

       01  TSPFL-RECORD.
           10  CM-CUST-NUM                     PICTURE X(8).
           10  CM-TYPE                         PICTURE X.
           10  CM-COMPANY                      PICTURE X(25).
           10  CM-DISK                         PICTURE X(8).
           10  CM-NO-TERMINALS                 PICTURE 9(4) COMP-4.
           10  CM-PK-DATE                      PICTURE S9(14) COMP-3.

       WORKING-STORAGE SECTION.

       78  MAX-SUB           VALUE  4.
       77  CUST-STAT                           PICTURE X(2).

       01  TEST-DATA.

         02  DATA-CUST-NUM-TBL.
           05  FILLER PIC X(8) VALUE "ALP00000".
           05  FILLER PIC X(8) VALUE "BET00000".
           05  FILLER PIC X(8) VALUE "GAM00000".
           05  FILLER PIC X(8) VALUE "DEL00000".

         02  DATA-CUST-NUM REDEFINES DATA-CUST-NUM-TBL
                                       PIC X(8) OCCURS MAX-SUB.
         02  DATA-COMPANY-TBL.
           05  FILLER PIC X(25) VALUE "ALPHA ELECTRICAL CO. LTD.".
           05  FILLER PIC X(25) VALUE "BETA SHOE MFG. INC.      ".
           05  FILLER PIC X(25) VALUE "GAMMA X-RAY TECHNOLOGY   ".
           05  FILLER PIC X(25) VALUE "DELTA LUGGAGE REPAIRS    ".
         02  DATA-COMPANY  REDEFINES DATA-COMPANY-TBL
                                       PIC X(25) OCCURS MAX-SUB.
         02  DATA-ADDRESS-2-TBL.
           05  FILLER PIC X(10) VALUE "NEW YORK  ".
           05  FILLER PIC X(10) VALUE "ATLANTA   ".
           05  FILLER PIC X(10) VALUE "WASHINGTON".
           05  FILLER PIC X(10) VALUE "TORONTO   ".
         02  DATA-ADDRESS   REDEFINES DATA-ADDRESS-2-TBL
                                       PIC X(10) OCCURS MAX-SUB.

         02  DATA-NO-TERMINALS-TBL.
           05  FILLER PIC 9(3) VALUE 10.
           05  FILLER PIC 9(3) VALUE 13.
           05  FILLER PIC 9(3) VALUE 3.
           05  FILLER PIC 9(3) VALUE 254.
         02  DATA-NO-TERMINALS REDEFINES DATA-NO-TERMINALS-TBL
                                       PIC 9(3) OCCURS MAX-SUB.
       01  WORK-AREA.
           05  SUB                             BINARY-SHORT UNSIGNED.
               88  ODD-RECORD                  VALUE 1 3 5.

       PROCEDURE DIVISION.
      * Load file using MF rules
           SET ENVIRONMENT "COB_LS_VALIDATE" TO "FALSE"
           SET ENVIRONMENT "COB_LS_NULLS"    TO "TRUE"
           DISPLAY "MF Load data"
           PERFORM LOADFILE.

      * Read file using MF rules
           OPEN INPUT FLATFILE.
           DISPLAY "MF Open Sts: " CUST-STAT
           PERFORM UNTIL CUST-STAT NOT = "00"
               PERFORM READ-RECORD
           END-PERFORM.
           CLOSE FLATFILE.

      * Read file using Std rules
           SET ENVIRONMENT "COB_LS_VALIDATE" TO "true"
           SET ENVIRONMENT "COB_LS_NULLS"    TO "false"
           OPEN INPUT FLATFILE.
           DISPLAY "Std Open Sts: " CUST-STAT
           PERFORM UNTIL CUST-STAT NOT = "00"
               PERFORM READ-RECORD
           END-PERFORM.
           CLOSE FLATFILE.

      * Load file using Std rules
           DISPLAY "Std Load data"
           PERFORM LOADFILE.

           STOP RUN RETURNING 0.

       READ-RECORD.
      *    MOVE SPACES                       TO TSPFL-RECORD.
           READ FLATFILE
           IF CUST-STAT NOT = "00"
             DISPLAY "Read Status: " CUST-STAT
           ELSE
             DISPLAY "Read  " CM-CUST-NUM
                     " Trms:" CM-NO-TERMINALS
           END-IF.

       LOADFILE.
           OPEN OUTPUT FLATFILE.
           PERFORM LOAD-RECORD
                        VARYING SUB FROM 1 BY 1
                          UNTIL SUB > MAX-SUB
                              OR CUST-STAT NOT = "00".
           CLOSE FLATFILE.

       LOAD-RECORD.
           MOVE SPACES                       TO TSPFL-RECORD.
           MOVE DATA-CUST-NUM      (SUB)     TO CM-CUST-NUM.
           MOVE DATA-COMPANY       (SUB)     TO CM-COMPANY.
           MOVE DATA-NO-TERMINALS  (SUB)     TO CM-NO-TERMINALS.
           MOVE 20070319                     TO CM-PK-DATE.
           IF SUB = 1 OR 4 OR 6
               MOVE -20070319                 TO CM-PK-DATE.

           IF  ODD-RECORD
               MOVE "8417"                   TO CM-DISK
           ELSE
               MOVE "8470"                   TO CM-DISK.
           WRITE TSPFL-RECORD.
           IF CUST-STAT NOT = "00"
               DISPLAY "Error status " CUST-STAT " writing record "
                       DATA-CUST-NUM (SUB).
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[MF Load data
MF Open Sts: 00
Read  ALP00000 Trms:0010
Read  BET00000 Trms:0013
Read  GAM00000 Trms:0003
Read  DEL00000 Trms:0254
Read Status: 10
Std Open Sts: 00
Read Status: 09
Std Load data
Error status 71 writing record ALP00000
], [])

AT_CLEANUP


AT_SETUP([Concatenated Files])
AT_KEYWORDS([runfile status])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT FLATFILE
           ASSIGN TO THE-FILE-NAME
           ORGANIZATION LINE SEQUENTIAL
           FILE STATUS IS FLAT-STAT.

       DATA  DIVISION.
       FILE SECTION.
       FD  FLATFILE.
       01  FLAT-RECORD.
           10  FILE-NAME                       PICTURE X(8).
           10  FLAT-MARK                       PICTURE X(6).
           10  FLAT-RECNUM                     PICTURE X(6).
           10  FLAT-NUM                        PICTURE Z9.
           10  FLAT-FILLER                     PICTURE X(2).

       WORKING-STORAGE SECTION.
       77  REC-NUM           VALUE  0          BINARY-SHORT UNSIGNED.
       78  MAX-REC           VALUE  3.
       77  FLAT-STAT                           PICTURE X(2).
       77  THE-FILE-NAME                       PICTURE X(48).

       PROCEDURE DIVISION.
           MOVE "file1" TO THE-FILE-NAME
           PERFORM LOADFILE.

           MOVE "file2" TO THE-FILE-NAME
           PERFORM LOADFILE.

           MOVE "file3" TO THE-FILE-NAME
           PERFORM LOADFILE.

           MOVE "file1+file2+file3" TO THE-FILE-NAME
           PERFORM UPDTFILE.

           SET ENVIRONMENT "COB_SEQ_CONCAT_SEP" TO "&"
           MOVE "file1&file2&file3" TO THE-FILE-NAME
           PERFORM LISTFILE.
           STOP RUN RETURNING 0.

       LISTFILE.
           OPEN INPUT FLATFILE.
           IF FLAT-STAT NOT = "00"
               DISPLAY "OPEN INPUT: " THE-FILE-NAME " Sts:" FLAT-STAT
           END-IF.
           PERFORM UNTIL FLAT-STAT NOT = "00"
               PERFORM READ-RECORD
           END-PERFORM.
           CLOSE FLATFILE.

       UPDTFILE.
           OPEN I-O FLATFILE.
           IF FLAT-STAT NOT = "00"
               DISPLAY "OPEN I-O: " THE-FILE-NAME " Sts:" FLAT-STAT
           END-IF.
           PERFORM VARYING REC-NUM FROM 1 BY 1
                      UNTIL FLAT-STAT NOT = "00"
               MOVE SPACES          TO FLAT-RECORD
               READ FLATFILE
               IF REC-NUM = 5
                  MOVE "Hello" TO FLAT-MARK
                  REWRITE FLAT-RECORD
                  IF FLAT-STAT NOT = "00"
                     DISPLAY "REWRITE5: " THE-FILE-NAME "Sts:" FLAT-STAT
                  END-IF
               END-IF
               IF REC-NUM = 7
                  MOVE "$$" TO FLAT-FILLER
                  REWRITE FLAT-RECORD
                  IF FLAT-STAT NOT = "44"
      *  Cannot change size of LINE SEQ record
                     DISPLAY "REWRITE7: " THE-FILE-NAME "Sts:" FLAT-STAT
                  END-IF
               END-IF
           END-PERFORM.
           CLOSE FLATFILE.

       READ-RECORD.
      *    MOVE SPACES                       TO FLAT-RECORD.
           READ FLATFILE
           IF FLAT-STAT NOT = "00"
               IF FLAT-STAT NOT = "10"
                   DISPLAY "Read Status: " FLAT-STAT
               END-IF
           ELSE
               DISPLAY FLAT-RECORD "."
           END-IF.

       LOADFILE.
           OPEN OUTPUT FLATFILE.
           IF FLAT-STAT NOT = "00"
               DISPLAY "OPEN OUTPUT: " THE-FILE-NAME " Sts:" FLAT-STAT
           END-IF.
           PERFORM LOAD-RECORD VARYING REC-NUM FROM 1 BY 1
                                 UNTIL REC-NUM > MAX-REC.
           CLOSE FLATFILE.

       LOAD-RECORD.
           MOVE SPACES                       TO FLAT-RECORD.
           MOVE "Record"                     TO FLAT-RECNUM.
           MOVE THE-FILE-NAME                TO FILE-NAME.
           MOVE REC-NUM                      TO FLAT-NUM.
           WRITE FLAT-RECORD.
           IF FLAT-STAT NOT = "00"
               DISPLAY "Write: " FILE-NAME " Rec#" REC-NUM
                       " Sts:" FLAT-STAT
           END-IF.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[OPEN I-O: file1+file2+file3                                Sts:35
OPEN INPUT: file1&file2&file3                                Sts:35
], [])

AT_CHECK([COB_SEQ_CONCAT_NAME=true $COBCRUN_DIRECT ./prog], [0],
[file1         Record 1  .
file1         Record 2  .
file1         Record 3  .
file2         Record 1  .
file2   Hello Record 2  .
file2         Record 3  .
file3         Record 1  .
file3         Record 2  .
file3         Record 3  .
], [])

AT_CLEANUP


## SORT/MERGE Module
## (should stay last here as it uses io functions tested above)


AT_SETUP([File SORT, SEQUENTIAL])
AT_KEYWORDS([runfile SORT USING GIVING])

# Note: We shouldn't use AT_DATA to create sequential record
# data, because AT_DATA needs a \n at the end

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT SORT-IN   ASSIGN "test.txt".
       SELECT SORT-OUT  ASSIGN "result.txt".
       SELECT SORT-WRK  ASSIGN "SORT-WRK".
       DATA             DIVISION.
       FILE             SECTION.
       FD SORT-IN.
       01 IN-REC        PIC X(6).
       FD SORT-OUT.
       01 OUT-REC       PIC X(6).
       SD SORT-WRK.
       01 WRK-REC       PIC X(6).
       PROCEDURE        DIVISION.

      * Special case: write test data in COBOL, see note above
           OPEN OUTPUT SORT-IN.
           WRITE IN-REC FROM SPACES   END-WRITE.
           WRITE IN-REC FROM SPACES   END-WRITE.
           WRITE IN-REC FROM "world " END-WRITE.
           WRITE IN-REC FROM SPACES   END-WRITE.
           WRITE IN-REC FROM "hello " END-WRITE.
           WRITE IN-REC FROM SPACES   END-WRITE.
           WRITE IN-REC FROM SPACES   END-WRITE.
           CLOSE SORT-IN.

           SORT SORT-WRK
                ASCENDING KEY WRK-REC
                USING  SORT-IN
                GIVING SORT-OUT.
             STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([cat result.txt], [0], [                              hello world ], [])

AT_CLEANUP


AT_SETUP([File SORT, SEQUENTIAL variable records])
AT_KEYWORDS([runfile SORT USING GIVING])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
       SELECT file1 ORGANIZATION SEQUENTIAL
                    ASSIGN "./file1".
       SELECT file2 ORGANIZATION SEQUENTIAL
                    ASSIGN "./file2".
       SELECT file3 ASSIGN DISK.
       DATA DIVISION.
       FILE SECTION.
       FD file1 RECORD VARYING FROM 3 TO 12 DEPENDING rsz.
       1  file1-rec pic x(12).
       FD file2 RECORD VARYING FROM 3 TO 12 DEPENDING rsz.
       1  file2-rec pic x(12).
       SD file3 RECORD VARYING FROM 3 TO 12 DEPENDING rsz.
       1  file3-rec.
          2  file3-key1 pic x.
          2  file3-key2 pic 9.
          2  filler pic x(10).
       WORKING-STORAGE SECTION.
       77 rsz pic 99.
       1  1-data.
          2  filler pic x(14) VALUE "03A4X".
          2  filler pic x(14) VALUE "04A3XX".
          2  filler pic x(14) VALUE "05A2XXX".
          2  filler pic x(14) VALUE "06A1XXXX".
          2  filler pic x(14) VALUE "07A0XXXXX".
          2  filler pic x(14) VALUE "08B2XXXXXX".
          2  filler pic x(14) VALUE "09B1XXXXXXX".
          2  filler pic x(14) VALUE "10C2XXXXXXXX".
          2  filler pic x(14) VALUE "11C1XXXXXXXXX".
          2  filler pic x(14) VALUE "12Z9XXXXXXXXXX".
      *
       1  filler redefines 1-data.
          2  filler occurs 10 times indexed by ix-1.
           3 1-rsz pic 99.
           3 1-rec pic x(12).

       PROCEDURE DIVISION.
          OPEN OUTPUT file1.
          PERFORM VARYING ix-1 FROM 1 BY 2 UNTIL ix-1 > 10
             MOVE 1-rsz(ix-1) TO rsz
             MOVE 1-rec(ix-1) TO file1-rec
             WRITE file1-rec
          END-PERFORM.
          PERFORM VARYING ix-1 FROM 2 BY 2 UNTIL ix-1 > 10
             MOVE 1-rsz(ix-1) TO rsz
             MOVE 1-rec(ix-1) TO file1-rec
             WRITE file1-rec
          END-PERFORM.
          CLOSE file1.
          SORT file3 ON ASCENDING file3-key1
                        DESCENDING file3-key2
             USING file1
             GIVING file2.
          OPEN INPUT file2.
          PERFORM VARYING ix-1 FROM 1 BY 1 UNTIL ix-1 > 10
             READ file2
      *>> fileio-sort currently returns constant length records
             MOVE 1-rsz(ix-1) TO rsz
      *>> END-OF-DETOUR
             IF (1-rsz(ix-1) <> rsz)
                DISPLAY "FAILED Test " ix-1 ": "
                        1-rsz(ix-1) " <> " rsz
             END-IF
             IF (1-rec(ix-1) <> file2-rec)
                DISPLAY "FAILED Test " ix-1 ": " 
                        1-rec(ix-1) " <> " file2-rec
             END-IF
          END-PERFORM.
          CLOSE file2.
          STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([File SORT, LINE SEQUENTIAL])
AT_KEYWORDS([runfile SORT USING GIVING])

# Note: We shouldn't use AT_DATA to create sequential record
# data, because AT_DATA needs a \n at the end

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT SORT-IN   ASSIGN "test.txt"
                        ORGANISATION LINE SEQUENTIAL.
       SELECT SORT-OUT  ASSIGN "result.txt"
                        ORGANISATION LINE SEQUENTIAL.
       SELECT SORT-WRK  ASSIGN "SORT-WRK".
       DATA             DIVISION.
       FILE             SECTION.
       FD SORT-IN.
       01 IN-REC        PIC X(20).
       FD SORT-OUT.
       01 OUT-REC       PIC X(20).
       SD SORT-WRK.
       01 WRK-REC       PIC X(6).
       PROCEDURE        DIVISION.

      * Special case: write test data in COBOL, see note above
           OPEN OUTPUT SORT-IN.
           WRITE IN-REC FROM SPACES   END-WRITE.
           WRITE IN-REC FROM SPACES   END-WRITE.
           WRITE IN-REC FROM "world " END-WRITE.
           WRITE IN-REC FROM SPACES   END-WRITE.
           WRITE IN-REC FROM "hello " END-WRITE.
           WRITE IN-REC FROM SPACES   END-WRITE.
           WRITE IN-REC FROM SPACES   END-WRITE.
           CLOSE SORT-IN.

           SORT SORT-WRK
                ASCENDING KEY WRK-REC
                USING  SORT-IN
                GIVING SORT-OUT.
             STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([cat result.txt], [0], [




hello
world
], [])

AT_CLEANUP


AT_SETUP([File SORT, LINE SEQUENTIAL same file])
AT_KEYWORDS([runfile SORT USING GIVING])

AT_DATA([test.txt], [
bla
world
hello

blubb
])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT SORT-IN   ASSIGN "test.txt"
                        ORGANISATION LINE SEQUENTIAL.
       SELECT SORT-WRK  ASSIGN "dummy".
       DATA             DIVISION.
       FILE             SECTION.
       FD SORT-IN.
       01 IN-REC        PIC X(6).
       SD SORT-WRK.
       01 sort-entry    PIC X(6).
       PROCEDURE        DIVISION.
           SORT SORT-WRK
                ASCENDING sort-entry
                USING  SORT-IN
                GIVING SORT-IN.
             STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([cat test.txt], [0], [

bla
blubb
hello
world
], [])

AT_CLEANUP


AT_SETUP([File SORT, LINE SEQUENTIAL variable records])
AT_KEYWORDS([runfile SORT USING GIVING])

AT_DATA([file1],
[A1XXXX
A2XXX
A3XX
Z9XXXXXXXXXX
A4X
B1XXXXXXX
B2XXXXXX
A0XXXXX
C1XXXXXXXXX
C2XXXXXXXX
])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
       SELECT file1 ORGANIZATION LINE SEQUENTIAL
                    ASSIGN "./file1".
       SELECT file2 ORGANIZATION LINE SEQUENTIAL
                    ASSIGN "./file2".
       SELECT file3 ASSIGN DISK.
       DATA DIVISION.
       FILE SECTION.
       FD file1.
       1  file1-rec pic x(12).
       FD file2.
       1  file2-rec pic x(12).
       SD file3.
       1  file3-rec.
          2  file3-key1 pic x.
          2  file3-key2 pic 9.
          2  filler pic x(10).
       PROCEDURE DIVISION.
          SORT file3 ON ASCENDING file3-key1
                        DESCENDING file3-key2
             USING file1
             GIVING file2.
          STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([cat file2], [0],
[A4X
A3XX
A2XXX
A1XXXX
A0XXXXX
B2XXXXXX
B1XXXXXXX
C2XXXXXXXX
C1XXXXXXXXX
Z9XXXXXXXXXX
])

AT_CLEANUP


AT_SETUP([EXTFH: File SORT, LINE SEQUENTIAL variable records])
AT_KEYWORDS([runfile SORT USING GIVING EXTFH])

# same test as above, but this time using an external file handler
# which in this case is the internal EXTFH handler

AT_DATA([file1],
[A1XXXX
A2XXX
A3XX
Z9XXXXXXXXXX
A4X
B1XXXXXXX
B2XXXXXX
A0XXXXX
C1XXXXXXXXX
C2XXXXXXXX
])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
       SELECT file1 ORGANIZATION LINE SEQUENTIAL
                    ASSIGN "./file1".
       SELECT file2 ORGANIZATION LINE SEQUENTIAL
                    ASSIGN "./file2".
       SELECT file3 ASSIGN DISK.
       DATA DIVISION.
       FILE SECTION.
       FD file1.
       1  file1-rec pic x(12).
       FD file2.
       1  file2-rec pic x(12).
       SD file3.
       1  file3-rec.
          2  file3-key1 pic x.
          2  file3-key2 pic 9.
          2  filler pic x(10).
       PROCEDURE DIVISION.
          SORT file3 ON ASCENDING file3-key1
                        DESCENDING file3-key2
             USING file1
             GIVING file2.
          STOP RUN.
])

AT_CHECK([$COMPILE -fcallfh=EXTFH prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([cat file2], [0],
[A4X
A3XX
A2XXX
A1XXXX
A0XXXXX
B2XXXXXX
B1XXXXXXX
C2XXXXXXXX
C1XXXXXXXXX
Z9XXXXXXXXXX
])

AT_CLEANUP


AT_SETUP([File MERGE, LINE SEQUENTIAL variable records])
AT_KEYWORDS([runfile])

AT_DATA([file1],
[A1XXXX
A2XXX
A3XX
Z9XXXXXXXXXX
A4X
B1XXXXXXX
B2XXXXXX
A0XXXXX
C1XXXXXXXXX
C2XXXXXXXX
])

AT_DATA([file2],
[A1****
A2***
A3**
Z9**********
A4*
B1*******
B2******
A0*****
C1*********
C2********
])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
       SELECT file1 ORGANIZATION LINE SEQUENTIAL
                    ASSIGN "./file1".
       SELECT file2 ORGANIZATION LINE SEQUENTIAL
                    ASSIGN "./file2".
       SELECT file3 ORGANIZATION LINE SEQUENTIAL
                    ASSIGN "./file3".
       SELECT file4 ASSIGN DISK.
       DATA DIVISION.
       FILE SECTION.
       FD file1.
       1  file1-rec pic x(12).
       FD file2.
       1  file2-rec pic x(12).
       FD file3.
       1  file3-rec pic x(12).
       SD file4.
       1  file4-rec.
          2  file4-key1 pic x.
          2  file4-key2 pic 9.
          2  filler pic x(10).
       PROCEDURE DIVISION.
          MERGE file4 ON ASCENDING file4-key1
                        DESCENDING file4-key2
             USING file1 file2
             GIVING file3.
          STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([cat file3], [0],
[A4X
A4*
A3XX
A3**
A2XXX
A2***
A1XXXX
A1****
A0XXXXX
A0*****
B2XXXXXX
B2******
B1XXXXXXX
B1*******
C2XXXXXXXX
C2********
C1XXXXXXXXX
C1*********
Z9XXXXXXXXXX
Z9**********
])

AT_CLEANUP


AT_SETUP([SORT nonexistent file])
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT SORT-IN   ASSIGN "SORT-IN".
       SELECT SORT-OUT  ASSIGN "SORT-OUT".
       SELECT SORT-WRK  ASSIGN "SORT-WRK".
       DATA             DIVISION.
       FILE             SECTION.
       FD SORT-IN.
       01 IN-REC        PIC X(100).
       FD SORT-OUT.
       01 OUT-REC       PIC X(100).
       SD SORT-WRK.
       01 WRK-REC       PIC X(100).
       PROCEDURE        DIVISION.
           SORT SORT-WRK
                ASCENDING KEY WRK-REC
                USING  SORT-IN
                GIVING SORT-OUT.
             STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([cat SORT-OUT], [0], [], [])

AT_CLEANUP


AT_SETUP([SORT with INPUT/OUTPUT PROCEDUREs])
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
       SELECT file1 ASSIGN DISK.
       DATA DIVISION.
       FILE SECTION.
       SD file1.
       1  file1-rec.
          2  file1-key pic 9(4).
          2  file1-data pic x(10).
       WORKING-STORAGE SECTION.
       77 w-eof pic 9 value 0.
       1  1-values.
          2  filler pic x(14) value "0001A--------A".
          2  filler pic x(14) value "0002B--------B".
          2  filler pic x(14) value "0003C--------C".
          2  filler pic x(14) value "0004D--------D".
          2  filler pic x(14) value "0005E--------E".
          2  filler pic x(14) value "0006F--------F".
          2  filler pic x(14) value "0007G--------G".
          2  filler pic x(14) value "0008H--------H".
          2  filler pic x(14) value "0009I--------I".
          2  filler pic x(14) value "0010J--------J".
          2  filler pic x(14) value "0011K--------K".
          2  filler pic x(14) value "0012L--------L".
          2  filler pic x(14) value "0013M--------M".
          2  filler pic x(14) value "0014N--------N".
          2  filler pic x(14) value "0015O--------O".
          2  filler pic x(14) value "0016P--------P".
          2  filler pic x(14) value "0017Q--------Q".
          2  filler pic x(14) value "0018R--------R".
          2  filler pic x(14) value "0019S--------S".
          2  filler pic x(14) value "0020T--------T".
          2  filler pic x(14) value "0021U--------U".
          2  filler pic x(14) value "0022V--------V".
          2  filler pic x(14) value "0023W--------W".
          2  filler pic x(14) value "0024X--------X".
          2  filler pic x(14) value "0025Y--------Y".
          2  filler pic x(14) value "0026Z--------Z".
       1  filler redefines 1-values.
          2  1-record occurs 26 times indexed by ix-1.
           3 1-key pic 9(4).
           3 1-data pic x(10).
       PROCEDURE DIVISION.
       a01-main.
          SORT file1 ON ASCENDING file1-key
             INPUT PROCEDURE a02-release-to-sort
             OUTPUT PROCEDURE a03-return-from-sort.
          STOP RUN.
      *
       a02-release-to-sort.
          PERFORM VARYING ix-1 FROM 1 BY 2 UNTIL ix-1 > 26
             RELEASE file1-rec from 1-record(ix-1)
          END-PERFORM.
          PERFORM VARYING ix-1 FROM 2 BY 2 UNTIL ix-1 > 26
             RELEASE file1-rec from 1-record(ix-1)
          END-PERFORM.
      *
       a03-return-from-sort.
          PERFORM VARYING ix-1 FROM 1 BY 1
             UNTIL (ix-1 > 26) OR (w-eof = 1)
             RETURN file1 RECORD
               AT END MOVE 1 TO w-eof
             END-RETURN
             IF (file1-rec <> 1-record(ix-1))
                MOVE 1 TO w-eof
             END-IF
          END-PERFORM.
          IF (w-eof = 1)
             DISPLAY "FAILED: unexpected eof"
          ELSE
             RETURN file1 RECORD
               AT END CONTINUE
               NOT AT END DISPLAY "FAILED: expected eof"
             END-RETURN
          END-IF.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([SORT with key1 ASCENDING, key2 DESCENDING])
AT_KEYWORDS([runfile])

AT_DATA([file1],
[A1
A2
A3
Z9
A4
B1
B2
A0
C1
C2
])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
       SELECT file1 ORGANIZATION LINE SEQUENTIAL
                    ASSIGN "./file1".
       SELECT file2 ORGANIZATION LINE SEQUENTIAL
                    ASSIGN "./file2".
       SELECT file3 ASSIGN DISK.
       DATA DIVISION.
       FILE SECTION.
       FD file1.
       1  file1-rec pic xxx.
       FD file2.
       1  file2-rec pic xxx.
       SD file3.
       1  file3-rec.
          2  file3-key1 pic x.
          2  file3-key2 pic 9.
          2  file3-dot pic x.
       PROCEDURE DIVISION.
          SORT file3 ON ASCENDING file3-key1
                        DESCENDING file3-key2
             USING file1
             GIVING file2.
          STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([cat file2], [0],
[A4
A3
A2
A1
A0
B2
B1
C2
C1
Z9
])

AT_CLEANUP


# Verify that FD GLOBAL will create default handlers in sub-programs, but
# only in its own sub-programs

AT_SETUP([Scope of FD GLOBAL in nested programs])
AT_KEYWORDS([file])
AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. NESTED-FILES.
       PROCEDURE DIVISION.
         CALL    "NESTED-PROGRAM-1".
         CALL    "NESTED-PROGRAM-2".
         STOP RUN.

       IDENTIFICATION DIVISION.
       PROGRAM-ID. NESTED-PROGRAM-1.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
         SELECT FILE-EXT ASSIGN "./TEST-FILE" FILE STATUS IS WSFS.
       DATA DIVISION.
       FILE SECTION.
       FD FILE-EXT GLOBAL.
       01 FILE-EXT-REC PIC X(5).
       WORKING-STORAGE SECTION.
       01  WSFS              PIC X(2).
       PROCEDURE DIVISION.
       DECLARATIVES.
       P01 SECTION.
          USE AFTER ERROR PROCEDURE ON FILE-EXT.
       P0101.
          DISPLAY "ERROR ON FILE-EXT".
       P02 SECTION.
          USE AFTER ERROR PROCEDURE ON OUTPUT.
       P0201.
          DISPLAY "ERROR ON OUTPUT".
       END DECLARATIVES.
       MAIN SECTION.
         OPEN OUTPUT FILE-EXT.
         CALL    "NESTED-PROGRAM-1-1".
      * The next line triggers a SILENT error in NESTED-PROGRAM-1-2
         CLOSE FILE-EXT.
         CALL    "NESTED-PROGRAM-1-2".
         GOBACK.

       IDENTIFICATION DIVISION.
       PROGRAM-ID. NESTED-PROGRAM-1-1.
       PROCEDURE DIVISION.
         NESTED-PROGRAM .
         WRITE FILE-EXT-REC FROM "Hello".
	 DISPLAY "1-1 TRIED TO WRITE".
         GOBACK.
       END PROGRAM NESTED-PROGRAM-1-1.

       IDENTIFICATION DIVISION.
       PROGRAM-ID. NESTED-PROGRAM-1-2.
       PROCEDURE DIVISION.
         NESTED-PROGRAM .
         WRITE FILE-EXT-REC FROM "Hello".
	 DISPLAY "1-2 TRIED TO WRITE".
         GOBACK.
       END PROGRAM NESTED-PROGRAM-1-2.

       END PROGRAM NESTED-PROGRAM-1.

       IDENTIFICATION DIVISION.
       PROGRAM-ID. NESTED-PROGRAM-2.
       PROCEDURE DIVISION.
         GOBACK.
       END PROGRAM NESTED-PROGRAM-2.

       END PROGRAM NESTED-FILES.
])
AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [1-1 TRIED TO WRITE
1-2 TRIED TO WRITE
], [])
AT_DATA([prog2.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. NESTED-FILES.
       PROCEDURE DIVISION.
         CALL    "NESTED-PROGRAM-1".
         CALL    "NESTED-PROGRAM-2".
         STOP RUN.

       IDENTIFICATION DIVISION.
       PROGRAM-ID. NESTED-PROGRAM-1.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
         SELECT FILE-EXT ASSIGN "./TEST-FILE" FILE STATUS IS WSFS.
       DATA DIVISION.
       FILE SECTION.
       FD FILE-EXT GLOBAL.
       01 FILE-EXT-REC PIC X(5).
       WORKING-STORAGE SECTION.
       01  WSFS              PIC X(2).
       PROCEDURE DIVISION.
       DECLARATIVES.
       P01 SECTION.
      * This one is GLOBAL and should be called from within nested programs
          USE GLOBAL AFTER ERROR PROCEDURE ON FILE-EXT.
       P0101.
          DISPLAY "ERROR ON FILE-EXT".
       P02 SECTION.
          USE AFTER ERROR PROCEDURE ON OUTPUT.
       P0201.
          DISPLAY "ERROR ON OUTPUT".
       END DECLARATIVES.
       MAIN SECTION.
         OPEN OUTPUT FILE-EXT.
         CALL    "NESTED-PROGRAM-1-1".
	 DISPLAY "CLOSING FILE DESCRIPTOR".
         CLOSE FILE-EXT.
         CALL    "NESTED-PROGRAM-1-2".
         GOBACK.

       IDENTIFICATION DIVISION.
       PROGRAM-ID. NESTED-PROGRAM-1-1.
       PROCEDURE DIVISION.
         NESTED-PROGRAM .
	 DISPLAY "ENTERING NESTED-PROGRAM-1-1".
	 DISPLAY "TRYING TO WRITE".
         WRITE FILE-EXT-REC FROM "Hello".
	 DISPLAY "EXITING NESTED-PROGRAM-1-1".
         GOBACK.
       END PROGRAM NESTED-PROGRAM-1-1.

       IDENTIFICATION DIVISION.
       PROGRAM-ID. NESTED-PROGRAM-1-2.
       PROCEDURE DIVISION.
         NESTED-PROGRAM .
	 DISPLAY "ENTERING NESTED-PROGRAM-1-2".
	 DISPLAY "TRYING TO WRITE".
         WRITE FILE-EXT-REC FROM "Hello".
	 DISPLAY "EXITING NESTED-PROGRAM-1-2".
         GOBACK.
       END PROGRAM NESTED-PROGRAM-1-2.

       END PROGRAM NESTED-PROGRAM-1.

       IDENTIFICATION DIVISION.
       PROGRAM-ID. NESTED-PROGRAM-2.
       PROCEDURE DIVISION.
         GOBACK.
       END PROGRAM NESTED-PROGRAM-2.

       END PROGRAM NESTED-FILES.
])
AT_CHECK([$COMPILE prog2.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog2], [0], [ENTERING NESTED-PROGRAM-1-1
TRYING TO WRITE
EXITING NESTED-PROGRAM-1-1
CLOSING FILE DESCRIPTOR
ENTERING NESTED-PROGRAM-1-2
TRYING TO WRITE
ERROR ON FILE-EXT
EXITING NESTED-PROGRAM-1-2
], [])
AT_CLEANUP

AT_SETUP([OPEN / CLOSE with multiple filenames])
AT_KEYWORDS([DECLARATIVES file error])

AT_DATA([prog1.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. DOUBLE-OPEN.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
          SELECT FILE1 ASSIGN TO "./file1.txt"
            FILE STATUS STAT-FILE1.
          SELECT FILE2 ASSIGN TO "./file2.txt"
            FILE STATUS STAT-FILE2.
       DATA DIVISION.
       FILE SECTION.
       FD FILE1.
         01 FS-FILE1 PIC X(10).
       FD FILE2.
         01 FS-FILE2 PIC X(10).
       WORKING-STORAGE SECTION.
	 01  STAT-FILE1               PIC XX.
	 01  STAT-FILE2               PIC XX.
       PROCEDURE DIVISION.
       DECLARATIVES.
       F-FILE1 SECTION. USE AFTER ERROR PROCEDURE ON FILE1.
       DEB-FILE1.
         DISPLAY "ERROR ON FILE1".
          DISPLAY "  STAT-FILE1: " STAT-FILE1.
          DISPLAY "  STAT-FILE2: " STAT-FILE2.
       F-FILE2 SECTION. USE AFTER ERROR PROCEDURE ON FILE2.
       DEB-FILE2.
         DISPLAY "ERROR ON FILE2".
         DISPLAY "  STAT-FILE1: " STAT-FILE1.
         DISPLAY "  STAT-FILE2: " STAT-FILE2.
       END DECLARATIVES.
       PROGRAMME SECTION.
       MAIN.
          OPEN INPUT FILE1
	  OPEN INPUT FILE2.
          DISPLAY "READ FILE1".
          READ FILE1.
          DISPLAY "READ FILE2".
          READ FILE2.
          DISPLAY "CLOSE FILES".
          CLOSE FILE1.
          CLOSE FILE2.
          DISPLAY "DELETE FILES".
          DELETE FILE FILE1.
          DELETE FILE FILE2.
          STOP RUN.
])
AT_DATA([prog2.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. DOUBLE-OPEN.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
          SELECT FILE1 ASSIGN TO "./file1.txt"
            FILE STATUS STAT-FILE1.
          SELECT FILE2 ASSIGN TO "./file2.txt"
            FILE STATUS STAT-FILE2.
       DATA DIVISION.
       FILE SECTION.
       FD FILE1.
         01 FS-FILE1 PIC X(10).
       FD FILE2.
         01 FS-FILE2 PIC X(10).
       WORKING-STORAGE SECTION.
	 01  STAT-FILE1               PIC XX.
	 01  STAT-FILE2               PIC XX.
       PROCEDURE DIVISION.
       DECLARATIVES.
       F-FILE1 SECTION. USE AFTER ERROR PROCEDURE ON FILE1.
       DEB-FILE1.
         DISPLAY "ERROR ON FILE1".
          DISPLAY "  STAT-FILE1: " STAT-FILE1.
          DISPLAY "  STAT-FILE2: " STAT-FILE2.
       F-FILE2 SECTION. USE AFTER ERROR PROCEDURE ON FILE2.
       DEB-FILE2.
         DISPLAY "ERROR ON FILE2".
         DISPLAY "  STAT-FILE1: " STAT-FILE1.
         DISPLAY "  STAT-FILE2: " STAT-FILE2.
       END DECLARATIVES.
       PROGRAMME SECTION.
       MAIN.
          OPEN INPUT FILE1
	             FILE2.
          DISPLAY "READ FILE1".
          READ FILE1.
          DISPLAY "READ FILE2".
          READ FILE2.
          DISPLAY "CLOSE FILES".
          CLOSE FILE1
                FILE2.
          DISPLAY "DELETE FILES".
          DELETE FILE FILE1
                      FILE2.
          STOP RUN.
])

AT_DATA([expected.txt],
[ERROR ON FILE2
  STAT-FILE1: 00
  STAT-FILE2: 35
READ FILE1
ERROR ON FILE1
  STAT-FILE1: 10
  STAT-FILE2: 35
READ FILE2
ERROR ON FILE2
  STAT-FILE1: 10
  STAT-FILE2: 47
CLOSE FILES
ERROR ON FILE2
  STAT-FILE1: 00
  STAT-FILE2: 42
DELETE FILES
])

AT_CHECK([$COMPILE prog1.cob])
AT_DATA([file1.txt], [])
AT_CHECK([$COBCRUN_DIRECT ./prog1 > prog1.txt])
AT_CHECK([diff expected.txt prog1.txt])

AT_CHECK([$COMPILE prog2.cob])
AT_DATA([file1.txt], [])
AT_CHECK([$COBCRUN_DIRECT ./prog2 > prog2.txt])
AT_CHECK([diff expected.txt prog2.txt])

AT_CLEANUP
