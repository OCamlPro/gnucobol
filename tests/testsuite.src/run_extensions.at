## Copyright (C) 2003-2012, 2014-2022 Free Software Foundation, Inc.
## Written by Keisuke Nishida, Roger While, Simon Sobisch, Edward Hart,
## Ron Norman
##
## This file is part of GnuCOBOL.
##
## The GnuCOBOL compiler is free software: you can redistribute it
## and/or modify it under the terms of the GNU General Public License
## as published by the Free Software Foundation, either version 3 of the
## License, or (at your option) any later version.
##
## GnuCOBOL is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with GnuCOBOL.  If not, see <https://www.gnu.org/licenses/>.

### GnuCOBOL Test Suite

### Non-standard extensions


AT_SETUP([CALL BY CONTENT binary and literal])
AT_KEYWORDS([extensions literals])

AT_DATA([dump.c], [
#include <stdio.h>
#include <libcob.h>

COB_EXT_EXPORT int
dump (unsigned char *data, int *p)
{
  int i;
  if ( *p == 1 ) {
     for (i = 0; i < 4; i++)
       printf ("%02x", data[[i]]);
  } else {
       printf ("%8.8d", *((int *)data));
  }
  puts ("");
  return 0;
}
])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01 X-1           PIC 9(9) VALUE 4660 COMP.
       01 X-2           PIC 9(9) VALUE 4660 COMP-5.
       PROCEDURE        DIVISION.
           CALL "dump" USING X-1 BY CONTENT 1
           END-CALL.
           CALL "dump" USING X-2 BY CONTENT 2
           END-CALL.
           STOP RUN.
])

AT_CHECK([$COMPILE_MODULE dump.c], [0], [], [])
AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[00001234
00004660
])

AT_CLEANUP


AT_SETUP([Numeric Boolean literals])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01 X-1           PIC 9(2)  VALUE B"010101".
       01 X-2           PIC 9(20) VALUE B"111111111111111111111111111111
      -                                  "111111111111111111111111111111
      -                                  "1111".
       PROCEDURE        DIVISION.
           DISPLAY X-1
           END-DISPLAY.
           DISPLAY X-2
           END-DISPLAY.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[21
18446744073709551615
])

AT_CLEANUP


AT_SETUP([ACUCOBOL literals])
AT_KEYWORDS([extensions acu binary octal hexadecimal])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       PROCEDURE        DIVISION.
           DISPLAY B#101 UPON STDOUT
           DISPLAY O#17777777777 UPON STDOUT
           DISPLAY X#ffFFFFff UPON STDOUT
           DISPLAY H#ffFFFFff UPON STDOUT

           STOP RUN.
])

AT_CHECK([$COMPILE -facu-literals=ok prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[5
2147483647
4294967295
4294967295
])

AT_CLEANUP


AT_SETUP([HP COBOL octal literals])
AT_KEYWORDS([extensions])

# FIXME: the type of octal literals must be context-sensitive, see below
# currently hard-wired as numeric (may be switched in scanner.l to alphanumeric)

AT_XFAIL_IF(true)

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
      *>   Octal literal is "AB" in ASCII.
       01  ITEM-ALPHA     PIC XX        VALUE %40502.
      *>   Octal literal is 39.
       01  ITEM-NUMERIC   PIC 99 BINARY VALUE %47.
      *>   Octal literal is ASCII 12.
       01  ITEM-NUM       PIC 99        VALUE %30462.
       PROCEDURE        DIVISION.
      *>   Octal literal is "XY".
           DISPLAY %54131.
           IF ITEM-ALPHA NOT = "AB"
              DISPLAY "VALUE %40502 is not ""AB"" (ASCII) but "
                      ITEM-ALPHA
           END-IF
           IF ITEM-NUMERIC NOT = 39
              DISPLAY "VALUE %47 BINARY is not 39 but " ITEM-NUMERIC
           END-IF
           IF ITEM-NUM NOT = 12
              DISPLAY "VALUE %30462 is not 12 (ASCII) but " ITEM-NUM
           END-IF
      *>   Adds octal 23 (decimal 19, as it is an arithmetic expression).
           ADD %23 TO ITEM-NUM.
           IF ITEM-NUM NOT = 31
              DISPLAY "12 + %23 (19) is not 31 but " ITEM-NUM
           END-IF
      *>   Sets the data to octal 30462 (ASCII 12).
           MOVE %30462 TO ITEM-NUM
           IF ITEM-NUM NOT = 12
              DISPLAY "%30462 is not 12 (ASCII) but " ITEM-NUM
           END-IF
      *>   Sets the data to x'4100' (octal 101 -> ASCII A + right-pad NULL)
           MOVE %101 TO ITEM-ALPHA
           IF ITEM-ALPHA NOT = x"4100"
              DISPLAY "%101 is not x""4100"" = Anull (ASCII) but "
                      ITEM-ALPHA
           END-IF


           STOP RUN.
])

AT_CHECK([$COMPILE -fhp-octal-literals=ok prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[XY
])

AT_CLEANUP


AT_SETUP([Hexadecimal numeric literals]) # FIXME: needs a dialect configuration
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01 X-1           PIC 9(8) VALUE H"012345".
       01 X-2           PIC 9(8) VALUE H"FFFFFF".
       PROCEDURE        DIVISION.
           DISPLAY X-1
           END-DISPLAY.
           DISPLAY X-2
           END-DISPLAY.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[00074565
16777215
])

AT_CLEANUP


## Expression

AT_SETUP([Semi-parenthesized condition])
AT_KEYWORDS([extensions]) # Shouldn't this be in run_fundamentals?

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       PROCEDURE        DIVISION.
           IF 1 = (1 OR 2)
             DISPLAY "OK" NO ADVANCING
             END-DISPLAY
           END-IF.
           STOP RUN.
])

AT_CHECK([$COMPILE -Wno-constant-expression prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [OK], [])

AT_CLEANUP


AT_SETUP([ADDRESS OF]) # Shouldn't this be in run_fundamentals?
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01 X-1           PIC X(3) VALUE "X-1".
       01 X-2           PIC X(3) VALUE "X-2".
       01 G.
         02 PTR-1       USAGE POINTER VALUE NULL.
         02 PTR-2       USAGE POINTER VALUE NULL.
       LINKAGE          SECTION.
       01 Y             PIC X(3).
       PROCEDURE        DIVISION.
         SET ADDRESS OF Y TO ADDRESS OF X-1.
         IF Y NOT = "X-1"
            DISPLAY "Test 1 " Y
            END-DISPLAY
         END-IF.
         SET PTR-1 TO ADDRESS OF X-2.
         SET PTR-2 TO PTR-1
         SET ADDRESS OF Y TO PTR-2.
         IF Y NOT = "X-2"
            DISPLAY "Test 2 " Y
            END-DISPLAY
         END-IF
         INITIALIZE PTR-1.
         IF PTR-1 NOT = NULL
           DISPLAY "NG 1"
           END-DISPLAY
         END-IF.
         SET ADDRESS OF Y TO NULL.
         IF PTR-1 NOT = ADDRESS OF Y
           DISPLAY "NG 2"
           END-DISPLAY
         END-IF.
         IF ADDRESS OF Y NOT = PTR-1
           DISPLAY "NG 3"
           END-DISPLAY
         END-IF.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([LENGTH OF])
AT_KEYWORDS([extensions VALUE RENAMES])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01 X             PIC X(2).
       01 G.
         02 Y           PIC X(2) OCCURS 10.
         02 G-GROUP.
         03 G-SGROUP.
         04 G1          PIC X(05).
         04 G2          PIC X(06).
         04 G3          PIC X(22).
         03 FILLER      PIC XX OCCURS 5.
       66 RENAME-STD-G  RENAMES G-GROUP.
       66 RENAME-STD-SG RENAMES G-SGROUP.
       66 RENAME-STD    RENAMES G1 THROUGH G3.
       66 RENAME-G      RENAMES G.
       01 L             PIC s9(4)v99.
       01 I             PIC 9(2) VALUE 10.
       78 I-LEN         VALUE LENGTH OF I.
      * TODO: check size of FILLER here
       01 TSTDISP.
         02 FILLER OCCURS 5000.
           10 T1        PIC X(11).
           10 T2        PIC X(22).
       78 var-length-l      value length of '00128'.
       78 var-length-x      value length of x'a0'.
       78 var-length-z      value length of z'a0'.
      *78 var-length-n      value length of n'001'.
       PROCEDURE        DIVISION.
           move var-length-l TO L
           IF L NOT = 5
              DISPLAY "Length '00128'" L
              END-DISPLAY
           END-IF
           move var-length-x TO L
           IF L NOT = 1
              DISPLAY "Length x'a0'" L
              END-DISPLAY
           END-IF
           move var-length-z TO L
           IF L NOT = 3
              DISPLAY "Length z'a0'" L
              END-DISPLAY
           END-IF
      *    What does MF reports here?
      *>   move var-length-n TO L
      *>   IF L NOT = 3
      *>      DISPLAY "Length n'001'" L
      *>      END-DISPLAY
      *>   END-IF
           MOVE LENGTH OF X  TO L
           IF L NOT = 2
              DISPLAY "Length 1 " L
              END-DISPLAY
           END-IF
           MOVE LENGTH OF X  TO L
           IF L NOT = 2
              DISPLAY "Length 1a " L LENGTH X
              END-DISPLAY
           END-IF
           MOVE LENGTH OF Y  TO L
           IF L NOT = 2
              DISPLAY "Length 2 " L
              END-DISPLAY
           END-IF
           IF L NOT = 2
              DISPLAY "Length 2a " L LENGTH OF Y
              END-DISPLAY
           END-IF
           MOVE LENGTH OF Y(1) TO L
           IF L NOT = 2
              DISPLAY "Length 3 " L
              END-DISPLAY
           END-IF
           MOVE LENGTH Y(1) TO L
           IF L NOT = 2
              DISPLAY "Length 3a " L LENGTH OF Y(1)
              END-DISPLAY
           END-IF
           IF I-LEN NOT = 2
              DISPLAY "Length 4 " I-LEN
              END-DISPLAY
           END-IF
           IF LENGTH OF L + 2 NOT = 8
              ADD 2 TO LENGTH OF L GIVING L
              DISPLAY "Length 5 + 2" L
              END-DISPLAY
           END-IF
           IF LENGTH L + 2 NOT = 8
              ADD 2 TO LENGTH L GIVING L
              DISPLAY "Length 5a + 2 " L
              END-DISPLAY
           END-IF
           MOVE 0 TO L
           PERFORM LENGTH OF L TIMES
              ADD 1 TO L
           END-PERFORM
           PERFORM LENGTH L TIMES
              ADD 1 TO L
           END-PERFORM
           IF L NOT = 12
              DISPLAY "Length 6 " L
              END-DISPLAY
           END-IF
           MOVE 0 TO L
           PERFORM VARME
                   VARYING I FROM LENGTH OF I
                             BY   LENGTH OF X
                   UNTIL   I > LENGTH OF L
           IF ((L NOT = 3) OR
               (I NOT = 8)    )
              DISPLAY "Length 7 " L " - " I
              END-DISPLAY
           END-IF
           MOVE 0 TO L
           PERFORM VARME
                   VARYING I FROM LENGTH I
                             BY   LENGTH X
                   UNTIL   I > LENGTH L
           IF ((L NOT = 3) OR
               (I NOT = 8)    )
              DISPLAY "Length 7a " L " - " I
              END-DISPLAY
           END-IF
           MOVE LENGTH OF RENAME-STD-SG  TO L
           IF L NOT = 33
              DISPLAY "Length 8a " L
              END-DISPLAY
           END-IF
           MOVE LENGTH OF RENAME-STD-G  TO L
           IF L NOT = 43
              DISPLAY "Length 8b " L
              END-DISPLAY
           END-IF
           MOVE LENGTH OF RENAME-STD  TO L
           IF L NOT = 33
              DISPLAY "Length 8c " L
              END-DISPLAY
           END-IF
           MOVE LENGTH OF RENAME-G  TO L
           IF L NOT = 63
              DISPLAY "Length 8d " L
              END-DISPLAY
           END-IF
           *> one display test
           DISPLAY LENGTH OF TSTDISP WITH NO ADVANCING
           END-DISPLAY
           STOP RUN.
       VARME.
           ADD 1 TO L
           .
])

AT_CHECK([$COMPILE -Wno-constant-expression prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [165000], [])

AT_CLEANUP


AT_SETUP([SET TO SIZE OF])
AT_KEYWORDS([extensions acu LENGTH])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       DATA  DIVISION.
       WORKING-STORAGE SECTION.
       01  TST    PIC X(10) VALUE "abcdefghij".
       01  TST2.
           05  FILLER OCCURS 5000.
               10 T2-1    PIC X(11).
               10 T2-2    PIC X(22).
       01  LN     PIC 9(06).

       PROCEDURE DIVISION.
           SET LN TO SIZE OF TST
           IF LN NOT = 10
              DISPLAY "SIZE OF TST is " LN UPON SYSERR
              END-DISPLAY
           END-IF
           SET LN TO SIZE OF TST2
           IF LN NOT = 165000
              DISPLAY "SIZE OF TST2 is " LN UPON SYSERR
              END-DISPLAY
           END-IF
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob ], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([WHEN-COMPILED])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01 X             PIC X(20).
       PROCEDURE        DIVISION.
           MOVE WHEN-COMPILED TO X.
           INSPECT X CONVERTING "0123456789" TO "9999999999".
           IF X NOT = "99/99/9999.99.99    "
              CALL 'CBL_OC_DUMP' USING X
                 ON EXCEPTION
                    DISPLAY X NO ADVANCING
                    END-DISPLAY
              END-CALL
           END-IF
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP

## OCCURS

AT_SETUP([Complex OCCURS DEPENDING ON (1)])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01 I PIC 9.
       01 G-1 VALUE "123456789".
         02 G-2.
           03 X   PIC X OCCURS 1 TO 3 DEPENDING ON I.
         02 G-3.
           03 G-4.
             04 X PIC X OCCURS 1 TO 3 DEPENDING ON I.
           03 G-5.
             04 X PIC X OCCURS 1 TO 3 DEPENDING ON I.
       PROCEDURE        DIVISION.
           MOVE 2 TO I.
           DISPLAY G-1 ":" G-4 ":" G-5 NO ADVANCING
           .
])

AT_CHECK([$COMPILE -std=mvs prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [123456:34:56])

AT_CLEANUP


AT_SETUP([Complex OCCURS DEPENDING ON (2)])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  I            PIC 99.
       01  J            PIC 99.
       01  K            PIC 99.
       01  VLEN         PIC 99.
       01  VTOP.
           03 VGROUP.
             05  VX     OCCURS 1 TO 5 DEPENDING ON I.
               10 VXX   PIC X(1).
             05  VY     OCCURS 1 TO 5 DEPENDING ON J.
               10 VYY   PIC X(2).
             05 ZZ      OCCURS 1 TO 5 DEPENDING ON K.
               10 VZZ   PIC X(3).
       PROCEDURE        DIVISION.
           MOVE    1      TO I.
           MOVE    1      TO J.
           MOVE    1      TO K.
           MOVE    '1'    TO VXX (1).
           MOVE    '22'   TO VYY (1).
           MOVE    '333'  TO VZZ (1).
           MOVE    LENGTH OF VGROUP         TO VLEN.
           DISPLAY VLEN   NO ADVANCING
           END-DISPLAY.
           MOVE    FUNCTION LENGTH (VGROUP) TO VLEN.
           DISPLAY VLEN   NO ADVANCING
           END-DISPLAY.
           DISPLAY VGROUP
           END-DISPLAY.
           INITIALIZE     VTOP.
           MOVE    3      TO I.
           MOVE    2      TO J.
           MOVE    1      TO K.
           MOVE    '3'    TO VXX (3).
           MOVE    '22'   TO VYY (2).
           MOVE    '111'  TO VZZ (1).
           MOVE    LENGTH OF VGROUP         TO VLEN.
           DISPLAY VLEN   NO ADVANCING
           END-DISPLAY.
           MOVE    FUNCTION LENGTH (VGROUP) TO VLEN.
           DISPLAY VLEN   NO ADVANCING
           END-DISPLAY.
           DISPLAY VGROUP
           END-DISPLAY.
           STOP RUN.
])

AT_CHECK([$COMPILE -std=mf prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[18181    22        333
1818  3    22      111
])

AT_CLEANUP


AT_SETUP([Complex OCCURS DEPENDING ON (3)])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  I            PIC 99.
       01  J            PIC 99.
       01  K            PIC 99.
       01  VLEN         PIC 99.
       01  VTOP.
           03 VGROUP.
             05  VX     OCCURS 1 TO 5 DEPENDING ON I.
               10 VXX   PIC X(1).
             05  VY     OCCURS 1 TO 5 DEPENDING ON J.
               10 VYY   PIC X(2).
             05 ZZ      OCCURS 1 TO 5 DEPENDING ON K.
               10 VZZ   PIC X(3).
       PROCEDURE        DIVISION.
           MOVE    1      TO I.
           MOVE    1      TO J.
           MOVE    1      TO K.
           MOVE    '1'    TO VXX (1).
           MOVE    '22'   TO VYY (1).
           MOVE    '333'  TO VZZ (1).
           MOVE    LENGTH OF VGROUP         TO VLEN.
           DISPLAY VLEN   NO ADVANCING
           END-DISPLAY.
           MOVE    FUNCTION LENGTH (VGROUP) TO VLEN.
           DISPLAY VLEN   NO ADVANCING
           END-DISPLAY.
           DISPLAY VGROUP
           END-DISPLAY.
           INITIALIZE     VTOP.
           MOVE    3      TO I.
           MOVE    2      TO J.
           MOVE    1      TO K.
           MOVE    '3'    TO VXX (3).
           MOVE    '22'   TO VYY (2).
           MOVE    '111'  TO VZZ (1).
           MOVE    LENGTH OF VGROUP         TO VLEN.
           DISPLAY VLEN   NO ADVANCING
           END-DISPLAY.
           MOVE    FUNCTION LENGTH (VGROUP) TO VLEN.
           DISPLAY VLEN   NO ADVANCING
           END-DISPLAY.
           DISPLAY VGROUP
           END-DISPLAY.
           STOP RUN.
])

# note: -fodoslide implies -fcomplex-ode
AT_CHECK([$COMPILE -fodoslide prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[0606122333
1010  3  22111
])

AT_CLEANUP


AT_SETUP([Complex OCCURS DEPENDING ON (4)])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  I            PIC 99.
       01  J            PIC 99.
       01  K            PIC 99.
       01  VLEN         PIC 99.
       01  VTOP.
           03 VGROUP.
             05  VX     OCCURS 1 TO 5 DEPENDING ON I.
               10 VXX   PIC X(1).
             05  VY     OCCURS 1 TO 5 DEPENDING ON J.
               10 VYY   PIC X(2).
             05 ZZ      OCCURS 1 TO 5 DEPENDING ON K.
               10 VZZ   PIC X(3).
             05  VFIX   PIC X(3).
       PROCEDURE        DIVISION.
           MOVE    1      TO I.
           MOVE    1      TO J.
           MOVE    1      TO K.
           MOVE    '1'    TO VXX (1).
           MOVE    '22'   TO VYY (1).
           MOVE    '333'  TO VZZ (1).
           MOVE    '444'  TO VFIX.
           MOVE    LENGTH OF VGROUP         TO VLEN.
           DISPLAY VLEN   NO ADVANCING
           END-DISPLAY.
           MOVE    FUNCTION LENGTH (VGROUP) TO VLEN.
           DISPLAY VLEN   NO ADVANCING
           END-DISPLAY.
           DISPLAY VGROUP
           END-DISPLAY.
           INITIALIZE     VTOP.
           MOVE    3      TO I.
           MOVE    2      TO J.
           MOVE    1      TO K.
           MOVE    '3'    TO VXX (3).
           MOVE    '22'   TO VYY (2).
           MOVE    '111'  TO VZZ (1).
           MOVE    '000'  TO VFIX.
           MOVE    LENGTH OF VGROUP         TO VLEN.
           DISPLAY VLEN   NO ADVANCING
           END-DISPLAY.
           MOVE    FUNCTION LENGTH (VGROUP) TO VLEN.
           DISPLAY VLEN   NO ADVANCING
           END-DISPLAY.
           DISPLAY VGROUP
           END-DISPLAY.
           STOP RUN.
])

AT_CHECK([$COMPILE -fcomplex-odo prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[33331    22        333            444
3333  3    22      111            000
])

AT_CLEANUP


AT_SETUP([Complex OCCURS DEPENDING ON (5)])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  I            PIC 99.
       01  J            PIC 99.
       01  K            PIC 99.
       01  VLEN         PIC 99.
       01  VTOP.
           03 VGROUP.
             05  VX     OCCURS 1 TO 5 DEPENDING ON I.
               10 VXX   PIC X(1).
             05  VY     OCCURS 1 TO 5 DEPENDING ON J.
               10 VYY   PIC X(2).
             05 ZZ      OCCURS 1 TO 5 DEPENDING ON K.
               10 VZZ   PIC X(3).
             05  VFIX   PIC X(3).
       PROCEDURE        DIVISION.
           MOVE    1      TO I.
           MOVE    1      TO J.
           MOVE    1      TO K.
           MOVE    '1'    TO VXX (1).
           MOVE    '22'   TO VYY (1).
           MOVE    '333'  TO VZZ (1).
           MOVE    '444'  TO VFIX.
           MOVE    LENGTH OF VGROUP         TO VLEN.
           DISPLAY VLEN   NO ADVANCING
           END-DISPLAY.
           MOVE    FUNCTION LENGTH (VGROUP) TO VLEN.
           DISPLAY VLEN   NO ADVANCING
           END-DISPLAY.
           DISPLAY VGROUP
           END-DISPLAY.
           INITIALIZE     VTOP.
           MOVE    3      TO I.
           MOVE    2      TO J.
           MOVE    1      TO K.
           MOVE    '3'    TO VXX (3).
           MOVE    '22'   TO VYY (2).
           MOVE    '111'  TO VZZ (1).
           MOVE    '000'  TO VFIX.
           MOVE    LENGTH OF VGROUP         TO VLEN.
           DISPLAY VLEN   NO ADVANCING
           END-DISPLAY.
           MOVE    FUNCTION LENGTH (VGROUP) TO VLEN.
           DISPLAY VLEN   NO ADVANCING
           END-DISPLAY.
           DISPLAY VGROUP
           END-DISPLAY.
           STOP RUN.
])

AT_CHECK([$COMPILE -fodoslide prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[0909122333444
1313  3  22111000
])

AT_CLEANUP


AT_SETUP([Complex OCCURS DEPENDING ON (6)])
AT_KEYWORDS([extensions runsubscripts nested subscripts odo odoslide])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  n            PIC 9 VALUE 2.
       01  m            PIC 9 VALUE 3.

       01  a-table      VALUE "ABCDEFGHIJ".
           03  rows     OCCURS 0 TO 2 TIMES
                        DEPENDING ON n.
                05  chars OCCURS 0 TO 5 TIMES
                          DEPENDING ON m
                          PIC X.

       01  vals         PIC X(3).

       PROCEDURE DIVISION.
           MOVE chars (1, 2) TO vals (1:1)
           MOVE chars (2, 1) TO vals (2:1)
           MOVE chars (2, 3) TO vals (3:1)
           IF vals NOT = "BDF"
              DISPLAY "Vals (slided) wrong: " vals
              END-DISPLAY
           END-IF
           IF a-table NOT = "ABCDEF"
              DISPLAY "Table (slided) wrong: " a-table
              END-DISPLAY
           END-IF
           .
])

AT_CHECK([$COMPILE -fodoslide prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([OCCURS UNBOUNDED (1)])
AT_KEYWORDS([extensions runsubscripts subscripts])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID. prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  N            PIC 9(03)  VALUE 123 COMP-5.
       01  P            USAGE POINTER.
       01  SAV          PIC X(8192).
       01  W-TABLE.
           03  WROWS     OCCURS 0 TO 500 TIMES
                        DEPENDING ON N.
               05 WCOL1  PIC 9.
               05 WCOL2  PIC X(02).

       LINKAGE SECTION.
       01  A-TABLE.
           03  ROWS     OCCURS 0 TO UNBOUNDED TIMES
                        DEPENDING ON N.
               05 COL1  PIC X.
               05 COL2  PIC X(02).

       PROCEDURE DIVISION.
           IF FUNCTION LENGTH (W-TABLE) NOT = 369
              DISPLAY 'WRONG WS LENGTH: ' FUNCTION LENGTH (A-TABLE)
              END-DISPLAY
           END-IF
           IF FUNCTION LENGTH (A-TABLE) NOT = 369
              DISPLAY 'WRONG LS LENGTH: ' FUNCTION LENGTH (A-TABLE)
              END-DISPLAY
           END-IF
           ALLOCATE FUNCTION LENGTH (A-TABLE) CHARACTERS
                    INITIALIZED TO ALL "ABCDE"
                    RETURNING P
           SET ADDRESS OF A-TABLE TO P
           IF COL2(1) NOT = "BC"
              DISPLAY "col2(1) wrong: " col2(1)
           END-IF
           IF ROWS(2) NOT = "DEA"
              DISPLAY "rows(2) wrong: " rows(2)
           END-IF
      *
           INITIALIZE W-TABLE
      *
           MOVE A-TABLE TO SAV
           INITIALIZE A-TABLE
      *
           FREE p
           .
])

# note: IBM implies -fodoslide
AT_CHECK([$COBC -x -std=ibm prog.cob], [0], [], [])
AT_CHECK([$COMPILE prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([OCCURS UNBOUNDED (2)])
AT_KEYWORDS([extensions runsubscripts DEPENDING odo subscripts])

# note: the following example is from IBM's Language Reference
#       for Enterprise COBOL for z/OS 6.1, but with fixed use
#       of old-size (+ removing some binary zeros for output)

AT_DATA([ALLOC.cob], [
       ID DIVISION.
        PROGRAM-ID. ALLOC.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
        WORKING-STORAGE SECTION.
        77  X   PIC  9(2) PACKED-DECIMAL.
        77  NUM-ELEMENTS PIC 9(4) BINARY.
        77  SIZE-NEEDED  PIC 9(4) BINARY.
        77  old-size     pic 9(4) binary.
        77  VPTR  POINTER.
        77  VPTR2 POINTER.
        77  VPTR3 POINTER.

        LINKAGE       SECTION.

        01  VARGRP.
          02  OBJ     PIC 9(4) COMP.
          02  TABGRP.
            03  VARTAB OCCURS 1 TO UNBOUNDED DEPENDING ON OBJ.
              04  T1      PIC 9(4).
              04  T2      PIC X(8).
              04  T3      PIC 9(4). *> changed from COMP because of output
        01 BUFFER         PIC X(1000).

       PROCEDURE DIVISION.

      *>    DISPLAY 'Starting testcase ALLOC'

           SET VPTR VPTR2 VPTR3 To NULL

      *************************************************************
      *  Allocate a table with 20 elements
      *************************************************************
           COMPUTE NUM-ELEMENTS = 20
           PERFORM ALLOC-VARGRP

      *************************************************************
      *  Set some 'test' values to validate re-allocated table
      *************************************************************
           initialize vartab(12), vartab(17)
           COMPUTE T1(12) = 9999
           MOVE 'HI MOM' TO T2 (17)
      *>   DISPLAY '  '
           DISPLAY 'VARTAB(12) = "' VARTAB(12) '"'
           DISPLAY 'VARTAB(17) = "' VARTAB(17) '"'
      *>   DISPLAY '  '

      *************************************************************
      *  Need a bigger table! Allocate a larger one and copy data
      *************************************************************
           COMPUTE NUM-ELEMENTS = 30
           PERFORM ALLOC-VARGRP

      *************************************************************
      *  Ensure that new table has correct data from original
      *************************************************************
           DISPLAY 'VARTAB(12) = "' VARTAB(12) '"'
           DISPLAY 'VARTAB(17) = "' VARTAB(17) '"'

           GOBACK.

      *************************************************************
      *  The first time allocate the original table.  If the table
      *  has already been allocated, assume that we are allocating
      *  a larger one and want to copy the data over to it
      *************************************************************
        ALLOC-VARGRP.

           If VPTR = NULL Then      *> If first time, allocate the table
             COMPUTE SIZE-NEEDED = LENGTH OF OBJ +
                                 LENGTH OF VARTAB * NUM-ELEMENTS
             display 'First allocation, using ' size-needed ' bytes.'
             ALLOCATE SIZE-NEEDED CHARACTERS INITIALIZED RETURNING VPTR

             SET ADDRESS OF VARGRP TO VPTR
             MOVE NUM-ELEMENTS TO OBJ

           Else                     *> If already have a table, doing re-size
      *********************************************************************
      * Re-size it!
      * First, allocate space for data save area  and move data in
      *********************************************************************

             ALLOCATE SIZE-NEEDED CHARACTERS INITIALIZED RETURNING VPTR2
             SET ADDRESS OF BUFFER TO VPTR2
             MOVE VARGRP TO BUFFER(1:SIZE-NEEDED)
             inspect BUFFER(1:SIZE-NEEDED) replacing all x'00' by space
             DISPLAY 'BUFFER     = "'
                   BUFFER(170:66) '"'
             DISPLAY 'BUFFER     = "'
                   BUFFER(226:66) '"'
             move size-needed to old-size

      *********************************************************************
      * Calculate new size from NUM-ElEMENTS
      *********************************************************************
             COMPUTE SIZE-NEEDED = LENGTH OF OBJ +
                                   LENGTH OF VARTAB * NUM-ELEMENTS

             display 'Re-allocation, using ' size-needed ' bytes.'
      *>     ALLOCATE SIZE-NEEDED CHARACTERS INITIALIZED RETURNING VPTR3
             if size-needed < 2097152
                ALLOCATE SIZE-NEEDED CHARACTERS INITIALIZED
                                                loc 24
                                                RETURNING VPTR3
             else
                ALLOCATE SIZE-NEEDED CHARACTERS INITIALIZED
                                                loc 31
                                                RETURNING VPTR3
             end-if

      *************************************************************
      * Move data from data save area to new larger table
      *************************************************************
             SET ADDRESS OF VARGRP TO VPTR3
             MOVE NUM-ELEMENTS TO OBJ
             MOVE BUFFER(1:old-size) TO VARGRP
             call 'CBL_OC_DUMP' using VARGRP   *> remove me once all is fine
             (1:size-needed) *> FIXME (from rw-branch), shouldn't be needed
      *************************************************************
      * Free the original table and temp copy
      *************************************************************
             FREE VPTR  VPTR2
             SET VPTR TO VPTR2
             .
])

AT_CHECK([$COMPILE -std=ibm-strict -w ALLOC.cob], [0], [], [])

# compiler limits ODO-item wrong, merge of rw-branch needed
AT_XFAIL_IF(true)

AT_CHECK([$COBCRUN_DIRECT ./ALLOC], [0],
[First allocation, using 00322 bytes.
VARTAB(12) = "9999        0000"
VARTAB(17) = "0000HI MOM  0000"
BUFFER     = "        9999        0000                                "
             "                                0000HI MOM  0000        "
Re-allocation, using 00482 bytes.
VARTAB(12) = "9999        0000"
VARTAB(17) = "0000HI MOM  0000"
], [])

AT_CLEANUP


AT_SETUP([INITIALIZE OCCURS UNBOUNDED])
AT_KEYWORDS([extensions runsubscripts subscripts refmod])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  p            USAGE POINTER.
       01  p2           USAGE POINTER.
       01  dlen         PIC 9(7).

       LINKAGE SECTION.
       01  a-table.
           03  prefix.
               05  n    PIC 9(03)  VALUE 123.
           03  table-data value all "ABCDE".
            04  rows    OCCURS 0 TO UNBOUNDED TIMES
                        DEPENDING ON n.
               05 col1  PIC X.
               05 col2  PIC X(02).

       PROCEDURE DIVISION.
           ALLOCATE LENGTH OF prefix CHARACTERS
                    RETURNING p
           SET ADDRESS OF a-table TO p
           INITIALIZE prefix ALL TO VALUE
           IF FUNCTION LENGTH (a-table) NOT = 372
              DISPLAY 'WRONG LENGTH table: ' FUNCTION LENGTH (a-table)
              END-DISPLAY
           END-IF
           ALLOCATE FUNCTION LENGTH (a-table) CHARACTERS
                    RETURNING p2
           SET ADDRESS OF a-table TO p2
           FREE p

           INITIALIZE prefix ALL TO VALUE

           IF LENGTH OF a-table NOT = 372
              MOVE LENGTH OF a-table TO dlen
              DISPLAY "BAD SIZE: " dlen
           END-DISPLAY

           INITIALIZE table-data (1:FUNCTION LENGTH(rows(1)) * n)
                      ALL TO VALUE
           IF col2(1) NOT = "BC"
              DISPLAY "col2(1) wrong: " col2(1)
              END-DISPLAY
           END-IF
           IF rows(2) NOT = "DEA"
              DISPLAY "rows(2) wrong: " rows(2)
              END-DISPLAY
           END-IF

      *>   check if ref-mod also works as expected
           MOVE ALL ZEROES TO a-table (1: (LENGTH OF a-table))

      *> Test -  should only initialize up to current size, not max:
           INITIALIZE table-data     TO DEFAULT
           INITIALIZE table-data ALL TO VALUE

      *> Test - FUNCTION LENGTH(table-data) must be resolved at run-time
          INITIALIZE table-data (1:FUNCTION LENGTH(table-data))
              ALL TO VALUE
           .
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([INITIALIZE OCCURS ODOSLIDE])
AT_KEYWORDS([extensions runsubscripts subscripts])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  p            USAGE POINTER.
       01  p2           USAGE POINTER.
       01  dlen         PIC 9(7).
       01  grp-0.
           05   FILLER  PIC X(3).
           05   FLD-0.
              10   FLD-0-1 OCCURS 8193 TIMES.
                15   FLD-0-2 PIC XXX VALUE "XYZ".
                15   FLD-0-3 PIC 99  VALUE 12.
                15   FLD-0-4 PIC XX  VALUE "QQ".
           05   FILLER  PIC X(3).
       01  grp-1.
           05   FILLER  PIC X(3).
           05   FLD-1   PIC X(5) VALUE ALL "ABCDE".
           05   FILLER  PIC X(3).
       01  grp-2.
           05   FILLER  PIC X(3).
           05   FLD-2   PIC X(42) VALUE ALL "ABCD ".
           05   FILLER  PIC X(3).
       01  grp-2a.
           05   FILLER  PIC X(3).
           05   FLD-2A  PIC X(8) VALUE ALL "ABC".
           05   FILLER  PIC X(3).
       01  grp-3.
           05   FILLER  PIC X(3).
           05   FLD-3   OCCURS 3 TIMES
                        VALUE ALL "ABC00XX".
                15   FLD-3-2 PIC XXX.
                15   FLD-3-3 PIC 99.
                15   FLD-3-4 PIC XX.
           05   FILLER  PIC X(3).
       01  grp-4.
           05   FILLER  PIC X(3).
           05   FLD-4.
              10   FLD-4-1 OCCURS 11 TIMES.
                15   FLD-4-2 PIC XX  VALUE "AB".
                15   FLD-4-3 PIC 99  VALUE 12.
                15   FLD-4-4 PIC XX  VALUE "YZ".
           05   FILLER  PIC X(3).

       77  C5    PIC 9(03)  VALUE 6.
       01  grp-5.
           05   FILLER  PIC X(3).
           05   FLD-5.
              10   FLD-5-1 OCCURS 0 TO 9 TIMES
                        DEPENDING ON C5.
                15   FLD-5-2 PIC XXX VALUE "Mon".
                15   FLD-5-3 PIC 99  VALUE 49.
                15   FLD-5-4 PIC XX  VALUE "ey".
           05   FILLER  PIC X(3).

       PROCEDURE DIVISION.
           MOVE ALL "*" TO grp-1.
           INITIALIZE FLD-1 ALL TO VALUE.
           DISPLAY "GRP-1:" grp-1.

           MOVE ALL "*" TO grp-2.
           INITIALIZE FLD-2 ALL TO VALUE.
           DISPLAY "GRP-2:" grp-2.

           MOVE ALL "*" TO grp-3.
           INITIALIZE FLD-3 (1) ALL TO VALUE.
           INITIALIZE FLD-3 (2) ALL TO VALUE.
           INITIALIZE FLD-3 (3) ALL TO VALUE.
           DISPLAY "GRP-3:" grp-3.

           MOVE ALL "*" TO grp-4.
           INITIALIZE FLD-4 ALL TO VALUE.
           DISPLAY "GRP-4:" grp-4.

           MOVE 7       TO c5.
           MOVE ALL "*" TO grp-5.
           INITIALIZE FLD-5 ALL TO VALUE.
           DISPLAY "GRP-5:" grp-5.
])

AT_CHECK([$COMPILE -fodoslide prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[GRP-1:***ABCDE***
GRP-2:***ABCD ABCD ABCD ABCD ABCD ABCD ABCD ABCD AB***
GRP-3:***ABC00XXABC00XXABC00XX***
GRP-4:***AB12YZAB12YZAB12YZAB12YZAB12YZAB12YZAB12YZAB12YZAB12YZAB12YZAB12YZ***
GRP-5:***Mon49eyMon49eyMon49eyMon49eyMon49eyMon49eyMon49ey***
], [])

AT_CLEANUP


AT_SETUP([DEPENDING ON with ODOSLIDE])
AT_KEYWORDS([nested ODO])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT FLATFILE
           ASSIGN "SEQODO"
           ORGANIZATION LINE SEQUENTIAL
           FILE STATUS IS CUST-STAT .

       DATA  DIVISION.
       FILE SECTION.
       FD  FLATFILE
           BLOCK CONTAINS 5 RECORDS.

       01  TSTREC.
         05  SEQ           PIC 99.
         05  DEP-X         PIC 99.
         05  DEP-Y         PIC 99.
         05  HELLO         PIC X(5) VALUE 'World'.
         05  TSTGRP.
           10  TSTGRP1.
             15  TSTX OCCURS 1 TO 3 TIMES
                      DEPENDING ON DEP-X.
               20  TSTG-1  PIC Z9.
             15  TSTTAIL1  PIC XXXX.
           10  TSTY-ALL.
             15  TSTY OCCURS 1 TO 3 TIMES
                      DEPENDING ON DEP-X.
               20  TSTY-1  PIC 99.
               20  TSTY-2  PIC XXX.
               20  TSTY-3  PIC X
                             OCCURS 1 TO 12 TIMES
                             DEPENDING ON DEP-Y.
               20  TSTY-4  PIC XX.
               20  TSTY-5    OCCURS 1 TO 3 TIMES
                             DEPENDING ON DEP-X.
                  25  TSTY-6 OCCURS 1 TO 3 TIMES
                             DEPENDING ON DEP-X.
                     30  TSTY-7  PIC X.
           10  TSTTAIL2    PIC XX.

       WORKING-STORAGE SECTION.
       77  CUST-STAT PIC  X(2).
       01  LN        PIC  9(3).
       01  IX        PIC  9(9) BINARY.
       01  IY        PIC  9(9) BINARY.
       01  IZ        PIC  9(9) BINARY.
       01  TSTXXX    PIC  X(26) VALUE "Abcdefghijklmnopqrstuvwxyz".
       01  TSTALPHA REDEFINES TSTXXX.
           05 ALPH-CHR PIC  X OCCURS 26 TIMES.
       01  TSTHEX    PIC  X(15) VALUE "123456789ABCDEF".
       01  FILLER REDEFINES TSTHEX.
           05 HEX-CHR PIC  X OCCURS 15 TIMES.

       01  TSTREC2.
         05  DEP-X2        PIC 99.
         05  TSTGRP2.
             10  TSTX2 OCCURS 1 TO 3 TIMES DEPENDING ON DEP-X2.
               15  TSTG2-1  PIC Z9.
             10  TST2TAIL1  PIC XXX.

       01  TSTREC3.
         05  DEP-X3        PIC 99.
         05  TSTGRP3.
             10  TSTX3 OCCURS 1 TO 6 TIMES DEPENDING ON DEP-X3.
               15  TSTG3-1  PIC 9.
       01  TSTWRK   PIC X(24).

       PROCEDURE DIVISION.
       MAIN-10.
           MOVE 6 TO DEP-X3.
           MOVE 1 TO TSTG3-1 (1).
           MOVE 2 TO TSTG3-1 (2).
           MOVE 3 TO TSTG3-1 (3).
           MOVE 4 TO TSTG3-1 (4).
           MOVE 5 TO TSTG3-1 (5).
           MOVE 6 TO TSTG3-1 (6).
           MOVE 3 TO DEP-X3.
           STRING TSTGRP3 "-TRAILER" DELIMITED BY SIZE
           INTO TSTWRK.
           DISPLAY "'" TSTWRK "'".
           OPEN OUTPUT FLATFILE.
           MOVE "Howdy" TO HELLO.
           MOVE 0 TO SEQ.
           MOVE 2 TO DEP-X.
           MOVE 5 TO DEP-Y.
           PERFORM WRITE-REC.
           MOVE 1 TO DEP-X.
           MOVE 2 TO DEP-Y.
           PERFORM WRITE-REC.
           MOVE 3 TO DEP-X.
           MOVE 3 TO DEP-Y.
           PERFORM WRITE-REC.
           MOVE 3 TO DEP-X.
           MOVE 10 TO DEP-Y.
           PERFORM WRITE-REC.
           CLOSE FLATFILE.
           OPEN INPUT FLATFILE.
           PERFORM READ-REC.
           CLOSE FLATFILE.
           STOP RUN.

       WRITE-REC SECTION.
           ADD 1 TO SEQ.
           MOVE LENGTH OF TSTREC TO LN.
           DISPLAY "Write SEQ " SEQ ", DEP-X = " DEP-X
                   " & DEP-Y = " DEP-Y
                   ", TSTREC len:" LN.
           MOVE ALL "*" TO TSTGRP.
           MOVE "<>"    TO TSTTAIL1, TSTTAIL2.
           PERFORM VARYING IX FROM 1 BY 1
                     UNTIL IX > DEP-X
               MOVE IX TO TSTG-1 (IX)
           END-PERFORM.
           MOVE LENGTH OF TSTGRP1 TO LN.
           DISPLAY "Group1: '" TSTGRP1 "' len:" LN.
           PERFORM VARYING IX FROM 1 BY 1
                     UNTIL IX > DEP-X
               MOVE IX TO TSTY-1 (IX)
               MOVE "." TO TSTY-4 (IX)
               PERFORM VARYING IY FROM 1 BY 1
                         UNTIL IY > DEP-Y
                   MOVE ALPH-CHR (IY) TO TSTY-3 (IX, IY)
               END-PERFORM
           END-PERFORM.
           PERFORM VARYING IX FROM 1 BY 1
                     UNTIL IX > DEP-X
               PERFORM VARYING IY FROM 1 BY 1
                         UNTIL IY > DEP-X
                 PERFORM VARYING IZ FROM 1 BY 1
                           UNTIL IZ > DEP-X
                   MOVE HEX-CHR (IX+IY+IZ) TO TSTY-7 (IX, IY, IZ)
                 END-PERFORM
               END-PERFORM
           END-PERFORM.
           DISPLAY "  Data: '" TSTGRP "'".

           MOVE ALL "*" TO TSTGRP2.
           MOVE DEP-X TO DEP-X2.
           PERFORM VARYING IX FROM 1 BY 1
                     UNTIL IX > DEP-X2
               MOVE IX TO TSTG2-1 (IX)
           END-PERFORM.
           MOVE "<>"    TO TST2TAIL1.
           MOVE LENGTH OF TSTGRP2 TO LN.
           DISPLAY "Group2: '" TSTGRP2 "' len:" LN.
           WRITE TSTREC.

       READ-REC SECTION.
       READ-10.
           READ FLATFILE AT END GO TO READ-99.
           MOVE LENGTH OF TSTREC TO LN.
           DISPLAY "Read SEQ " SEQ ", DEP-X = " DEP-X
                   " & DEP-Y = " DEP-Y
                   ", TSTREC len:" LN.
           DISPLAY "  Data: '" TSTGRP "'".
           GO TO READ-10.
       READ-99.
           EXIT .
])

# FIXME: odo-checks (-debug) must be adjusted, either with -fodoslide or with a possibly new
#        compiler configuration flag as IBM seems to only check against the field-founder's
#        bounds, not the subscript (which is the reason to use "$COBC -x" instead of "$COMPILE")
AT_CHECK([$COBC -x -fodoslide prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
['123-TRAILER             '
Write SEQ 01, DEP-X = 02 & DEP-Y = 05, TSTREC len:053
Group1: ' 1 2<>  ' len:008
  Data: ' 1 2<>  01***Abcde. 344502***Abcde. 4556<>'
Group2: ' 1 2<> ' len:007
Write SEQ 02, DEP-X = 01 & DEP-Y = 02, TSTREC len:029
Group1: ' 1<>  ' len:006
  Data: ' 1<>  01***Ab. 3<>'
Group2: ' 1<> ' len:005
Write SEQ 03, DEP-X = 03 & DEP-Y = 03, TSTREC len:080
Group1: ' 1 2 3<>  ' len:010
  Data: ' 1 2 3<>  01***Abc. 34545656702***Abc. 45656767803***Abc. 567678789<>'
Group2: ' 1 2 3<> ' len:009
Write SEQ 04, DEP-X = 03 & DEP-Y = 10, TSTREC len:101
Group1: ' 1 2 3<>  ' len:010
  Data: ' 1 2 3<>  01***Abcdefghij. 34545656702***Abcdefghij. 45656767803***Abcdefghij. 567678789<>'
Group2: ' 1 2 3<> ' len:009
Read SEQ 01, DEP-X = 02 & DEP-Y = 05, TSTREC len:053
  Data: ' 1 2<>  01***Abcde. 344502***Abcde. 4556<>'
Read SEQ 02, DEP-X = 01 & DEP-Y = 02, TSTREC len:029
  Data: ' 1<>  01***Ab. 3<>'
Read SEQ 03, DEP-X = 03 & DEP-Y = 03, TSTREC len:080
  Data: ' 1 2 3<>  01***Abc. 34545656702***Abc. 45656767803***Abc. 567678789<>'
Read SEQ 04, DEP-X = 03 & DEP-Y = 10, TSTREC len:101
  Data: ' 1 2 3<>  01***Abcdefghij. 34545656702***Abcdefghij. 45656767803***Abcdefghij. 567678789<>'
], [])


AT_CAPTURE_FILE(./SEQODO)

AT_DATA([reference],
[010205Howdy 1 2<>  01***Abcde. 344502***Abcde. 4556<>
020102Howdy 1<>  01***Ab. 3<>
030303Howdy 1 2 3<>  01***Abc. 34545656702***Abc. 45656767803***Abc. 567678789<>
040310Howdy 1 2 3<>  01***Abcdefghij. 34545656702***Abcdefghij. 45656767803***Abcdefghij. 567678789<>
])

AT_CHECK([diff reference SEQODO], [0], [], [])

AT_CLEANUP


AT_SETUP([DEPENDING ON with ODOSLIDE for IBM])
AT_KEYWORDS([OCCURS ODO])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.

       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01  L1-1-2-S    PIC 99.
       01  L1-1-2-1-S  PIC 99.
       01  L1-2-S      PIC 99.
       01  L1-3-S      PIC 99.
       01  L1-3-2-S    PIC 99.
       01  BUFFER      PIC X(370).

       PROCEDURE DIVISION.
           MOVE ALL '0123456789' TO BUFFER.
           MOVE 3 TO L1-1-2-S.
           MOVE 4 TO L1-1-2-1-S.
           MOVE 0 TO L1-2-S.
           MOVE 6 TO L1-3-S.
           MOVE 1 TO L1-3-2-S.
           CALL 'IBM-ODO-TEST' USING BUFFER
                               L1-1-2-S
                               L1-1-2-1-S
                               L1-2-S
                               L1-3-S
                               L1-3-2-S.

           MOVE ALL '0123456789' TO BUFFER.
           MOVE 2 TO L1-1-2-S.
           MOVE 3 TO L1-1-2-1-S.
           MOVE 1 TO L1-2-S.
           MOVE 4 TO L1-3-S.
           MOVE 0 TO L1-3-2-S.
           CALL 'IBM-ODO-TEST' USING BUFFER
                               L1-1-2-S
                               L1-1-2-1-S
                               L1-2-S
                               L1-3-S
                               L1-3-2-S.
           STOP RUN.
           END PROGRAM prog.

       IDENTIFICATION DIVISION.
       PROGRAM-ID. IBM-ODO-TEST.

       DATA DIVISION.
       WORKING-STORAGE SECTION.

       LINKAGE SECTION.
       01  L1-1-2-S    PIC 99.
       01  L1-1-2-1-S  PIC 99.
       01  L1-2-S      PIC 99.
       01  L1-3-S      PIC 99.
       01  L1-3-2-S    PIC 99.
       01 BASE.
         10 ARRAY OCCURS 2 TIMES.
           20 L1-1.
             25 L1-1-1 PIC X(3).
             25 L1-1-2 OCCURS 4 TIMES DEPENDING ON L1-1-2-S.
               30 L1-1-2-1 OCCURS 5 TIMES DEPENDING ON L1-1-2-1-S
                  PIC XXX.
           20 L1-2 OCCURS 0 TO 1 TIMES DEPENDING ON L1-2-S PIC XX.
           20 L1-3 OCCURS 1 TO 10 TIMES DEPENDING ON L1-3-S.
             25 L1-3-1.
               30  L1-3-1-1 PIC X(5).
               30  L1-3-1-2 PIC X.
               30  L1-3-1-3 PIC X(5).
             25 L1-3-2 OCCURS 0 TO 1 TIMES DEPENDING ON L1-3-2-S PIC X.

       PROCEDURE DIVISION USING BASE
                                L1-1-2-S
                                L1-1-2-1-S
                                L1-2-S
                                L1-3-S
                                L1-3-2-S.
           DISPLAY "Length is " LENGTH OF BASE
                   " with " L1-1-2-S
                   ", " L1-1-2-1-S
                   ", " L1-2-S
                   ", " L1-3-S
                   ", " L1-3-2-S.
           MOVE '.'   TO L1-3-2(1, 5, 1).
           MOVE '--'  TO L1-2(2, 1).
           MOVE '+++' TO L1-1-2-1(2, 1, 5).
           DISPLAY '"' BASE '"'.
       END PROGRAM IBM-ODO-TEST.
])
# FIXME: odo-checks (-debug) must be adjusted, either with -fodoslide or with a possibly new
#        compiler configuration flag as IBM seems to only check against the field-founder's
#        bounds, not the subscript (which is the reason to use "$COBC -x" instead of "$COMPILE")
AT_CHECK([$COBC -x -std=ibm prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[Length is +0000000222 with 03, 04, 00, 06, 01
"01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567.901234567890123456789012345+++901234567890123456789--2345678901234567890123456789012345678901234567890123456789012345678901"
Length is +0000000134 with 02, 03, 01, 04, 00
"012345678901234567890123456789012345678901234567890123456789012345678901234567.901+++567--01234567890123456789012345678901234567890123"
], [])

AT_CLEANUP


AT_SETUP([INITIALIZE level 01])
AT_KEYWORDS([initialize])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01 L1 OCCURS 1000 TIMES.
           05 L2 PIC S9(9) COMP-5 VALUE 5.
           05 L3 PIC S9(9)        VALUE 5.
       PROCEDURE DIVISION.
           IF L2(3) not = 5
              DISPLAY '0 VALUE(3) = ' L2(3)
              END-DISPLAY
           END-IF.
           INITIALIZE L1(1).
           IF L2(1) not = 0
              DISPLAY '1 VALUE(1) = ' L2(1)
              END-DISPLAY
           END-IF.
           IF L2(3) not = 5
              DISPLAY '1 VALUE(3) = ' L2(3)
              END-DISPLAY
           END-IF.
           INITIALIZE L1(1)  DEFAULT.
           IF L2(1) not = 0
              DISPLAY '2 VALUE(1) = ' L2(1)
              END-DISPLAY
           END-IF.
           IF L2(3) not = 5
              DISPLAY '2 VALUE(3) = ' L2(3)
              END-DISPLAY
           END-IF.
           INITIALIZE L1(1)  ALL VALUE.
           IF L2(1) not = 5
              DISPLAY '3 VALUE(1) = ' L2(1)
              END-DISPLAY
           END-IF.
           IF L2(3) not = 5
              DISPLAY '3 VALUE(3) = ' L2(3)
              END-DISPLAY
           END-IF.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([MOVE of non-integer to alphanumeric])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
        01 INTEGER             PIC 9(4)   VALUE 1289 .
        01 SIGNED-INTEGER      PIC S9(4)  VALUE -1289 .

        01 ALPHA-FIELD         PIC X(4).

        01 NON-INTEGER           PIC 9(2)V99   VALUE 12.89 .
        01 NON-INTEGER-2         PIC 9(2)V99
                                     USAGE BINARY VALUE 12.89 .
        01 NON-INTEGER-3         PIC 9(2)V99
                                      USAGE PACKED-DECIMAL VALUE 12.89 .
        01 SIGNED-NON-INTEGER    PIC S9(2)V99   VALUE -12.89 .
        01 SIGNED-NON-INTEGER-2  PIC S9(2)V99
                                     USAGE BINARY VALUE -12.89 .
        01 SIGNED-NON-INTEGER-3  PIC S9(2)V99
                                     USAGE PACKED-DECIMAL VALUE -12.89 .

       PROCEDURE        DIVISION.
*     *    MOVE NON-INTEGER TO ALPHA-NUMERIC --> ignore Decimal Point!
       S-01.
          MOVE SPACES TO ALPHA-FIELD.
          MOVE INTEGER TO ALPHA-FIELD.
          DISPLAY  ALPHA-FIELD NO ADVANCING
          END-DISPLAY.
       S-02.
          MOVE SPACES TO ALPHA-FIELD.
          MOVE SIGNED-INTEGER TO ALPHA-FIELD.
          DISPLAY  ALPHA-FIELD NO ADVANCING
          END-DISPLAY.
       S-03.
          MOVE SPACES TO ALPHA-FIELD.
          MOVE NON-INTEGER TO ALPHA-FIELD.
          DISPLAY  ALPHA-FIELD NO ADVANCING
          END-DISPLAY.
       S-10.
          MOVE SPACES TO ALPHA-FIELD.
          MOVE NON-INTEGER-2 TO ALPHA-FIELD.
          DISPLAY  ALPHA-FIELD NO ADVANCING
          END-DISPLAY.
       S-20.
          MOVE SPACES TO ALPHA-FIELD.
          MOVE NON-INTEGER-3 TO ALPHA-FIELD.
          DISPLAY  ALPHA-FIELD NO ADVANCING
          END-DISPLAY.
       S-30.
          MOVE SPACES TO ALPHA-FIELD.
          MOVE SIGNED-NON-INTEGER TO ALPHA-FIELD.
          DISPLAY  ALPHA-FIELD NO ADVANCING
          END-DISPLAY.
       S-40.
          MOVE SPACES TO ALPHA-FIELD.
          MOVE SIGNED-NON-INTEGER-2 TO ALPHA-FIELD.
          DISPLAY  ALPHA-FIELD NO ADVANCING
          END-DISPLAY.
       S-50.
          MOVE SPACES TO ALPHA-FIELD.
          MOVE SIGNED-NON-INTEGER-3 TO ALPHA-FIELD.
          DISPLAY  ALPHA-FIELD NO ADVANCING
          END-DISPLAY.

          STOP RUN.
])

AT_CHECK([$COMPILE -std=mf prog.cob], [0], [],
[prog.cob: in paragraph 'S-03':
prog.cob:36: warning: MOVE of non-integer to alphanumeric
prog.cob: in paragraph 'S-10':
prog.cob:41: warning: MOVE of non-integer to alphanumeric
prog.cob: in paragraph 'S-20':
prog.cob:46: warning: MOVE of non-integer to alphanumeric
prog.cob: in paragraph 'S-30':
prog.cob:51: warning: MOVE of non-integer to alphanumeric
prog.cob: in paragraph 'S-40':
prog.cob:56: warning: MOVE of non-integer to alphanumeric
prog.cob: in paragraph 'S-50':
prog.cob:61: warning: MOVE of non-integer to alphanumeric
])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [12891289128912891289128912891289])

AT_CLEANUP

## CALL

AT_SETUP([CALL USING file-name])
AT_KEYWORDS([extensions])

AT_DATA([setfilename.c], [
#include <stdio.h>
#include <string.h>
#include <libcob.h>

COB_EXT_EXPORT int
setfilename (cob_file *f, unsigned char *name)
{
  memcpy (f->assign->data, name, strlen ((char *)name));
  return 0;
}
])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT TEST-FILE ASSIGN FILENAME.
       DATA             DIVISION.
       FILE             SECTION.
       FD TEST-FILE.
       01 TEST-REC      PIC X(4).
       WORKING-STORAGE  SECTION.
       01 FILENAME      PIC X(8).
       PROCEDURE        DIVISION.
           INITIALIZE FILENAME.
           CALL "setfilename" USING TEST-FILE "TESTFILE"
           END-CALL.
           OPEN OUTPUT TEST-FILE.
           CLOSE TEST-FILE.
           STOP RUN.
])

AT_CHECK([$COMPILE_MODULE setfilename.c], [0], [], [])
AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([test -e TESTFILE], [0], [], [])

AT_CLEANUP

AT_SETUP([CALL unusual PROGRAM-ID.])
AT_KEYWORDS([extensions])

AT_DATA([A@B.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      "A@B".
       PROCEDURE        DIVISION.
           DISPLAY "P1" NO ADVANCING
           END-DISPLAY.
           EXIT PROGRAM.
])

AT_DATA([A@%:@B.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      "A@%:@B".
       PROCEDURE        DIVISION.
           DISPLAY "P2" NO ADVANCING
           END-DISPLAY.
           EXIT PROGRAM.
])

AT_DATA([A-B.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      "A-B".
       PROCEDURE        DIVISION.
           DISPLAY "P3" NO ADVANCING
           END-DISPLAY.
           EXIT PROGRAM.
])

AT_DATA([A_B.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      "A_B".
       PROCEDURE        DIVISION.
           DISPLAY "P4" NO ADVANCING
           END-DISPLAY.
           EXIT PROGRAM.
])

AT_DATA([caller.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      caller.
       PROCEDURE        DIVISION.
           CALL "A@B"
           END-CALL.
           CALL "A@%:@B"
           END-CALL.
           CALL "A-B"
           END-CALL.
           CALL "A_B"
           END-CALL.
           STOP RUN.
])

AT_CHECK([$COMPILE_MODULE A@B.cob], [0], [], [])
AT_CHECK([$COMPILE_MODULE A@%:@B.cob], [0], [], [])
AT_CHECK([$COMPILE_MODULE A-B.cob], [0], [], [])
AT_CHECK([$COMPILE_MODULE A_B.cob], [0], [], [])
AT_CHECK([$COMPILE -o caller caller.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./caller], [0], [P1P2P3P4])

AT_CLEANUP

AT_SETUP([CALL / GOBACK with LOCAL-STORAGE])
AT_KEYWORDS([extensions])

# Testcase introduced when Bug #91 occurred.
# Will fail if memory is freed which was
# allocated by mpir/gmp.
AT_DATA([prog_a.cob], [
		IDENTIFICATION DIVISION.
		PROGRAM-ID. prog_a.
		DATA DIVISION.
		WORKING-STORAGE SECTION.
		77  WS-STRINGA   PIC X(10).
		PROCEDURE DIVISION.
		    MOVE  "hi there"   TO WS-STRINGA
		    CALL  "prog_b"  USING WS-STRINGA
		    DISPLAY "back in prog_a"
		    GOBACK.
])

AT_DATA([prog_b.cob], [
		IDENTIFICATION DIVISION.
		PROGRAM-ID. prog_b.
		DATA DIVISION.
		WORKING-STORAGE SECTION.
		77  WS-STRINGB   PIC X(10).
		77  WS-CALLSB    PIC 9(03).
		LOCAL-STORAGE SECTION.
		77  LS-STRING  PIC X(10).
		LINKAGE SECTION.
		77  LK-STRING  PIC X(10).

		PROCEDURE DIVISION  USING  LK-STRING.
		    DISPLAY "entered prog_b"
		    ADD   1  TO  WS-CALLSB
		    MOVE  LK-STRING TO WS-STRINGB
		    MOVE  LK-STRING TO LS-STRING
		    DISPLAY "exiting prog_b"
		    GOBACK.
])

AT_CHECK([$COMPILE prog_a.cob], [0], [], [])
AT_CHECK([$COMPILE_MODULE prog_b.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog_a], [0], [entered prog_b
exiting prog_b
back in prog_a
], [])

AT_CLEANUP


AT_SETUP([CALL BY VALUE alphanumeric item])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  X            PIC XX VALUE "OK".
       PROCEDURE        DIVISION.
           CALL "prog2" USING BY VALUE X
           END-CALL.
           IF X NOT = "OK"
              DISPLAY X NO ADVANCING
              END-DISPLAY
           END-IF.
           STOP RUN.
       PROGRAM-ID.      prog2.
       DATA             DIVISION.
       LINKAGE          SECTION.
       01  Y            PIC XX.
       PROCEDURE        DIVISION USING BY VALUE Y.
           MOVE "KO" TO Y.
           EXIT PROGRAM.
       END PROGRAM prog2.
       END PROGRAM prog.
])

AT_CHECK([$COMPILE prog.cob], [0], [],
[prog.cob:8: warning: BY CONTENT assumed for alphanumeric item 'X'
prog.cob:19: warning: handling of parameters passed BY VALUE is unfinished; implementation is likely to be changed
])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([CALL BY VALUE numeric literal with SIZE IS])
AT_KEYWORDS([extensions])

# note: Eiter MicroFocus SIZE IS extension will be added via dialect option
#       or OpenCOBOL SIZE IS extension be removed later

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       PROCEDURE        DIVISION.
           *> Test of auto size, identical to SIZE AUTO
           CALL "prog2" USING BY VALUE 4 0 0 1 0
           END-CALL

           *> Test of explicit SIZE syntax
           CALL "prog2" USING BY VALUE 1 SIZE 1 2 0 0 0
           END-CALL
           CALL "prog2" USING BY VALUE 2 0 SIZE 2 3 0 0
           END-CALL
           CALL "prog2" USING BY VALUE 4 0 0 SIZE 4 4 0
           END-CALL
           CALL "prog2" USING BY VALUE 8 0 0 0 SIZE 8 5
           END-CALL
           CALL "prog2" USING BY VALUE 4 0 0 SIZE DEFAULT 6 0
           END-CALL
           CALL "prog2" USING BY VALUE 4 0 0 SIZE AUTO    7 0
           END-CALL
           *> test for SIZE AUTO with VALUE > INT_MAX is non-portable

           *> Test of explicit UNSIGNED SIZE syntax
           CALL "prog2" USING BY VALUE 1 UNSIGNED SIZE 1 2 0 0 0
           END-CALL
           CALL "prog2" USING BY VALUE 2 0 UNSIGNED SIZE 2 3 0 0
           END-CALL
           CALL "prog2" USING BY VALUE 4 0 0 UNSIGNED SIZE 4 4 0
           END-CALL
           CALL "prog2" USING BY VALUE 8 0 0 0 UNSIGNED SIZE 8 5 0
           END-CALL
           CALL "prog2" USING BY VALUE 4 0 0 UNSIGNED SIZE AUTO 6 0
           END-CALL
           *> test for SIZE AUTO with VALUE > INT_MAX is non-portable

           *> Test of MF size syntax
           *>CALL "prog2" USING BY VALUE 2 SIZE 1
           *>END-CALL
           *>CALL "prog2" USING BY VALUE 3 SIZE 2
           *>END-CALL
           *>CALL "prog2" USING BY VALUE 4 SIZE 4
           *>END-CALL
           *>CALL "prog2" USING BY VALUE 5 SIZE 8
           *>END-CALL

           STOP RUN.
       END PROGRAM prog. *> FIXME: C compile warnings when moved to end (nested programs)

       PROGRAM-ID.      prog2.
       DATA             DIVISION.
       LINKAGE          SECTION.
       01  LEN          USAGE BINARY-LONG.
       01  VAR-1        USAGE BINARY-CHAR.
       01  VAR-2        USAGE BINARY-SHORT.
       01  VAR-4        USAGE BINARY-LONG.
       01  VAR-8        USAGE BINARY-DOUBLE.
       PROCEDURE        DIVISION USING BY VALUE LEN
                                                SIZE 1 VAR-1
                                                SIZE 2 VAR-2
                                                SIZE 4 VAR-4
                                                SIZE 8 VAR-8.
           EVALUATE len
              WHEN 1
                 DISPLAY '1: ' VAR-1 END-DISPLAY
              WHEN 2
                 DISPLAY '2: ' VAR-2 END-DISPLAY
              WHEN 4
                 DISPLAY '4: ' VAR-4 END-DISPLAY
              WHEN 8
                 DISPLAY '8: ' VAR-8 END-DISPLAY
           END-EVALUATE
           EXIT PROGRAM.
       END PROGRAM prog2.
])

# hack for now: explicit suppress warning
AT_CHECK([$COMPILE -Wno-unfinished prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[4: +0000000001
1: +002
2: +00003
4: +0000000004
8: +00000000000000000005
4: +0000000006
4: +0000000007
1: +002
2: +00003
4: +0000000004
8: +00000000000000000005
4: +0000000006
], [])

AT_CLEANUP


AT_SETUP([CALL BY VALUE to C])
AT_KEYWORDS([extensions SIZE CHAINING])

AT_DATA([caller.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      caller.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       77 CALL-NAME     PIC X(10).
       01.
         03 SOME-FILL   PIC X(33).
         03 ADR-PTR     USAGE POINTER.
         03 ADR-BUFFER  REDEFINES ADR-PTR  USAGE COMP-5 PIC S9(8).
       77 BIG-BUFF      USAGE COMP-5 PIC S9(18) VALUE 99999999999999.
       PROCEDURE        DIVISION  CHAINING CALL-NAME.

      >> IF P64 DEFINED
           MOVE "callee64" TO CALL-NAME
      >> ELSE
           MOVE "callee32" TO CALL-NAME
      >> END-IF

           MOVE 12345678 TO ADR-BUFFER
           CALL CALL-NAME USING BY VALUE ADR-PTR

           CALL CALL-NAME USING BY VALUE ADR-BUFFER

           CALL CALL-NAME USING BY VALUE LENGTH OF SOME-FILL

           MOVE -42 TO ADR-BUFFER
      >> IF P64 DEFINED
           CALL "callee32" USING BY VALUE SIZE 4 ADR-BUFFER
           CALL "callee64" USING BY VALUE BIG-BUFF
      >> ELSE
           CALL "callee32" USING BY VALUE ADR-BUFFER
           CALL "callee64" USING BY VALUE SIZE 8 BIG-BUFF
      >> END-IF

           GOBACK.
])
# hack for now: explicit suppress warning
AT_CHECK([$COMPILE -Wno-unfinished caller.cob], [0], [], [])

AT_DATA([callee64.c], [
#include <stdio.h>
#include <libcob.h>

COB_EXT_EXPORT int
callee64(cob_s64_t val)
{
  printf("VAL received: " CB_FMT_LLD "\n", val);
  return 0;
}
])

AT_DATA([callee32.c], [
#include <stdio.h>
#include <libcob.h>

COB_EXT_EXPORT int
callee32(cob_s32_t val)
{
  printf("VAL received: %d\n", val);
  return 0;
}
])

AT_CHECK([$COMPILE_MODULE callee32.c callee64.c], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./caller], [0],
[VAL received: 12345678
VAL received: 12345678
VAL received: 33
VAL received: -42
VAL received: 99999999999999
], [])


AT_CLEANUP


# extension, should normally be *not* case sensitive
AT_SETUP([Case-sensitive PROGRAM-ID])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      PROG.
       PROCEDURE        DIVISION.
           CALL "prog"
           END-CALL.
           STOP RUN.
       PROGRAM-ID.      prog.
       PROCEDURE        DIVISION.
           EXIT PROGRAM.
       END PROGRAM prog.
       END PROGRAM PROG.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


# note: this is an extension while PROGAM-ID. name AS 'lit'
#       is standard
AT_SETUP([Quoted PROGRAM-ID])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      "caller".
       PROCEDURE        DIVISION.
           CALL "callee"
           END-CALL.
           STOP RUN.
       PROGRAM-ID.      "callee".
       PROCEDURE        DIVISION.
           EXIT PROGRAM.
       END PROGRAM callee.
       END PROGRAM caller.
])

AT_CHECK([$COMPILE -w prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([PROGRAM-ID AS clause])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      caller AS "PROG".
       PROCEDURE        DIVISION.
           CALL "prog"
           END-CALL.
           STOP RUN.
       PROGRAM-ID.      callee AS "prog".
       PROCEDURE        DIVISION.
           EXIT PROGRAM.
       END PROGRAM callee.
       END PROGRAM caller.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([NUMBER-OF-CALL-PARAMETERS])
AT_KEYWORDS([extensions])

AT_DATA([callee.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      callee.
       DATA             DIVISION.
       LINKAGE          SECTION.
       01 W             PIC X.
       01 X             PIC X.
       01 Y             PIC X.
       01 Z             PIC X.
       PROCEDURE        DIVISION
           USING W X Y Z.
           DISPLAY NUMBER-OF-CALL-PARAMETERS
           END-DISPLAY.
           EXIT PROGRAM.
])

AT_DATA([caller.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      caller.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01 W             PIC X.
       01 X             PIC X.
       01 Y             PIC X.
       01 Z             PIC X.
       PROCEDURE        DIVISION.
           CALL "callee"
           END-CALL.
           CALL "callee" USING W
           END-CALL.
           CALL "callee" USING W X
           END-CALL.
           CALL "callee" USING W X Y
           END-CALL.
           CALL "callee" USING W X Y Z
           END-CALL.
           STOP RUN.
])

AT_CHECK([$COMPILE caller.cob], [0], [], [])
AT_CHECK([$COMPILE_MODULE callee.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./caller], [0],
[+000000000
+000000001
+000000002
+000000003
+000000004
])

AT_CLEANUP


AT_SETUP([TALLY register])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      callee.
       PROCEDURE        DIVISION.
           ADD  1 TO TALLY.
           CALL "nested".
           STOP RUN.

       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      nested.
       PROCEDURE        DIVISION.
           DISPLAY tally WITH NO ADVANCING.
           GOBACK.
       END PROGRAM      nested.
])

#FIXME: Should get a dialect check in syntax checks,
#       along with all other special registers
AT_CHECK([$COMPILE_ONLY -fnot-register=TALLY prog.cob], [1], [],
[prog.cob:5: error: 'TALLY' is not defined
prog.cob:12: error: 'tally' is not defined
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [00001])

AT_CLEANUP


AT_SETUP([Redefining TALLY])
AT_KEYWORDS([extensions register])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.

       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01  tally PIC 999 VALUE 1.

       PROCEDURE DIVISION.
           ADD 1 TO tally
           DISPLAY tally UPON SYSOUT
           .
])


#FIXME: Should get a dialect check in syntax checks,
#       along with all other special registers
AT_CHECK([$COMPILE -std=ibm-strict prog.cob], [1], [], [ignore])
AT_CHECK([$COMPILE -std=acu-strict prog.cob], [0], [], [])
#AT_CHECK([$COMPILE -std=ibm prog.cob], [0], [], [])
#AT_CHECK([$COMPILE -std=ibm-strict prog.cob], [1], [],
#[prog.cob:7: error: redefinition of register 'TALLY'
#])
#AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[002
])

AT_CLEANUP


# Program parameters

AT_SETUP([PROCEDURE DIVISION USING BY ...])
AT_KEYWORDS([extensions])

AT_DATA([callee.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      callee.
       DATA             DIVISION.
       LINKAGE          SECTION.
       01 X             PIC X.
       01 Y             PIC 99.
       01 Z             PIC 99 USAGE COMP.
       PROCEDURE        DIVISION
           USING BY VALUE X BY REFERENCE Y Z.
           MOVE "Z" TO X.
           MOVE 56 TO Y.
           MOVE 78 TO Z.
           EXIT PROGRAM.
])

AT_DATA([caller.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      caller.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01 X             PIC X.
       01 Y             PIC 99.
       01 Z             PIC 99 USAGE COMP.
       PROCEDURE        DIVISION.
           MOVE "X" TO X.
           MOVE 12 TO Y.
           MOVE 34 TO Z.
           CALL "callee" USING BY CONTENT X
                               BY REFERENCE Y
                               BY CONTENT Z
           END-CALL.
           IF X NOT = "X" OR
              Y NOT = 56  OR
              Z NOT = 34
                DISPLAY "X = " X " Y = " Y " Z = " Z
                END-DISPLAY
           END-IF
           STOP RUN.
])

AT_CHECK([$COMPILE caller.cob], [0], [], [])
AT_CHECK([$COMPILE_MODULE callee.cob], [0], [],
[callee.cob:10: warning: handling of parameters passed BY VALUE is unfinished; implementation is likely to be changed
])
AT_CHECK([$COBCRUN_DIRECT ./caller], [0], [], [])

AT_CLEANUP


AT_SETUP([PROCEDURE DIVISION CHAINING])
AT_KEYWORDS([extensions CALL INITIALIZE])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  X            PIC X.
       01  ABCD         PIC X(4).
       01  NUM          PIC 9 VALUE 7.
       PROCEDURE        DIVISION
                        CHAINING X ABCD NUM.
           IF X    NOT = "X"    OR
              ABCD NOT = "ABCD"
              DISPLAY "X = " X " ABCD = " ABCD
              END-DISPLAY
           END-IF
           IF NUM  NOT = 7
              DISPLAY "NUM not INITIALIZED: " NUM
              END-DISPLAY
           END-IF
           STOP RUN.
])

AT_DATA([prog2.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog2.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  VAR.
           03  X            PIC X VALUE 'a'.
           03  ABCD         PIC X(4).
           03  NUM          PIC 9 VALUE 7.
       PROCEDURE        DIVISION
                        CHAINING VAR.
           DISPLAY '-' VAR '-' WITH NO ADVANCING
           END-DISPLAY
           STOP RUN.
])

AT_DATA([prog3.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog3.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  X            PIC X.
       01  ABCD         PIC X(4).
       01  NUM          PIC 9 VALUE 7.
       PROCEDURE        DIVISION
                        CHAINING X ABCD NUM.
           IF X    NOT = "X"    OR
              ABCD NOT = "ABCD"
              DISPLAY "X = " X " ABCD = " ABCD
              END-DISPLAY
           END-IF
           IF NUM  NOT = 7
              DISPLAY "NUM not INITIALIZED: " NUM
              END-DISPLAY
           END-IF
           STOP RUN.
])

AT_DATA([caller.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      caller.
       DATA             DIVISION.
       PROCEDURE        DIVISION.
           CALL "prog3" USING "X ABCD" END-CALL
           STOP RUN.
])

AT_DATA([init.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      init.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  VAR.
           03  X            PIC X VALUE 'a'.
           03  ABCD         PIC X(4).
           03  NUM          PIC 9  VALUE 7.
       77  NUM2             PIC 99 VALUE 2.
       PROCEDURE        DIVISION
                        CHAINING VAR.
           DISPLAY '-' VAR NUM2 '-' WITH NO ADVANCING
           END-DISPLAY
           INITIALIZE  VAR NUM2
           DISPLAY '-' VAR NUM2 '-' WITH NO ADVANCING
           MOVE 'XXXX' TO ABCD
           INITIALIZE  VAR NUM2 ALL TO VALUE
           DISPLAY '-' VAR NUM2 '-' WITH NO ADVANCING
           MOVE ALL 'b' TO ABCD
           INITIALIZE  VAR NUM2 ALL TO VALUE THEN TO DEFAULT
           DISPLAY '-' VAR NUM2 '-' WITH NO ADVANCING
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog X ABCD], [0], [], [])

# note: sticky linkage and CHAINING produced compiler errors
#   --> additional test
AT_CHECK([$COMPILE prog.cob -fsticky-linkage -o prog_sticky], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog_sticky X ABCD], [0], [], [])

AT_CHECK([$COMPILE prog2.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog2 X], [0], [-X     -], [])
AT_CHECK([$COBCRUN_DIRECT ./prog2], [0], [-a    7-], [])

AT_CHECK([$COMPILE_MODULE prog3.cob], [0], [], [])
AT_CHECK([$COBCRUN prog3 X ABCD], [0], [], [])

AT_CHECK([$COMPILE caller.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./caller X ABCD], [1], [],
[libcob: caller.cob:6: error: CALL of program with CHAINING clause
])

AT_CHECK([$COMPILE init.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./init X], [0], [-X     02--     000--aXXXX702--a    702-], [])

AT_CLEANUP


AT_SETUP([STOP RUN RETURNING/GIVING])
AT_KEYWORDS([extensions])

AT_DATA([prog1.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog1.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       77  RET          PIC 99 USAGE DISPLAY.
       PROCEDURE        DIVISION.
           MOVE 11 TO RET
           STOP RUN RETURNING RET.
])

AT_DATA([prog2.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog2.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       77  RET          PIC 99 USAGE PACKED-DECIMAL.
       PROCEDURE        DIVISION.
           MOVE 22 TO RET
           STOP RUN GIVING RET.
])

AT_DATA([prog3.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog3.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       PROCEDURE        DIVISION.
           STOP RUN 33.
])

AT_DATA([prog4.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog4.
       PROCEDURE        DIVISION.
           STOP RUN RETURNING 44.
])

AT_CHECK([$COMPILE prog1.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog1], [11])

AT_CHECK([$COMPILE prog2.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog2], [22])

AT_CHECK([$COMPILE prog3.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog3], [33])

AT_CHECK([$COMPILE prog4.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog4], [44])

AT_CLEANUP


AT_SETUP([GOBACK/EXIT PROGRAM RETURNING/GIVING])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       77  RETURN-DISP  PIC S9(08).
       PROCEDURE        DIVISION.
           CALL 'prog1' END-CALL
           IF RETURN-CODE NOT = -1
              MOVE RETURN-CODE TO RETURN-DISP
              DISPLAY 'RETURN-CODE ' RETURN-DISP
                      ' INSTEAD OF -1'
              END-DISPLAY
           END-IF
           CALL 'prog2' END-CALL
           IF RETURN-CODE NOT = 2
              MOVE RETURN-CODE TO RETURN-DISP
              DISPLAY 'RETURN-CODE ' RETURN-DISP
                      ' INSTEAD OF 2'
              END-DISPLAY
           END-IF
           STOP RUN.
])

AT_DATA([prog1.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog1.
       PROCEDURE        DIVISION.
           EXIT PROGRAM RETURNING -1.
])


AT_DATA([prog2.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog2.
       PROCEDURE        DIVISION.
           GOBACK GIVING 2.
])

AT_CHECK([$COMPILE prog.cob prog1.cob prog2.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [2])

AT_CLEANUP


# ENTRY

AT_SETUP([ENTRY])
AT_KEYWORDS([extensions])

AT_DATA([caller.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      caller.
       PROCEDURE        DIVISION.
           CALL "hello" USING "COBOL"
           END-CALL.
           CALL "bye" USING "COBOL"
           END-CALL.
           STOP RUN.
])

AT_DATA([hello.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      hello.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01 MSG-HELLO     PIC X(7) VALUE "Hello, ".
       01 MSG-BYE       PIC X(5) VALUE "Bye, ".
       LINKAGE          SECTION.
       01 X             PIC X(5).
       01 Y             PIC X(5).
       PROCEDURE        DIVISION USING X.
           DISPLAY MSG-HELLO X "!".
           EXIT PROGRAM.

       ENTRY "bye" USING Y.
           DISPLAY MSG-BYE Y "!".
           EXIT PROGRAM.
])

AT_CHECK([$COMPILE caller.cob], [0], [], [])
# TODO: Doesn't work without sticky-linkage which is likely a bug!
AT_CHECK([$COMPILE_MODULE -fentry-statement=ok -fsticky-linkage hello.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./caller], [0],
[Hello, COBOL!
Bye, COBOL!
])

AT_CLEANUP


## LINE SEQUENTIAL

AT_SETUP([LINE SEQUENTIAL write])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT TEST-FILE ASSIGN       "./TEST-FILE"
                        ORGANIZATION IS LINE SEQUENTIAL.
       DATA             DIVISION.
       FILE             SECTION.
       FD TEST-FILE.
       01 TEST-REC      PIC X(4).
       PROCEDURE        DIVISION.
           OPEN OUTPUT TEST-FILE.
           MOVE "a"    TO TEST-REC.
           WRITE TEST-REC
           END-WRITE.
           MOVE "ab"   TO TEST-REC.
           WRITE TEST-REC AFTER 1 LINES
           END-WRITE.
           MOVE "abc"  TO TEST-REC.
           WRITE TEST-REC BEFORE 2 LINES
           END-WRITE.
           MOVE "abcd" TO TEST-REC.
           WRITE TEST-REC
           END-WRITE.
           CLOSE TEST-FILE.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog])
AT_CHECK([cat TEST-FILE], [0],
[a

ababc

abcd
])

AT_CLEANUP


AT_SETUP([LINE SEQUENTIAL read])
AT_KEYWORDS([extensions])

AT_DATA([TEST-FILE],
[a
ab
abc
abcd
abcde
abcdef
])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT TEST-FILE ASSIGN       "./TEST-FILE"
                        ORGANIZATION IS LINE SEQUENTIAL.
       DATA             DIVISION.
       FILE             SECTION.
       FD TEST-FILE.
       01 TEST-REC      PIC X(4).
       PROCEDURE        DIVISION.
           OPEN INPUT TEST-FILE.
           READ TEST-FILE
           END-READ.
           DISPLAY "(" TEST-REC ")"
           END-DISPLAY.
           READ TEST-FILE
           END-READ.
           DISPLAY "(" TEST-REC ")"
           END-DISPLAY.
           READ TEST-FILE
           END-READ.
           DISPLAY "(" TEST-REC ")"
           END-DISPLAY.
           READ TEST-FILE
           END-READ.
           DISPLAY "(" TEST-REC ")"
           END-DISPLAY.
           READ TEST-FILE
           END-READ.
           DISPLAY "(" TEST-REC ")"
           END-DISPLAY.
           READ TEST-FILE
           END-READ.
           DISPLAY "(" TEST-REC ")"
           END-DISPLAY.
           CLOSE TEST-FILE.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[(a   )
(ab  )
(abc )
(abcd)
(abcd)
(abcd)
])

AT_CLEANUP


AT_SETUP([ASSIGN to KEYBOARD/DISPLAY])
AT_KEYWORDS([extensions])

AT_DATA([TEST-FILE],
[a
ab
abc
abcd
abcde
abcdef
])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT TEST-FILE ASSIGN  KEYBOARD
                        ORGANIZATION IS LINE SEQUENTIAL.
       SELECT TEST-OUT  ASSIGN  DISPLAY
                        ORGANIZATION IS LINE SEQUENTIAL.
       DATA             DIVISION.
       FILE             SECTION.
       FD TEST-FILE.
       01 TEST-REC      PIC X(80).
       FD TEST-OUT.
       01 TEST-REC-OUT  PIC X(80).
       PROCEDURE        DIVISION.
       A00.
           OPEN INPUT  TEST-FILE.
           OPEN OUTPUT TEST-OUT.
       A01.
           READ TEST-FILE AT END
                GO TO Z99
           END-READ.
           WRITE TEST-REC-OUT FROM TEST-REC
           END-WRITE.
           GO TO A01.
       Z99.
           CLOSE TEST-FILE.
           CLOSE TEST-OUT.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([cat TEST-FILE | $COBCRUN_DIRECT ./prog], [0],
[a
ab
abc
abcd
abcde
abcdef
])

AT_CLEANUP


AT_SETUP([SORT ASSIGN KEYBOARD to ASSIGN DISPLAY])
AT_KEYWORDS([extensions])

# GC has an extension "SORT FILES always in memory" and therefore didn't
# used the ASSIGN clause (which should be mandatory) for SORT files at all.
# We should add an according test and change the test here after cleanup,
# officially documenting the "ASSIGN clause not necessary for SORT FILES"
# extension and enable it only with a conf entry (set only in default.conf).
AT_XFAIL_IF(true)

AT_DATA([TEST-FILE],
[9
22
11
0
00
8
77
])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT TEST-FILE ASSIGN  KEYBOARD
                        ORGANIZATION IS LINE SEQUENTIAL.
       SELECT TEST-OUT  ASSIGN  DISPLAY
                        ORGANIZATION IS LINE SEQUENTIAL.
       SELECT SORT-FILE.
       DATA             DIVISION.
       FILE             SECTION.
       FD TEST-FILE.
       01 TEST-REC      PIC X(80).
       FD TEST-OUT.
       01 TEST-REC-OUT  PIC X(80).
       SD SORT-FILE.
       01 SORT-REC      PIC X(80).
       PROCEDURE        DIVISION.
       A00.
           SORT SORT-FILE
                ON ASCENDING SORT-REC
                USING        TEST-FILE
                GIVING       TEST-OUT.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([cat TEST-FILE | $COBCRUN_DIRECT ./prog], [0],
[0
00
11
22
77
8
9
])

AT_CLEANUP


AT_SETUP([Environment/Argument variable])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01 X             PIC X(4).
       01 Y             PIC X(8).
       01 Z             PIC 9(4).
       PROCEDURE        DIVISION.
           DISPLAY "TEST_ENV" UPON ENVIRONMENT-NAME
           END-DISPLAY.
           ACCEPT X FROM ENVIRONMENT-VALUE
           END-ACCEPT.
           DISPLAY "(" X ")"
           END-DISPLAY.
           DISPLAY "RXW" UPON ENVIRONMENT-VALUE
           END-DISPLAY.
           ACCEPT X FROM ENVIRONMENT-VALUE
           END-ACCEPT.
           DISPLAY "(" X ")"
           END-DISPLAY.
           ACCEPT Y FROM ARGUMENT-VALUE
           END-ACCEPT.
           DISPLAY "(" Y ")"
           END-DISPLAY.
           ACCEPT Z FROM ARGUMENT-NUMBER
           END-ACCEPT.
           DISPLAY "(" Z ")"
           END-DISPLAY.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([TEST_ENV=OK $COBCRUN_DIRECT ./prog CHECKPAR], [0],
[(OK  )
(RXW )
(CHECKPAR)
(0001)
])

AT_CLEANUP


AT_SETUP([78 Level (1)])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       78  X            VALUE "OK".
       PROCEDURE        DIVISION.
           DISPLAY X
           END-DISPLAY.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[OK
])

AT_CLEANUP


AT_SETUP([78 Level (2)])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  Z.
       78  X            VALUE "OK".
       78  Y            VALUE "OK".
           03  FILLER   PIC XX VALUE "OK".
       PROCEDURE        DIVISION.
           DISPLAY X Z Y
           END-DISPLAY.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[OKOKOK
])

AT_CLEANUP


AT_SETUP([78 Level (3)])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       78  X            VALUE "OK".
       01  Z            PIC XX VALUE "OK".
       PROCEDURE        DIVISION.
           DISPLAY Z X
           END-DISPLAY.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[OKOK
])

AT_CLEANUP


AT_SETUP([SWITCHES with non-standard names])
AT_KEYWORDS([runmisc extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       SPECIAL-NAMES.
           SW1
             ON  IS SWIT1-ON
             OFF IS SWIT1-OFF
           .
           SWITCH B IS SWITCH-B
             ON  IS SWIT2-ON
             OFF IS SWIT2-OFF
           .
           SWITCH 25
             ON  IS SWIT25-ON
             OFF IS SWIT25-OFF
           .
           SWITCH Z
             ON  IS SWIT26-ON
             OFF IS SWIT26-OFF
           .
           USW-31
             ON  IS SWIT31-ON
             OFF IS SWIT31-OFF
           .
           SWITCH-32
             ON  IS SWIT32-ON
             OFF IS SWIT32-OFF
           .
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  SWITCH       PIC 99 VALUE 12.
	   78  Z            VALUE 11.
       PROCEDURE        DIVISION.
           ADD SWITCH 1 GIVING SWITCH
           END-ADD.
           IF SWITCH NOT = 13
              DISPLAY "SWITCH (variable) + 1 WRONG: "
                      SWITCH
              END-DISPLAY
           END-IF.
           ADD SWITCH Z GIVING SWITCH
           END-ADD.
           IF SWITCH NOT = 24
              DISPLAY "SWITCH (variable) + Z WRONG: "
                      SWITCH
              END-DISPLAY
           END-IF.
           IF SWIT1-ON
              DISPLAY "ON" NO ADVANCING
              END-DISPLAY
           ELSE
              DISPLAY "OFF" NO ADVANCING
              END-DISPLAY
           END-IF.
           IF SWIT2-ON
              DISPLAY " ON" NO ADVANCING
              END-DISPLAY
           ELSE
              DISPLAY " OFF" NO ADVANCING
              END-DISPLAY
           END-IF.
           SET SWITCH-B TO OFF
           IF SWIT2-ON
              DISPLAY " ON" NO ADVANCING
              END-DISPLAY
           ELSE
              DISPLAY " OFF" NO ADVANCING
              END-DISPLAY
           END-IF.
           IF SWIT25-ON
              DISPLAY " ON" NO ADVANCING
              END-DISPLAY
           ELSE
              DISPLAY " OFF" NO ADVANCING
              END-DISPLAY
           END-IF.
           IF SWIT26-ON
              DISPLAY " ON" NO ADVANCING
              END-DISPLAY
           ELSE
              DISPLAY " OFF" NO ADVANCING
              END-DISPLAY
           END-IF.
           IF SWIT31-ON
              DISPLAY " ON" NO ADVANCING
              END-DISPLAY
           ELSE
              DISPLAY " OFF" NO ADVANCING
              END-DISPLAY
           END-IF.
           IF SWIT32-ON
              DISPLAY " ON" NO ADVANCING
              END-DISPLAY
           ELSE
              DISPLAY " OFF" NO ADVANCING
              END-DISPLAY
           END-IF.
           STOP RUN.
])

AT_CHECK([$COMPILE -fsystem-name="sw1, SwItCh\ b, SWITCH\ 25" \
-fsystem-name=SWITCH-32 -fsystem-name="SWITCH\ Z" -fsystem-name=USW-31 prog.cob], [0], [], [])
AT_CHECK([COB_SWITCH_2=1 COB_SWITCH_26=1 COB_SWITCH_31=1 COB_SWITCH_32=1 ./prog], [0],
[OFF ON OFF OFF ON ON ON], [])

AT_CLEANUP


AT_SETUP([Larger REDEFINES lengths])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  Z            PIC 99.
       01  XMAIN        PIC X(8).
       01  XMAINRED REDEFINES XMAIN.
           03  FILLER         PIC X(4).
           03  XMAIN03.
               05  XMAIN0501  PIC X(4).
               05  XMAIN0502 REDEFINES XMAIN0501 PIC X(5).
       01 USE-VARS.
          05 USE-VALUE                PIC 9
                                      VALUE ZERO.
             88 USE-ACTIVE-FIRST      VALUE 1.
             88 USE-ACTIVE-SECOND     VALUE 2.
          05 USE-FIRST.
             10 FIRST-DATA.
                20 FIRST-DATA-VAR     PIC X(033).
             10 FIRST-VARIANT-A REDEFINES FIRST-DATA.
                20 PART-A-FIRST       PIC X(33211).
             10 FIRST-VARIANT-B REDEFINES FIRST-DATA.
                20 PART-B-FIRST       PIC X(24561).
             10 FIRST-VARIANT-C REDEFINES FIRST-DATA.
                20 PART-C-FIRST       PIC X(3421).
         05 USE-SECOND REDEFINES USE-FIRST.
            10 SECOND-HEADER.
               20 SECOND-DATA         PIC 9(015).
               20 SECOND-CONTROL-SUM  PIC 9(015)V9(003).
            10 SECOND-VARIANT-A REDEFINES SECOND-HEADER.
               20 PART-A-SECOND       PIC X(27241).
            10 SECOND-VARIANT-B REDEFINES SECOND-HEADER.
               20 PART-B-SECOND       PIC X(3879).
       PROCEDURE        DIVISION.
           MOVE    LENGTH OF XMAIN       TO Z.
           IF Z NOT = 8
              DISPLAY "Test 1 " Z.
           MOVE    LENGTH OF XMAINRED    TO Z.
           IF Z NOT = 9
              DISPLAY "Test 2 " Z.
           MOVE    LENGTH OF XMAIN03     TO Z.
           IF Z NOT = 5
              DISPLAY "Test 3 " Z.
           MOVE    LENGTH OF XMAIN0501   TO Z.
           IF Z NOT = 4
              DISPLAY "Test 4 " Z.
           MOVE    LENGTH OF XMAIN0502   TO Z.
           IF Z NOT = 5
              DISPLAY "Test 5 " Z.
           IF LENGTH OF USE-FIRST  NOT = 33211
              DISPLAY LENGTH OF USE-FIRST   END-DISPLAY.
           IF LENGTH OF USE-SECOND NOT = 27241
              DISPLAY LENGTH OF USE-SECOND  END-DISPLAY.
           STOP RUN.
])

AT_CHECK([$COMPILE -flarger-redefines=ok -w prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_CLEANUP


AT_SETUP([REDEFINES: non-referenced ambiguous item])
AT_KEYWORDS([extensions redefines mf])

# bad extension, supported for compatibility to at least MicroFocus
# the redefines always applies to the item defined before

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01 X             PIC X value '1'.
       01 X             PIC X value '2'.
       01 G             REDEFINES X PIC 9.
       PROCEDURE        DIVISION.
           IF G NOT = 2
              DISPLAY 'G IS ' G.
           STOP RUN.
])

# syntax checked in syn_definition.at
AT_CHECK([$COMPILE -w prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_CLEANUP


AT_SETUP([Obsolete 2002 keywords with COBOL2014])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  TERMINAL     PIC XX VALUE "OK".
       01  SEND         PIC XX VALUE "OK".
       PROCEDURE        DIVISION.
           DISPLAY TERMINAL SEND.
           STOP RUN.
])

AT_CHECK([$COMPILE -std=cobol2002 prog.cob], [1], [],
[prog.cob:6: error: syntax error, unexpected TERMINAL
prog.cob:7: error: syntax error, unexpected SEND
prog.cob:9: error: syntax error, unexpected TERMINAL, expecting [(]
])
AT_CHECK([$COMPILE -std=cobol2014 prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[OKOK
])

AT_CLEANUP


#  System routines

AT_SETUP([System routine with wrong number of parameters])
AT_KEYWORDS([extensions narg])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  N            PIC 9 USAGE BINARY.
       77  X            PIC X.
       PROCEDURE        DIVISION.
           CALL "C$NARG" USING N X
           END-CALL
           IF N NOT = 2
              DISPLAY "NOTOK " N
              END-DISPLAY
           END-IF
           STOP RUN.
])

AT_DATA([wrong.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      wrong.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       77  X            PIC X.
       PROCEDURE        DIVISION.
           CALL "CBL_OR" USING X
           END-CALL
           STOP RUN.
])

AT_CHECK([$COMPILE wrong.cob], [1], [],
[wrong.cob:8: error: wrong number of CALL parameters for 'CBL_OR', 1 given, 3 expected
])
AT_CHECK([$COMPILE prog.cob], [0], [],
[prog.cob:9: warning: wrong number of CALL parameters for 'C$NARG', 2 given, 1 expected
])
AT_CHECK([$COBCRUN_DIRECT ./prog 1 2], [0], [], [])

AT_CLEANUP


AT_SETUP([System routine C$NARG])
AT_KEYWORDS([extensions narg])

AT_DATA([callee.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      callee.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  X            USAGE BINARY-LONG.
       LINKAGE SECTION.
       01  Y            PIC   X.
       PROCEDURE        DIVISION USING Y.
           CALL "C$NARG" USING X
           END-CALL
           IF X NOT = 1
              DISPLAY "NOTOK callee " X
              END-DISPLAY
           END-IF
           EXIT PROGRAM.
])

AT_DATA([caller.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      caller.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  X            PIC X VALUE "X".
       01  N            PIC 9 USAGE BINARY.
       LINKAGE SECTION.
       77  Y            PIC X.
       77  Z            PIC X.
       PROCEDURE        DIVISION.
           CALL "C$NARG" USING N
           END-CALL
           IF N NOT = 2
              DISPLAY "NOTOK caller (1) " N
              END-DISPLAY
           END-IF
           CALL "callee" USING X
           END-CALL
           CALL "C$NARG" USING N
           END-CALL
           IF N NOT = 2
              DISPLAY "NOTOK caller (2) " N
              END-DISPLAY
           END-IF
           STOP RUN.
])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  N            PIC 9 USAGE BINARY.
       LINKAGE SECTION.
       77  X            PIC X.
       77  Y            PIC X.
       77  Z            PIC X.
       PROCEDURE        DIVISION.
           CALL "C$NARG" USING N
           END-CALL
           DISPLAY N WITH NO ADVANCING
           END-DISPLAY
           STOP RUN.
])

AT_CHECK([$COMPILE caller.cob], [0], [], [])
AT_CHECK([$COMPILE_MODULE callee.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./caller 1 2], [0], [], [])
AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog "1 2"], [0], [1], [])
AT_CHECK([$COBCRUN_DIRECT ./prog 1 2 3], [0], [3], [])

AT_CLEANUP


AT_SETUP([System routine C$PARAMSIZE])
AT_KEYWORDS([extensions])

AT_DATA([callee.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      callee.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  X            USAGE BINARY-LONG.
       LINKAGE SECTION.
       01  Y            PIC   X ANY LENGTH.
       PROCEDURE        DIVISION USING Y.
           MOVE 1 TO X.
           CALL "C$PARAMSIZE" USING X
           END-CALL.
           IF RETURN-CODE NOT = 2
              DISPLAY "NOTOK "  RETURN-CODE
              END-DISPLAY
           END-IF.
           MOVE 0 TO RETURN-CODE.
           EXIT PROGRAM.
])

AT_DATA([caller.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      caller.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  X            PIC XX VALUE "XY".
       PROCEDURE        DIVISION.
           CALL "callee" USING X
           END-CALL.
           STOP RUN.
])

AT_CHECK([$COMPILE caller.cob], [0], [], [])
AT_CHECK([$COMPILE_MODULE callee.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./caller], [0], [], [])

AT_CLEANUP


AT_SETUP([System routine C$CALLEDBY])
AT_KEYWORDS([extensions])

AT_DATA([callee.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      callee.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  X            PIC X(6) VALUE "X".
       PROCEDURE        DIVISION.
           CALL "C$CALLEDBY" USING X
           END-CALL.
           IF RETURN-CODE = 1 AND
              X = "caller"
              DISPLAY "OK" NO ADVANCING
              END-DISPLAY
           END-IF.
           EXIT PROGRAM.
])

AT_DATA([caller.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      caller.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  X            PIC X(6) VALUE "X".
       PROCEDURE        DIVISION.
           CALL "C$CALLEDBY" USING X
           END-CALL.
           IF RETURN-CODE = 0 AND
              X = SPACES
              DISPLAY "OK" NO ADVANCING
              END-DISPLAY
           END-IF.
           CALL "callee"
           END-CALL.
           STOP RUN.
])

AT_CHECK([$COMPILE caller.cob], [0], [], [])
AT_CHECK([$COMPILE_MODULE callee.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./caller], [1], [OKOK])

AT_CLEANUP


AT_SETUP([System routine C$JUSTIFY])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  X            PIC X(4) VALUE " OK ".
       PROCEDURE        DIVISION.
           CALL "C$JUSTIFY" USING X "L"
           END-CALL.
           IF X NOT = "OK  "
              DISPLAY X NO ADVANCING
              END-DISPLAY
           END-IF.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([System routine C$PRINTABLE])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  X.
           03  X1       PIC X.
           03  X234     PIC XXX.
       PROCEDURE        DIVISION.
           MOVE LOW-VALUE TO X1.
           MOVE "BCD"     TO X234.
           CALL "C$PRINTABLE" USING X
           END-CALL.
           IF X NOT = ".BCD"
              DISPLAY X NO ADVANCING
              END-DISPLAY
           END-IF.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([System routine C$MAKEDIR])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       PROCEDURE        DIVISION.
           CALL "C$MAKEDIR" USING "TMP"
           END-CALL.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([test -d "TMP" && rmdir "TMP"], [0], [], [])

AT_CLEANUP


AT_SETUP([System routine C$GETPID])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       PROCEDURE        DIVISION.
           CALL "C$GETPID"
           END-CALL.
           IF RETURN-CODE = 0
              DISPLAY "C$GETPID returned zero!"
              END-DISPLAY
           END-IF.
           MOVE 0 TO RETURN-CODE.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([System routine C$TOUPPER])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  X            PIC X(2) VALUE "ok".
       PROCEDURE        DIVISION.
           CALL "C$TOUPPER" USING X BY VALUE 2
           END-CALL.
           IF X NOT = "OK"
              DISPLAY X NO ADVANCING
              END-DISPLAY
           END-IF.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([System routine C$TOLOWER])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  X            PIC X(2) VALUE "OK".
       PROCEDURE        DIVISION.
           CALL "C$TOLOWER" USING X BY VALUE 2
           END-CALL.
           IF X NOT = "ok"
              DISPLAY X NO ADVANCING
              END-DISPLAY
           END-IF.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([System routine CBL_OR])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  X            PIC X(4) VALUE "0000".
       01  Z            PIC X(4) VALUE X"01010101".
       PROCEDURE        DIVISION.
           CALL "CBL_OR" USING X Z
                BY VALUE LENGTH OF Z
           END-CALL.
           IF Z NOT = "1111"
              DISPLAY Z NO ADVANCING
              END-DISPLAY
           END-IF.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([System routine CBL_NOR])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  X            PIC X(4) VALUE X"03030303".
       01  Z            PIC X(4) VALUE X"05050505".
       PROCEDURE        DIVISION.
           CALL "CBL_NOR" USING X Z
                BY VALUE LENGTH OF Z
           END-CALL.
           IF Z NOT = X"F8F8F8F8"
              DISPLAY "NG" NO ADVANCING
              END-DISPLAY
           END-IF.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([System routine CBL_AND])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  X            PIC X(4) VALUE "3333".
       01  Z            PIC X(4) VALUE "5555".
       PROCEDURE        DIVISION.
           CALL "CBL_AND" USING X Z
                BY VALUE LENGTH OF Z
           END-CALL.
           IF Z NOT = "1111"
              DISPLAY Z NO ADVANCING
              END-DISPLAY
           END-IF.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([System routine CBL_XOR])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  X            PIC X(4) VALUE "3333".
       01  Z            PIC X(4) VALUE X"02020202".
       PROCEDURE        DIVISION.
           CALL "CBL_XOR" USING X Z
                BY VALUE LENGTH OF Z
           END-CALL.
           IF Z NOT = "1111"
              DISPLAY Z NO ADVANCING
              END-DISPLAY
           END-IF.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([System routine CBL_IMP])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  X            PIC X(4) VALUE HIGH-VALUE.
       01  Z            PIC X(4) VALUE "1111".
       PROCEDURE        DIVISION.
           CALL "CBL_IMP" USING X Z
                BY VALUE LENGTH OF Z
           END-CALL.
           IF Z NOT = "1111"
              DISPLAY Z NO ADVANCING
              END-DISPLAY
           END-IF.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([System routine CBL_NIMP])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  X            PIC X(4) VALUE "1111".
       01  Z            PIC X(4) VALUE LOW-VALUE.
       PROCEDURE        DIVISION.
           CALL "CBL_NIMP" USING X Z
                BY VALUE LENGTH OF Z
           END-CALL.
           IF Z NOT = "1111"
              DISPLAY Z NO ADVANCING
              END-DISPLAY
           END-IF.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([System routine CBL_NOT])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  X            PIC X(4) VALUE HIGH-VALUE.
       PROCEDURE        DIVISION.
           CALL "CBL_NOT" USING X
                BY VALUE LENGTH OF X
           END-CALL.
           IF X NOT = LOW-VALUE
              DISPLAY "NG" NO ADVANCING
              END-DISPLAY
           END-IF.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([System routine CBL_EQ])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01  X            PIC X(4) VALUE HIGH-VALUE.
       01  Z            PIC X(4) VALUE "1111".
       PROCEDURE        DIVISION.
           CALL "CBL_EQ" USING X Z
                BY VALUE LENGTH OF Z
           END-CALL.
           IF Z NOT = "1111"
              DISPLAY Z NO ADVANCING
              END-DISPLAY
           END-IF.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([System routine CBL_GC_GETOPT])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
        IDENTIFICATION DIVISION.
        PROGRAM-ID. prog.
      *> check combination of long and short options
        DATA DIVISION.
        WORKING-STORAGE SECTION.
           01 LO.
                05 OPTIONRECORD OCCURS 2 TIMES.
                    10 ONAME        PIC X(25).
                    10 HAS-VALUE    PIC 9.
                    10 VALPOINT     POINTER     VALUE NULL.
                    10 VAL          PIC X(4).

            01 SO             PIC X(256).
            01 LONGIND        PIC 99.
            01 LONG-ONLY      PIC 9 VALUE 1.
            01 RETURN-CHAR    PIC X(4).
            01 OPT-VAL        PIC X(10).
            01 RET-DISP       PIC S9 VALUE 0.

            01 COUNTER        PIC 9 VALUE 0.
        PROCEDURE DIVISION.
            MOVE "jkl"     TO SO.

            MOVE "version" TO ONAME     (1).
            MOVE 0         TO HAS-VALUE (1).
            MOVE "v"       TO VAL       (1).

            MOVE "verbose" TO ONAME     (2).
            MOVE 0         TO HAS-VALUE (2).
            MOVE "V"       TO VAL       (2).

            PERFORM WITH TEST AFTER
                    VARYING COUNTER FROM 0 BY 1
                    UNTIL RETURN-CODE = -1
               CALL 'CBL_GC_GETOPT' USING
                  BY REFERENCE SO LO LONGIND
                  BY VALUE     LONG-ONLY
                  BY REFERENCE RETURN-CHAR OPT-VAL
               END-CALL

               EVALUATE COUNTER
                  WHEN 0
                     IF RETURN-CHAR NOT = 'v' THEN
                        DISPLAY '0-ERROR: ' RETURN-CHAR END-DISPLAY
                     END-IF
                  WHEN 1
                     IF RETURN-CHAR NOT = 'V' THEN
                        DISPLAY '1-ERROR: ' RETURN-CHAR END-DISPLAY
                     END-IF
                  WHEN 2
                     IF RETURN-CHAR NOT = 'j' THEN
                        DISPLAY '2-ERROR: ' RETURN-CHAR END-DISPLAY
                     END-IF
                  WHEN 3
                     IF RETURN-CHAR NOT = 'k' THEN
                        DISPLAY '3-ERROR: ' RETURN-CHAR END-DISPLAY
                     END-IF
                  WHEN 4
                     IF RETURN-CHAR NOT = 'l' THEN
                        DISPLAY '4-ERROR: ' RETURN-CHAR END-DISPLAY
                     END-IF
                  WHEN 5
                     IF RETURN-CODE NOT = -1 THEN
                        MOVE RETURN-CODE TO RET-DISP
                        DISPLAY 'last RETURN-CODE wrong: ' RET-DISP
                        END-DISPLAY
                     END-IF
                     EXIT PERFORM
               END-EVALUATE
            END-PERFORM.

            MOVE 0 TO RETURN-CODE.

            IF COUNTER NOT = 5 THEN
               MOVE RETURN-CODE TO RET-DISP
               DISPLAY 'CBL_GC_GETOPT returned -1 too early: ' COUNTER
               END-DISPLAY
            END-IF.

            STOP RUN.
])

AT_DATA([prog2.cob], [
        IDENTIFICATION DIVISION.
        PROGRAM-ID. prog2.
      *> check if partial options work correct
        DATA DIVISION.
        WORKING-STORAGE SECTION.
      *> Check with wrong record count


            01 LO.
                05 OPTIONRECORD OCCURS 3 TIMES.
                    10 ONAME        PIC X(25).
                    10 HAS-VALUE    PIC 9.
                    10 VALPOINT     POINTER     VALUE NULL.
                    10 VAL          PIC X(4).

            78 SO             VALUE "jkl".
            01 LONGIND        PIC 99.
            01 LONG-ONLY      PIC 9 VALUE 1.
            01 RETURN-CHAR    PIC X(4).
            01 OPT-VAL        PIC X(10).
            01 RET-DISP       PIC S9 VALUE 0.

            01 COUNTER        PIC 9 VALUE 0.
        PROCEDURE DIVISION.
            MOVE "version" TO ONAME     (1).
            MOVE 0         TO HAS-VALUE (1).
            MOVE "v"       TO VAL       (1).

            MOVE "verbose" TO ONAME     (2).
            MOVE 0         TO HAS-VALUE (2).
            MOVE "V"       TO VAL       (2).

            PERFORM WITH TEST AFTER
                    VARYING COUNTER FROM 0 BY 1
                    UNTIL RETURN-CODE = -1
               CALL 'CBL_GC_GETOPT' USING
                  BY REFERENCE SO LO LONGIND
                  BY VALUE     LONG-ONLY
                  BY REFERENCE RETURN-CHAR OPT-VAL
               END-CALL

               EVALUATE COUNTER
                  WHEN 0
                     IF RETURN-CHAR NOT = '?' THEN
                        DISPLAY '0-ERROR: ' RETURN-CHAR END-DISPLAY
                     END-IF
                  WHEN 1
                     IF RETURN-CHAR NOT = 'v' THEN
                        DISPLAY '1-ERROR: ' RETURN-CHAR END-DISPLAY
                     END-IF
                  WHEN 2
                     IF RETURN-CODE NOT = -1 THEN
                        MOVE RETURN-CODE TO RET-DISP
                        DISPLAY 'last RETURN-CODE wrong: ' RET-DISP
                        END-DISPLAY
                     END-IF
                     EXIT PERFORM
               END-EVALUATE
            END-PERFORM.

            MOVE 0 TO RETURN-CODE.

            IF COUNTER NOT = 2 THEN
               MOVE RETURN-CODE TO RET-DISP
               DISPLAY 'CBL_GC_GETOPT returned -1 too early: ' COUNTER
               END-DISPLAY
            END-IF.

            STOP RUN.
])

AT_DATA([prog3.cob], [
        IDENTIFICATION DIVISION.
        PROGRAM-ID. prog3.
      *> check for optional and mandatory parameters
        DATA DIVISION.
        WORKING-STORAGE SECTION.
            01 SO PIC X(128).
            01 LO.
                05 OPTIONRECORD OCCURS 3 TIMES.
                    10 ONAME        PIC X(25).
                    10 HAS-VALUE    PIC 9.
                    10 VALPOINT     POINTER     VALUE NULL.
                    10 VAL          PIC X(4).
            01 LONGIND        PIC 99.
            01 LONG-ONLY      PIC 9 VALUE 0.
            01 RETURN-CHAR    PIC X(4).
            01 OPT-VAL        PIC X(10).
            01 RET-DISP       PIC S9 VALUE 0.

            01 COUNTER        PIC 9 VALUE 0.
        PROCEDURE DIVISION.
            MOVE "j:k::l"  TO SO.

            MOVE "version" TO ONAME     (1).
            MOVE 1         TO HAS-VALUE (1).
            MOVE "v"       TO VAL       (1).

            MOVE "verbose" TO ONAME     (2).
            MOVE 2         TO HAS-VALUE (2).
            MOVE "V"       TO VAL       (2).

            MOVE "usage"   TO ONAME     (3).
            MOVE 0         TO HAS-VALUE (3).
            MOVE "u"       TO VAL       (3).

            PERFORM WITH TEST AFTER
                    VARYING COUNTER FROM 0 BY 1
                    UNTIL RETURN-CODE = -1
               CALL 'CBL_GC_GETOPT' USING
                  BY REFERENCE SO LO LONGIND
                  BY VALUE     LONG-ONLY
                  BY REFERENCE RETURN-CHAR OPT-VAL
               END-CALL

               EVALUATE COUNTER
                  WHEN 0
                     IF OPT-VAL(1:4) NOT = 'lang' THEN
                        DISPLAY '0-ERROR: ' OPT-VAL END-DISPLAY
                     END-IF
                  WHEN 1
                     IF (OPT-VAL(1:1) NOT = 'k' OR
                         RETURN-CHAR  NOT = 'V' OR
                         OPT-VAL(1:4)     = 'kang')  THEN
                        DISPLAY '1-ERROR: ' OPT-VAL ' ' RETURN-CHAR
                        END-DISPLAY
                     END-IF
                  WHEN 2
                     IF RETURN-CHAR NOT = 'u' THEN
                        DISPLAY '2-ERROR: ' RETURN-CHAR END-DISPLAY
                     END-IF
                  WHEN 3
                     IF OPT-VAL(1:1) NOT = '5' OR
                        RETURN-CHAR  NOT = 'j' THEN
                        DISPLAY '3-ERROR: ' OPT-VAL ' ' RETURN-CHAR
                        END-DISPLAY
                     END-IF
                  WHEN 4
                     IF OPT-VAL(1:1) NOT = '6' OR
                        RETURN-CHAR  NOT = 'k' THEN
                        DISPLAY '4-ERROR: ' OPT-VAL ' ' RETURN-CHAR
                        END-DISPLAY
                     END-IF
                  WHEN 5
                     IF RETURN-CHAR NOT = 'l' THEN
                        DISPLAY '5-ERROR: ' RETURN-CHAR END-DISPLAY
                     END-IF
                  WHEN 6
                     IF RETURN-CODE NOT = -1 THEN
                        MOVE RETURN-CODE TO RET-DISP
                        DISPLAY 'last RETURN-CODE wrong: ' RET-DISP
                        END-DISPLAY
                     END-IF
                     EXIT PERFORM
               END-EVALUATE
            END-PERFORM.

            MOVE 0 TO RETURN-CODE.

            IF COUNTER NOT = 6 THEN
               MOVE RETURN-CODE TO RET-DISP
               DISPLAY 'CBL_GC_GETOPT returned -1 too early: ' COUNTER
               END-DISPLAY
            END-IF.

            STOP RUN.
])

AT_DATA([prog4.cob], [
        IDENTIFICATION DIVISION.
        PROGRAM-ID. prog4.
      *> check use of value pointer and trimming of opt-val
        DATA DIVISION.
        WORKING-STORAGE SECTION.
            01 SO PIC X(12).
            01 LO.
                05 OPTIONRECORD OCCURS 3 TIMES.
                    10 ONAME        PIC X(25).
                    10 HAS-VALUE    PIC 9.
                    10 VALPOINT     POINTER     VALUE NULL.
                    10 VAL          PIC X(4).
            01 LONGIND          PIC 99.
            01 LONG-ONLY        PIC 9 VALUE 1.
            01 RETURN-CHAR      PIC X(4).
            01 OPT-VAL          PIC X(10).
            01 RET-DISP         PIC S999 VALUE 0.

            01 COUNTER          PIC 9 VALUE 0.

            01 FLAG-VAL         PIC X(4).
        procedure division.
            MOVE "jkl"       TO SO.

            MOVE "static"    TO ONAME     (1).
            MOVE 0           TO HAS-VALUE (1).
            SET  VALPOINT(1) TO ADDRESS OF FLAG-VAL.
            MOVE '1'         TO VAL       (1).

            MOVE "dynamic"   TO ONAME     (2).
            MOVE 0           TO HAS-VALUE (2).
            SET  VALPOINT(2) TO ADDRESS OF FLAG-VAL.
            MOVE '0'         TO VAL       (2).

            MOVE "usage"     TO ONAME     (3).
            MOVE 1           TO HAS-VALUE (3).
            MOVE 'u'         TO VAL       (3).

            PERFORM WITH TEST AFTER
                    VARYING COUNTER FROM 0 BY 1
                    UNTIL RETURN-CODE = -1
               CALL 'CBL_GC_GETOPT' USING
                  BY REFERENCE SO LO LONGIND
                  BY VALUE     LONG-ONLY
                  BY REFERENCE RETURN-CHAR OPT-VAL
               END-CALL

               EVALUATE COUNTER
                  WHEN 0
                     IF RETURN-CODE NOT = 0 OR
                        FLAG-VAL    NOT = '1' THEN
                        DISPLAY '0-ERROR: ' RET-DISP ' ' FLAG-VAL
                        END-DISPLAY
                     END-IF
                  WHEN 1
                     IF RETURN-CODE NOT = 0 OR
                        FLAG-VAL    NOT = '0' THEN
                        DISPLAY '1-ERROR: ' RET-DISP ' ' FLAG-VAL
                        END-DISPLAY
                     END-IF
                  WHEN 2
                     IF RETURN-CHAR NOT = 'u' OR
                        RETURN-CODE NOT = 2 THEN
                        DISPLAY '2-ERROR: ' RET-DISP ' ' FLAG-VAL
                        END-DISPLAY
                     END-IF
                  WHEN 3
                     IF RETURN-CODE NOT = -1 THEN
                        MOVE RETURN-CODE TO RET-DISP
                        DISPLAY 'last RETURN-CODE wrong: ' RET-DISP
                        END-DISPLAY
                     END-IF
                     EXIT PERFORM
               END-EVALUATE
            END-PERFORM.

            MOVE 0 TO RETURN-CODE.

            IF COUNTER NOT = 3 THEN
               MOVE RETURN-CODE TO RET-DISP
               DISPLAY 'CBL_GC_GETOPT returned -1 too early: ' COUNTER
               END-DISPLAY
            END-IF.

            STOP RUN.
])

AT_DATA([prog5.cob], [
        IDENTIFICATION DIVISION.
        PROGRAM-ID. prog5.
      *> check for wrong longoption structure
        DATA DIVISION.
        WORKING-STORAGE SECTION.
            01 SO PIC X.
            01 LO.
                05 OPTIONRECORD OCCURS 2 TIMES.
                    10 ONAME        PIC X(45).
                    10 HAS-VALUE    PIC 9.
                    10 VALPOINT     POINTER     VALUE NULL.
                    10 VAL          PIC X(4).
            01 LONGIND       PIC 99.
            01 LONG-ONLY     PIC 9 VALUE 1.
            01 RETURN-CHAR   PIC X(4).
            01 OPT-VAL       PIC X(10).
            01 RET-DISP      PIC S999 VALUE 0.

            01 COUNTER       PIC 9 VALUE 0.

            01 FLAG-VAL      PIC 9.
        PROCEDURE DIVISION.
            MOVE "super-long-option-with-more-than-25-bytes"
              TO ONAME(1).
            MOVE 0   TO HAS-VALUE(1).
            MOVE '1' TO VAL(1).

            MOVE "stupid-long-option-with-more-than-25-bytes"
              TO ONAME(2).
            MOVE 0   TO HAS-VALUE(2).
            MOVE '0' TO VAL(2).

            PERFORM WITH TEST AFTER
                    VARYING COUNTER FROM 0 BY 1
                    UNTIL RETURN-CODE = -1
               CALL 'CBL_GC_GETOPT' USING
                  BY REFERENCE SO LO LONGIND
                  BY VALUE     LONG-ONLY
                  BY REFERENCE RETURN-CHAR OPT-VAL
               END-CALL

               EVALUATE COUNTER
                  WHEN 0
                  WHEN 1
                  WHEN 2
                     CONTINUE

      *>       MOVE RETURN-CODE TO RET-DISP

      *>       IF COUNTER = 0 AND RETURN-CODE NOT = 1 THEN
      *>          DISPLAY 'RETURN VALUE: ' RET-DISP ' ' FLAG-VAL
      *>       END-IF
                  WHEN 3
                     IF RETURN-CODE NOT = -1 THEN
                        MOVE RETURN-CODE TO RET-DISP
                        DISPLAY 'last RETURN-CODE wrong: ' RET-DISP
                        END-DISPLAY
                     END-IF
                     EXIT PERFORM
               END-EVALUATE
            END-PERFORM.

            MOVE 0 TO RETURN-CODE.

            IF COUNTER NOT = 3 THEN
               MOVE RETURN-CODE TO RET-DISP
               DISPLAY 'CBL_GC_GETOPT returned -1 too early: ' COUNTER
               END-DISPLAY
            END-IF.

            STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog --version --verbose -jkl], [0], [])
AT_CHECK([$COMPILE_MODULE prog2.cob], [0], [], [])
AT_CHECK([$COBCRUN prog2 --ver --vers], [0], [],
[prog2: option '--ver' is ambiguous; possibilities: '--version' '--verbose'
])
AT_CHECK([$COMPILE prog3.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog3 --version=lang --verbose=k --usage -j 5 -k6 -l], [0], [])
AT_CHECK([$COMPILE prog4.cob --free], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog4 --static --dynamic --usage=boringandtoolongtext], [0], [])
# Again a long and system specific error message which we ignore.
# Return code 1 is sufficient as proof of hard return (as wanted).
AT_CHECK([$COMPILE prog5.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog5 --static], [1], [],
[libcob: prog5.cob:37: error: Call to CBL_GC_GETOPT with wrong longoption size.
])

AT_CLEANUP


AT_SETUP([System routine CBL_GC_FORK])
AT_KEYWORDS([extensions C$GETPID])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       77 CHILD-PID   USAGE BINARY-LONG.
       77 PARENT-PID  USAGE BINARY-LONG.
       PROCEDURE DIVISION.

           CALL "C$GETPID" RETURNING PARENT-PID
           CALL "CBL_GC_FORK" END-CALL
           EVALUATE RETURN-CODE
              WHEN ZERO
                 PERFORM CHILD-CODE
              WHEN -1
                 STOP RUN RETURNING 77 *> skip test
              WHEN OTHER
                 PERFORM PARENT-CODE
           END-EVALUATE

           STOP RUN.

       CHILD-CODE.
           CALL "C$SLEEP"  USING 1.
           DISPLAY "Hello, I am the child".
           CALL "C$GETPID" RETURNING CHILD-PID.
           IF CHILD-PID = PARENT-PID
              DISPLAY "CHILD: parent and child have same PID: "
                      "'" CHILD-PID "'" UPON SYSERR
              END-DISPLAY
           END-IF.
           MOVE 0 TO RETURN-CODE.

       PARENT-CODE.
           DISPLAY "Hello, I am the parent".
           CALL "C$SLEEP"  USING 4.
           DISPLAY "Parent again".
           IF RETURN-CODE = PARENT-PID
              DISPLAY "PARENT: parent and child have same PID: "
                      "'" PARENT-PID "'" UPON SYSERR
              END-DISPLAY
           END-IF.
           CALL "C$GETPID".
           IF RETURN-CODE NOT = PARENT-PID
              DISPLAY "PARENT: parent PID has changed: "
                      "'" PARENT-PID "' -> '" RETURN-CODE "'"
                      UPON SYSERR
              END-DISPLAY
           END-IF.
           MOVE 0 TO RETURN-CODE.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [Hello, I am the parent
Hello, I am the child
Parent again
], [])

AT_CLEANUP


# Placed as extra routine as we should find a way to test this
# without CBL_GC_FORK (which isn't available on all systems where
# CBL_GC_WAITPID is available, for example MINGW)
AT_SETUP([System routine CBL_GC_WAITPID])
AT_KEYWORDS([extensions CBL_GC_FORK])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01 CHILD-PID   PIC S9(9) BINARY.
       01 WAIT-STS    PIC S9(9) BINARY VALUE -3.
       PROCEDURE DIVISION.

           CALL "CBL_GC_FORK" RETURNING CHILD-PID.
           EVALUATE CHILD-PID
              WHEN ZERO
                 PERFORM CHILD-CODE
              WHEN -1
                 STOP RUN RETURNING 77 *> skip test
              WHEN OTHER
                 PERFORM PARENT-CODE
           END-EVALUATE.

           STOP RUN.

       CHILD-CODE.
           CALL "C$SLEEP" USING 1.
           DISPLAY "Hello, I am the child".
           MOVE 2 TO RETURN-CODE.

       PARENT-CODE.
           DISPLAY "Hello, I am the parent".
           CALL "CBL_GC_WAITPID" USING CHILD-PID
              RETURNING WAIT-STS
           END-CALL
           MOVE 0 TO RETURN-CODE
           IF WAIT-STS = -1
              STOP RUN RETURNING 77 *> skip test
           END-IF
           DISPLAY "Child ended status " WAIT-STS
           END-DISPLAY.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [Hello, I am the parent
Hello, I am the child
Child ended status +000000002
], [])

AT_CLEANUP


AT_SETUP([System routine CBL_GC_HOSTED])
AT_KEYWORDS([extensions errno EXTERNAL BASED POINTER])

AT_DATA([test_errno.c], [
#include <errno.h>
#include <stdio.h>

#include <libcob.h>

COB_EXT_EXPORT int
test_errno(void)
{
    FILE *fail;
    fail = fopen("file-not-to-be-found", "r");
    if (errno != 2) {
        printf("BAD ERRNO %d", errno);
    } else {
        if (fail) fclose(fail);
    }
    return 0;
}
])

AT_DATA([test_stdio.c], [
#include <stdio.h>

#include <libcob.h>
COB_EXT_EXPORT int
test_stdio(FILE *si, FILE *so, FILE *se)
{
    if (feof(si)) {
        fprintf(se, "BAD STDIN EOF\n");
    }
    fprintf(so, "OUT");
    return fprintf(se, "ERR");
}
])
AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01 STDIN    USAGE POINTER.
       01 STDOUT   USAGE POINTER.
       01 STDERR   USAGE POINTER.
       01 CELL     USAGE BINARY-LONG.
       01 ARGC     USAGE BINARY-LONG.
       01 ARGV     USAGE POINTER.
       01 ERRPTR   USAGE POINTER.
       01 ERRNO    USAGE BINARY-LONG BASED.
       01 CERRNO   USAGE BINARY-LONG EXTERNAL AS "errno".
       01 TZNAME   USAGE POINTER.
       01 TZNAMES  USAGE POINTER BASED.
          05 TZS      USAGE POINTER OCCURS 2 TIMES.
       01 TIMEZONE USAGE BINARY-C-LONG.
       01 DAYLIGHT USAGE BINARY-LONG.
       01 EXTPTR   USAGE POINTER. *> only for the check, otherwise unused

       PROCEDURE DIVISION.
           CALL "CBL_GC_HOSTED" USING STDIN "stdin"
           CALL "CBL_GC_HOSTED" USING STDOUT "stdout"
           CALL "CBL_GC_HOSTED" USING STDERR "stderr"
      *> verify working alias with old name "CBL_OC_HOSTED"
           CALL "CBL_OC_HOSTED" USING ARGC "argc"
           CALL "CBL_OC_HOSTED" USING ARGV "argv"
           CALL "CBL_GC_HOSTED" USING CELL "cell"
           CALL "CBL_GC_HOSTED" USING ERRPTR "errno"
           CALL "CBL_GC_HOSTED" USING ARGC "arg"
           CALL "CBL_GC_HOSTED" USING NULL "argc"
           SET ADDRESS OF ERRNO TO ERRPTR
           CALL "CBL_GC_HOSTED" USING TZNAME "tzname"
           CALL "CBL_GC_HOSTED" USING TIMEZONE "timezone"
           CALL "CBL_GC_HOSTED" USING DAYLIGHT "daylight"

      *> prog.cob must be compiled with same C runtime as libcob to match...
           IF ERRPTR NOT EQUAL ADDRESS OF CERRNO
              DISPLAY "ADDRESS OF ERRNO VARIABLES DON'T MATCH"
              SET EXTPTR TO ADDRESS OF CERRNO
              DISPLAY "HOSTED: "   ERRPTR ", "
                      "EXTERNAL: " EXTPTR
              END-DISPLAY
           END-IF

      *> test_errno.c must be compiled with same C runtime as libcob to match...
           CALL "test_errno"
           IF ERRNO NOT EQUAL 2 THEN
              DISPLAY "BAD HOSTED ERRNO " ERRNO
              IF CERRNO NOT EQUAL 2 THEN
                 DISPLAY "BAD EXTERNAL ERRNO " CERRNO
              END-IF
           END-IF

           IF ARGC NOT EQUAL 2 THEN
              DISPLAY "BAD ARGC " ARGC
           END-IF
           IF ARGV EQUAL NULL THEN
              DISPLAY "BAD ARGV"
           END-IF

           IF CELL LESS THAN 0 OR GREATER THAN 8 THEN
              DISPLAY "UNK CELL " CELL
           END-IF

           SET ENVIRONMENT "TZ" TO "PST8PDT"
           CALL "tzset" RETURNING OMITTED
              ON EXCEPTION CONTINUE
           END-CALL
           IF TZNAME NOT EQUAL NULL THEN
              SET ADDRESS OF TZNAMES TO TZNAME
              IF TZS(1) EQUAL NULL THEN
                 DISPLAY "BAD TZNAME" END-DISPLAY
              END-IF
           END-IF

      *> Test assumes return-code will be 3, chars output by last fprintf
      *> test_stdio.c must be compiled with same C runtime as libcob to match...
           CALL "test_stdio" USING BY VALUE STDIN STDOUT STDERR
           END-CALL

           STOP RUN.
])

AT_CHECK([$COMPILE_MODULE test_errno.c], [0], [], [])
AT_CHECK([$COMPILE_MODULE test_stdio.c], [0], [], [])
AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog 1ARG], [3], [OUT], [ERR])

AT_CLEANUP


AT_SETUP([System routine SYSTEM, parameter handling])
AT_KEYWORDS([CHAINING TRIM])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.

       DATA DIVISION.
       WORKING-STORAGE SECTION.
      *
       77  test-no                    PIC 9 VALUE 0.
       77  chaining-param             PIC X(20).
       77  chaining-param-2           PIC X(20).
      *
       PROCEDURE DIVISION CHAINING chaining-param, chaining-param-2.
      *
       main.
           EVALUATE chaining-param ALSO chaining-param-2
              WHEN SPACES  ALSO SPACES
                 DISPLAY "started without options - closing"
              WHEN "1"     ALSO SPACES
              WHEN '"1"'   ALSO SPACES
              WHEN "a v"   ALSO SPACES
              WHEN '"a v"' ALSO SPACES
                 DISPLAY "  called with -"
                         function trim (chaining-param) "-"
              WHEN "a"    ALSO "v"
                 DISPLAY "  called with -"
                         FUNCTION TRIM (chaining-param) "-"
                         " and with -"
                         FUNCTION TRIM (chaining-param-2) "-"
              WHEN "start" ALSO SPACES
                 MOVE 'prog 1'         TO chaining-param
                 PERFORM callme
                 MOVE 'prog "1"'       TO chaining-param
                 PERFORM callme
                 MOVE '"prog" 1'       TO chaining-param
                 PERFORM callme
                 MOVE '"prog" "1"'     TO chaining-param
                 PERFORM callme
                 MOVE 'prog a v'       TO chaining-param
                 PERFORM callme
                 MOVE 'prog "a v"'     TO chaining-param
                 PERFORM callme
                 MOVE '"prog" a v'     TO chaining-param
                 PERFORM callme
                 MOVE '"prog" "a v"'   TO chaining-param
                 PERFORM callme
                 MOVE '"prog" "a" "v"' TO chaining-param
                 PERFORM callme
                 DISPLAY "tests finished"
              WHEN OTHER
                 DISPLAY "called with unexpected -"
                         FUNCTION TRIM (chaining-param) "-"
           END-EVALUATE
           STOP RUN.
      *
       callme.
           ADD  1 TO test-no.
           DISPLAY "Test #" test-no ":"
           DISPLAY "  CALL 'SYSTEM' with "
                   FUNCTION TRIM (chaining-param) ":"
           CALL "SYSTEM" USING FUNCTION TRIM (chaining-param)
           DISPLAY "  --> return of the given CALL 'SYSTEM': "
                   return-code.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([PATH=.:$PATH $COBCRUN_DIRECT prog "start"], [0],
[Test #1:
  CALL 'SYSTEM' with prog 1:
  called with -1-
  --> return of the given CALL 'SYSTEM': +000000000
Test #2:
  CALL 'SYSTEM' with prog "1":
  called with -1-
  --> return of the given CALL 'SYSTEM': +000000000
Test #3:
  CALL 'SYSTEM' with "prog" 1:
  called with -1-
  --> return of the given CALL 'SYSTEM': +000000000
Test #4:
  CALL 'SYSTEM' with "prog" "1":
  called with -1-
  --> return of the given CALL 'SYSTEM': +000000000
Test #5:
  CALL 'SYSTEM' with prog a v:
  called with -a- and with -v-
  --> return of the given CALL 'SYSTEM': +000000000
Test #6:
  CALL 'SYSTEM' with prog "a v":
  called with -a v-
  --> return of the given CALL 'SYSTEM': +000000000
Test #7:
  CALL 'SYSTEM' with "prog" a v:
  called with -a- and with -v-
  --> return of the given CALL 'SYSTEM': +000000000
Test #8:
  CALL 'SYSTEM' with "prog" "a v":
  called with -a v-
  --> return of the given CALL 'SYSTEM': +000000000
Test #9:
  CALL 'SYSTEM' with "prog" "a" "v":
  called with -a- and with -v-
  --> return of the given CALL 'SYSTEM': +000000000
tests finished
])

AT_CLEANUP


AT_SETUP([System routine CBL_EXIT_PROC])
AT_KEYWORDS([extensions])

# tests that exit handlers work including multiple error handlers

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. DemoExtProc IS RECURSIVE.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       77  Ext-Proc-Address            USAGE PROCEDURE-POINTER.
       77  install-flag                USAGE BINARY-CHAR.
           88  install-default         VALUE 0.
           88  uninstall               VALUE 1.
           88  query-priority          VALUE 2.
           88  install-priority        VALUE 3.
       01  exit-params.
           02  proc-addrs              USAGE PROCEDURE-POINTER.
           02  ppriority               USAGE BINARY-CHAR.
       PROCEDURE DIVISION.
       S1.
           DISPLAY 'Program is starting'
      *>   Do this for the ACU test later
      *>   CALL 'CBL_EXIT_PROC' USING 0, "ExtProc-internal"
           SET Ext-Proc-Address TO ENTRY 'ExtProc'
      *>   GC "simple variant"
           CALL 'CBL_EXIT_PROC' USING 0, Ext-Proc-Address
      *>   Support for MF variant,
      *>   storing but otherwise ignoring the priority for now
           SET install-default  TO TRUE
           SET proc-addrs       TO ENTRY 'ExtProc-internal'
           CALL 'CBL_EXIT_PROC' USING install-flag, exit-params
      *>   Ensure subsequent CALLs with the same one are seen as error (MF!)
           SET proc-addrs       TO ENTRY 'ExtProc'
           CALL 'CBL_EXIT_PROC' USING install-flag, exit-params
           IF RETURN-CODE = 0
              DISPLAY 'Unexpected RETURN-CODE with subsequent call '
                       RETURN-CODE.
           SET install-priority TO TRUE
           MOVE 127             TO ppriority
           CALL 'CBL_EXIT_PROC' USING install-flag, exit-params
           IF RETURN-CODE NOT = 0
              DISPLAY 'Unexpected RETURN-CODE with subsequent call, '
                      'different priority ' RETURN-CODE.
           SET proc-addrs       TO ENTRY 'ExtProc-internal2'
           CALL 'CBL_EXIT_PROC' USING install-flag, exit-params
           IF RETURN-CODE NOT = 0
              DISPLAY 'Unexpected RETURN-CODE with new call '
                       RETURN-CODE.
      *>
           DISPLAY 'Program is stopping'
           STOP RUN
           .
       ENTRY 'ExtProc-internal2'.
           DISPLAY 'Exit procedure from ' FUNCTION MODULE-ID ()
           SET Ext-Proc-Address TO ENTRY 'ExtProc'
           SET query-priority TO TRUE
           MOVE 0             TO ppriority
           CALL 'CBL_EXIT_PROC' USING install-flag, exit-params
           IF RETURN-CODE NOT = ZERO
              DISPLAY 'Unexpected RETURN-CODE for query '
                       RETURN-CODE
           ELSE IF ppriority NOT = 127
              DISPLAY 'Unexpected priority external ' ppriority.
           SET proc-addrs       TO ENTRY 'ExtProc-internal'
           CALL 'CBL_EXIT_PROC' USING install-flag, exit-params
           IF RETURN-CODE NOT = ZERO
              DISPLAY 'Unexpected RETURN-CODE for query '
                       RETURN-CODE
           ELSE IF ppriority NOT = 64
              DISPLAY 'Unexpected priority internal ' ppriority.
           SET uninstall      TO TRUE
           CALL 'CBL_EXIT_PROC' USING install-flag, exit-params
           IF RETURN-CODE NOT = 0
              DISPLAY 'Unexpected RETURN-CODE after uninstall '
                       RETURN-CODE.
           CALL 'CBL_EXIT_PROC' USING install-flag, exit-params
           IF RETURN-CODE = 0
              DISPLAY 'Unexpected RETURN-CODE after double uninstall '
                       RETURN-CODE.
           MOVE 0 TO RETURN-CODE
           GOBACK
           .
       ENTRY 'ExtProc-internal'.
           DISPLAY 'should have been removed'
           GOBACK
           .
       END PROGRAM DemoExtProc.

       IDENTIFICATION DIVISION.
       PROGRAM-ID. ExtProc.
       PROCEDURE DIVISION.
       000-Main.
           DISPLAY 'Exit procedure from ' FUNCTION MODULE-ID ()
           EXIT PROGRAM
           .
       END PROGRAM ExtProc.
])
AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[Program is starting
Program is stopping
Exit procedure from DemoExtProc
Exit procedure from ExtProc
], [])

AT_CLEANUP


AT_SETUP([System routine CBL_ERROR_PROC (1)])
AT_KEYWORDS([extensions exceptions error
EXCEPTION-LOCATION EXCEPTION-STATEMENT EXCEPTION-FILE EXCEPTION-STATUS])

# tests that error handlers work (later for ACU: test for re-ordered)
# including multiple error handlers

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. DemoErrProc IS RECURSIVE.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       77  Err-Proc-Address            USAGE PROGRAM-POINTER.
       77  Err-Message-Len             PIC 9(04) USAGE COMP-5.
       LINKAGE SECTION.
       77  Err-Message-From-Runtime    PIC X(1023).
       PROCEDURE DIVISION.
       S1.
           DISPLAY 'Program is starting'
      *>   Do this for the ACU test, where second call moves top front
      *>   SET Err-Proc-Address TO ENTRY 'ErrProc-internal'
      *>   CALL 'CBL_ERROR_PROC' USING 0, Err-Proc-Address
           SET Err-Proc-Address TO ENTRY 'ErrProc'
           CALL 'CBL_ERROR_PROC' USING 0, Err-Proc-Address
           SET Err-Proc-Address TO ENTRY 'ErrProc-internal'
           CALL 'CBL_ERROR_PROC' USING 0, Err-Proc-Address
      *>   Ensure subsequent CALLs with the same one are ignored (MF!)
           SET Err-Proc-Address TO ENTRY 'ErrProc'
           CALL 'CBL_ERROR_PROC' USING 0, Err-Proc-Address
           SET Err-Proc-Address TO NULL
           CALL 'Tilt' *> THIS DOESN'T EXIST!!!!
           DISPLAY 'Program is stopping'
           STOP RUN
           .
       ENTRY 'ErrProc-internal' USING Err-Message-From-Runtime.
           DISPLAY 'Error (internal): ' FUNCTION EXCEPTION-LOCATION  '-'
           DISPLAY '                  ' FUNCTION EXCEPTION-STATEMENT '-'
           DISPLAY '                  ' FUNCTION EXCEPTION-STATUS    '-'
           *> NOTE: the error message is *EXPLICIT* specified to end with x'00'
           MOVE 0 TO Err-Message-Len
           INSPECT Err-Message-From-Runtime
              TALLYING Err-Message-Len FOR CHARACTERS BEFORE x'00'
           DISPLAY 'Error-Message:    ' Err-Message-From-Runtime
                                       (1:Err-Message-Len)
           DISPLAY '-*- Returning to Next Error Routine -*-'
           MOVE    1         TO RETURN-CODE
           EXIT PROGRAM
           .
       END PROGRAM DemoErrProc.

       IDENTIFICATION DIVISION.
       PROGRAM-ID. ErrProc.
       PROCEDURE DIVISION.
       000-Main.
           DISPLAY 'Error: ' FUNCTION EXCEPTION-LOCATION  '-'
           DISPLAY '       ' FUNCTION EXCEPTION-STATEMENT '-'
           DISPLAY '       ' FUNCTION EXCEPTION-STATUS    '-'
           DISPLAY '-*- Returning to Standard Error Routine -*-'
           MOVE    1         TO RETURN-CODE
           EXIT PROGRAM
           .
       END PROGRAM ErrProc.
])
AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [1],
[Program is starting
Error (internal): DemoErrProc; S1; 25-
                  CALL                           -
                  EC-PROGRAM-NOT-FOUND           -
Error-Message:    prog.cob:25: module 'Tilt' not found
-*- Returning to Next Error Routine -*-
Error: DemoErrProc; S1; 25-
       CALL                           -
       EC-PROGRAM-NOT-FOUND           -
-*- Returning to Standard Error Routine -*-
],
[libcob: prog.cob:25: error: module 'Tilt' not found
])

AT_CHECK([$COBC -x -o prog_noloc prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog_noloc], [1],
[Program is starting
Error (internal):  -
                                                 -
                  EC-PROGRAM-NOT-FOUND           -
Error-Message:    module 'Tilt' not found
-*- Returning to Next Error Routine -*-
Error:  -
                                      -
       EC-PROGRAM-NOT-FOUND           -
-*- Returning to Standard Error Routine -*-
],
[libcob: error: module 'Tilt' not found
])

AT_CLEANUP


AT_SETUP([System routine CBL_ERROR_PROC (2)])
AT_KEYWORDS([extensions exceptions error LOCAL-STORAGE RECURSIVE
EXCEPTION-LOCATION EXCEPTION-STATEMENT EXCEPTION-FILE EXCEPTION-STATUS])

# tests that error handlers can stop the processing,
# including the internal error handler
# and that the MF "LOCAL-STORAGE implies RECURSIVE" works

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. DemoErrProc.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       77  Err-Proc-Address            USAGE PROGRAM-POINTER.
       77  Err-Message-Len             PIC 9(04) USAGE COMP-5.
       LOCAL-STORAGE SECTION.  *> can even be empty...
       LINKAGE SECTION.
       77  Err-Message-From-Runtime    PIC X(1023).
       PROCEDURE DIVISION.
       S1.
           DISPLAY 'Program is starting'
           SET Err-Proc-Address TO ENTRY 'ErrProc'
           CALL 'CBL_ERROR_PROC' USING 0, Err-Proc-Address
           SET Err-Proc-Address TO ENTRY 'ErrProc-internal'
           CALL 'CBL_ERROR_PROC' USING 0, Err-Proc-Address
           SET Err-Proc-Address TO NULL
           CALL 'Tilt' *> THIS DOESN'T EXIST!!!!
           DISPLAY 'Program is stopping'
           STOP RUN
           .
       ENTRY 'ErrProc-internal' USING Err-Message-From-Runtime.
           DISPLAY 'Error (interal): ' FUNCTION EXCEPTION-LOCATION  '-'
           DISPLAY '                 ' FUNCTION EXCEPTION-STATEMENT '-'
           DISPLAY '                 ' FUNCTION EXCEPTION-STATUS    '-'
           *> NOTE: the error message is *EXPLICIT* specified to end with x'00'
           MOVE 0 TO Err-Message-Len
           INSPECT Err-Message-From-Runtime
              TALLYING Err-Message-Len FOR CHARACTERS BEFORE x'00'
           DISPLAY 'Error-Message:   ' Err-Message-From-Runtime
                                       (1:Err-Message-Len)
           DISPLAY '-*- Stop error routines here -*-'
           MOVE    0         TO RETURN-CODE
           EXIT PROGRAM
           .
       END PROGRAM DemoErrProc.

       IDENTIFICATION DIVISION.
       PROGRAM-ID. ErrProc.
       PROCEDURE DIVISION.
       000-Main.
           DISPLAY 'Error: ' FUNCTION EXCEPTION-LOCATION  '-'
           DISPLAY '       ' FUNCTION EXCEPTION-STATEMENT '-'
           DISPLAY '       ' FUNCTION EXCEPTION-STATUS    '-'
           DISPLAY '-*- Returning to Standard Error Routine -*-'
           MOVE    1         TO RETURN-CODE
           EXIT PROGRAM
           .
       END PROGRAM ErrProc.
])
AT_CHECK([$COMPILE -std=mf prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [1],
[Program is starting
Error (interal): DemoErrProc; S1; 20-
                 CALL                           -
                 EC-PROGRAM-NOT-FOUND           -
Error-Message:   prog.cob:20: module 'Tilt' not found
-*- Stop error routines here -*-
], [])

# to be done
#AT_CHECK([$COMPILE -o prog_noloc prog.cob], [0], [], [])
#AT_CHECK([$COBCRUN_DIRECT ./prog_noloc], [1],
#[Program is starting
#],
#[libcob: error: recursive CALL from 'DemoErrProc' to 'DemoErrProc' which is NOT RECURSIVE
#])

AT_CLEANUP


AT_SETUP([CALL own PROGRAM-ID and RECURSIVE attribute])
AT_KEYWORDS([extensions exceptions])

# mixed syntax and runtime test, may be split later

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       78  own-prog                VALUE 'prog'.
       77  first-call        PIC X VALUE ' '.
       PROCEDURE DIVISION.
       T1.
           IF first-call = SPACE
              MOVE 'X' TO first-call
              CALL own-prog.
           GOBACK.
])
AT_CHECK([$COMPILE prog.cob], [0], [],
[prog.cob: in paragraph 'T1':
prog.cob:12: warning: CALL to own PROGRAM-ID used
prog.cob:12: note: assuming RECURSIVE attribute
])

AT_CHECK([$COMPILE -fself-call-recursive=error prog.cob], [1], [],
[prog.cob: in paragraph 'T1':
prog.cob:12: error: CALL to own PROGRAM-ID used
])

AT_CHECK([$COMPILE -o prog_std -std=mf prog.cob], [0], [], [])

AT_DATA([progc.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       77  first-call        PIC X VALUE ' '.
       PROCEDURE DIVISION.
       T2.
           IF first-call NOT = SPACE
              GOBACK.
           MOVE 'X' TO first-call
       COPY "cllprg.cpy".
           GOBACK.
])
AT_DATA([cllprg.cpy], [
           CALL 'prog'.
])
AT_CHECK([$COMPILE progc.cob], [0], [],
[cllprg.cpy: in paragraph 'T2':
cllprg.cpy:2: warning: CALL to own PROGRAM-ID used
cllprg.cpy:2: note: assuming RECURSIVE attribute
])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./progc], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog_std], [1], [],
[libcob: prog.cob:12: error: recursive CALL from 'prog' to 'prog' which is NOT RECURSIVE
])

AT_CLEANUP


AT_SETUP([DISPLAY DIRECTIVE and $DISPLAY])
AT_KEYWORDS([extensions])

# note: as we do support inline comments here we do not
#       allow the * to be part of a non-literal output

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01 var1          pic x.
       $DISPLAY  MF compile time text # A.0-B;C *> without comment
       01 var2          pic x.
       >> DISPLAY some.text-here
       01 var3          pic x.
       PROCEDURE        DIVISION.
       >> DISPLAY   other  text #2  *> comment
       >> DISPLAY  "literal text...  *> no comment"
       $DISPLAY  "MF compile time text"
           GOBACK.
])

AT_CHECK([$COMPILE prog.cob], [0],
[MF compile time text # A.0-B;C
some.text-here
other  text #2
literal text...  *> no comment
MF compile time text
])
AT_CLEANUP


AT_SETUP([Conditional / define directives (1)])
AT_KEYWORDS([extensions directive])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       PROCEDURE        DIVISION.
       >>IF ACTIVATE NOT DEFINED
           DISPLAY "OK" NO ADVANCING
           END-DISPLAY
       >>ELSE
           DISPLAY "NOTOK" NO ADVANCING
           END-DISPLAY
       >>END-IF
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [OK], [])

AT_CLEANUP


AT_SETUP([Conditional / define directives (2)])
AT_KEYWORDS([extensions directive])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       PROCEDURE        DIVISION.
       >>IF ACTIVATE DEFINED
           DISPLAY "OK" NO ADVANCING
           END-DISPLAY
       >>ELSE
           DISPLAY "NOTOK" NO ADVANCING
           END-DISPLAY
       >>END-IF
           STOP RUN.
])

AT_CHECK([$COMPILE -DACTIVATE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [OK], [])

AT_CLEANUP


AT_SETUP([Conditional / define directives (3)])
AT_KEYWORDS([extensions directive])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       PROCEDURE        DIVISION.
       >>IF ACTIVATE DEFINED
           DISPLAY "NOTOK" NO ADVANCING
           END-DISPLAY
       >>ELIF ACTIVATE2 DEFINED
           DISPLAY "OK" NO ADVANCING
           END-DISPLAY
       >>ELSE
           DISPLAY "NOTOK" NO ADVANCING
           END-DISPLAY
       >>END-IF
           STOP RUN.
])

AT_CHECK([$COMPILE -DACTIVATE2 prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [OK], [])

AT_CLEANUP


AT_SETUP([Conditional / define directives (4)])
AT_KEYWORDS([extensions directive])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       PROCEDURE        DIVISION.
       >>IF ACTIVATE DEFINED
           DISPLAY "NOTOK" NO ADVANCING
           END-DISPLAY
       >>ELIF ACTIVATE2 DEFINED
       >>ELSE
           DISPLAY "NOTOK" NO ADVANCING
           END-DISPLAY
       >>END-IF
           STOP RUN.
])

AT_CHECK([$COMPILE -DACTIVATE2 prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([Invalid source format])
AT_KEYWORDS([extensions runmisc])

AT_DATA([unknown.cob], [
       >>SOURCE FORMAT UNKNOWN
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       PROCEDURE DIVISION.
          STOP RUN.
])
AT_DATA([lit.cob], [
       >>SOURCE FORMAT "literal"
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       PROCEDURE DIVISION.
          STOP RUN.
])

AT_CHECK([$COMPILE unknown.cob], [1], [],
[unknown.cob:2: error: invalid SOURCE directive option 'UNKNOWN'
])
AT_CHECK([$COMPILE lit.cob], [1], [],
[lit.cob:2: error: invalid SOURCE directive option
lit.cob:2: error: PROGRAM-ID header missing
])

AT_CLEANUP


AT_SETUP([Variable format])
AT_KEYWORDS([extensions runmisc])

AT_DATA([prog.cob], [
       >>SOURCE FORMAT VARIABLE
000010 IDENTIFICATION DIVISION.
000020 PROGRAM-ID. prog.
000030* blah blah blah
000040 PROCEDURE DIVISION.
000050                                                                  DISPLAY "Hello!"
000060     .
000070 END PROGRAM prog.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[Hello!
])

# Check that manually setting -ftext-column in combination with
# variable source format isstill allowed: -ftext-column now impacts
# fixed format only; 250 is the default right margin for variable
# format.
AT_DATA([fit.cob], [
000010 IDENTIFICATION DIVISION.
000020 PROGRAM-ID. fit.
000040 PROCEDURE DIVISION.
000050                                                                                                                                                                                                                                    DISPLAY "Hello!"
000060     STOP RUN.
])
AT_CHECK([$COMPILE -fformat=variable -ftext-column=250 fit.cob], [0], [], [])
AT_CHECK([$COMPILE -fformat=variable -ftext-column=72 -o fit fit.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./fit], [0],
[Hello!
])

AT_CLEANUP


AT_SETUP([COBOLX format])
AT_KEYWORDS([extensions runmisc])

AT_DATA([prog.cob], [
       >>SOURCE FORMAT COBOLX
 IDENTIFICATION DIVISION.
 PROGRAM-ID. prog.
* area B can extend up to character position 255
 PROCEDURE DIVISION.
/
                                                        DISPLAY "Hello!"
                                                                                                                                                                                                                                                  DISPLAY "Hi!"
DDISPLAY "Hey!"
D                                                         DISPLAY "Bye!"
* trucated alphanumeric literals are not padded with spaces
 DISPLAY "        20        30        40        50        60        70        80        90       100       110       120       130
-        "       140       150       160       170       180       190       200       210       220       230       240       250"
 .
])
# " (closing quote)

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[Hello!
Hi!
        20        30        40        50        60        70        80        90       100       110       120       130       140       150       160       170       180       190       200       210       220       230       240       250
])
AT_CHECK([$COMPILE -fdebugging-line -o prog prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[Hello!
Hi!
Hey!
Bye!
        20        30        40        50        60        70        80        90       100       110       120       130       140       150       160       170       180       190       200       210       220       230       240       250
])

AT_CLEANUP


AT_SETUP([X/Open free-form format])
AT_KEYWORDS([fundamental xopen extensions])

AT_DATA([prog.cob], [
* Sample program in X/Open free-form format.

IDENTIFICATION   DIVISION.
PROGRAM-ID.      prog.
DATA             DIVISION.
WORKING-STORAGE  SECTION.
PROCEDURE        DIVISION.
/ Beginning of the code
DISPLAY "OK" NO ADVANCING
* If debug:
D DISPLAY "KO" NO ADVANCING
STOP RUN.
])

AT_CHECK([$COMPILE -fformat=xopen prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [OK], [])
AT_CHECK([$COMPILE -fformat=xopen -fdebugging-line -o prog prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [OKKO], [])

AT_DATA([fit.cob], [
* Sample program in X/Open format, and with longer lines and truncated literals.

IDENTIFICATION   DIVISION.
PROGRAM-ID.      fit.
DATA             DIVISION.
WORKING-STORAGE  SECTION.
PROCEDURE        DIVISION.
DISPLAY '         20        30        40        50        60        70       79'
D DISPLAY '       20        30        40        50        60        70       79'
STOP RUN.
])

AT_CHECK([$COMPILE -fformat=xopen fit.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./fit], [0],
[         20        30        40        50        60        70       79
], [])
AT_CHECK([$COMPILE -fformat=xopen -fdebugging-line -o fit fit.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./fit], [0],
[         20        30        40        50        60        70       79
       20        30        40        50        60        70       79
], [])

AT_CLEANUP


AT_SETUP([TERMINAL format])
AT_KEYWORDS([fundamental extensions])

# FIXME: For now, only comment paragraphs can be used to check proper
# handling of margin B w.r.t indicators; better tests shall be
# implemented once area A/B checking will be available

AT_DATA([prog.cob], [
* Sample program in ACU terminal format.

IDENTIFICATION   DIVISION.
PROGRAM-ID.      prog.
AUTHOR.
    Somebody.
\D    Somebody else.
    One last author.
DATA             DIVISION.
WORKING-STORAGE  SECTION.
PROCEDURE        DIVISION.
      DISPLAY "OK" NO ADVANCING
      END-DISPLAY.
\D    DISPLAY "KO" NO ADVANCING
\D    END-DISPLAY.
      STOP RUN.
])

AT_CHECK([$COMPILE -fformat=terminal -fcomment-paragraphs=ok prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [OK], [])
AT_CHECK([$COMPILE -fformat=terminal -fcomment-paragraphs=ok -fdebugging-line -o prog prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [OKKO], [])

AT_DATA([marginberr.cob], [
IDENTIFICATION   DIVISION.
PROGRAM-ID.      marginberr.
AUTHOR.
* Comment paragraph where margin B depends on indicator width:
    Somebody
\D   Somebody else.
DATA             DIVISION.
WORKING-STORAGE  SECTION.
PROCEDURE        DIVISION.
      DISPLAY "OK" NO ADVANCING
      STOP RUN.
])

AT_CHECK([$COMPILE -fformat=terminal -fcomment-paragraphs=ok -fdebugging-line marginberr.cob], [1], [],
[marginberr.cob:7: error: ENVIRONMENT DIVISION header missing
marginberr.cob:7: error: CONFIGURATION SECTION header missing
marginberr.cob:7: error: SPECIAL-NAMES header missing
marginberr.cob:7: error: invalid system-name 'Somebody'
marginberr.cob:7: error: syntax error, unexpected ELSE, expecting CRT or Identifier
])

AT_DATA([fit.cob], [
* Sample program in ACU terminal format, and with longer lines and truncated literals.

IDENTIFICATION   DIVISION.
PROGRAM-ID.      fit.
DATA             DIVISION.
WORKING-STORAGE  SECTION.
PROCEDURE        DIVISION.
      DISPLAY '   20        30        40        50        60        70        80        90       100       110       120       130       140       150       160       170       180       190       200       210       220       230       240       250       260       270       280       290       300       310      319'
\D    DISPLAY '   20        30        40        50        60        70        80        90       100       110       120       130       140       150       160       170       180       190       200       210       220       230       240       250       260       270       280       290       300       310      319'
\D    END-DISPLAY.
      DISPLAY '   20        30        40        50        60        70        80        90       100       110       120       130
-             '       140       150       160       170       180       190       200       210       220       230       240       250       260       270       280       290       300       310      319'
      STOP RUN.
])

AT_CHECK([$COMPILE -fformat=terminal fit.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./fit], [0],
[   20        30        40        50        60        70        80        90       100       110       120       130       140       150       160       170       180       190       200       210       220       230       240       250       260       270       280       290       300       310      319
   20        30        40        50        60        70        80        90       100       110       120       130       140       150       160       170       180       190       200       210       220       230       240       250       260       270       280       290       300       310      319
], [])
AT_CHECK([$COMPILE -fformat=terminal -fdebugging-line -o fit fit.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./fit], [0],
[   20        30        40        50        60        70        80        90       100       110       120       130       140       150       160       170       180       190       200       210       220       230       240       250       260       270       280       290       300       310      319
   20        30        40        50        60        70        80        90       100       110       120       130       140       150       160       170       180       190       200       210       220       230       240       250       260       270       280       290       300       310      319
   20        30        40        50        60        70        80        90       100       110       120       130       140       150       160       170       180       190       200       210       220       230       240       250       260       270       280       290       300       310      319
], [])

AT_CLEANUP


AT_SETUP([Binary COMP-1 (1)])
AT_KEYWORDS([extensions])

AT_DATA([prog.cob], [
       IDENTIFICATION  DIVISION.
       PROGRAM-ID.     prog.

       DATA            DIVISION.
       WORKING-STORAGE SECTION.
       01  comp1       COMP-1.
       01  num         PIC 9.9.

       PROCEDURE       DIVISION.
           COMPUTE comp1 = 7 / 2
           MOVE comp1 TO num
           DISPLAY num
           .
])

AT_CHECK([$COMPILE -fbinary-comp-1 prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[3.0
])
AT_CHECK([$COMPILE -fno-binary-comp-1 prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[3.5
])

AT_CLEANUP


AT_SETUP([Binary COMP-1 (2)])
AT_KEYWORDS([extensions directive])

AT_DATA([prog.cob], [
       >>IF BINARY-COMP-1 IS DEFINED
           $SET COMP-1(BINARY)
       >>ELSE
           $SET COMP1 "float"
       >>END-IF
       IDENTIFICATION  DIVISION.
       PROGRAM-ID.     prog.

       DATA            DIVISION.
       WORKING-STORAGE SECTION.
       01  comp1       COMP-1.
       01  num         PIC 9.9.

       PROCEDURE       DIVISION.
           COMPUTE comp1 = 7 / 2
           MOVE comp1 TO num
           DISPLAY num
           .
])

AT_CHECK([$COMPILE -DBINARY-COMP-1 prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[3.0
])
AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[3.5
])

AT_CLEANUP


AT_SETUP([EXHIBIT statement])
AT_KEYWORDS([extensions osvs SORt-RETURN TALLY])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       77 VAR-1         PIC X(8) VALUE SPACES.
       77 VAR-2         PIC 999.
       PROCEDURE        DIVISION.
           EXHIBIT CHANGED VAR-1 'X'
           MOVE ALL 'X' TO VAR-1
           STRING "123" DELIMITED BY SIZE INTO VAR-1
           EXHIBIT NAMED VAR-1 VAR-2 'Y'
           EXHIBIT VAR-2
           EXHIBIT SORT-RETURN TALLY
           STOP RUN.
])

AT_CHECK([$COMPILE -std=mvs -Wno-strict-typing -Wno-pending prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[         X
VAR-1 = 123XXXXX VAR-2 = 000 Y
VAR-2 = 000
SORT-RETURN = +000000000 TALLY = 00000
])

AT_CLEANUP

AT_SETUP([Bit Operations])
AT_KEYWORDS([BIT-WISE])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01 X1  PIC X  COMP-X VALUE 0.
       01 X2  PIC X  COMP-X VALUE 0.
       01 X3  PIC X  COMP-X VALUE 0.
       01 XX1 PIC XX COMP-X VALUE 0.
       01 XX2 PIC XX COMP-X VALUE 0.
       01 XX3 PIC XX COMP-X VALUE 0.
       PROCEDURE DIVISION.
           MOVE 2 TO XX2 X2
           MOVE 4 TO XX3 X3.

           DISPLAY "Test using PIC XX COMP-X"
           COMPUTE XX1 = (XX2 B-OR XX3).
           DISPLAY XX2 " B-OR  " XX3 " is " XX1.
           MOVE 3 TO XX3.
           COMPUTE XX1 = (XX2 B-XOR XX3).
           DISPLAY XX2 " B-XOR " XX3 " is " XX1.
           MOVE 3 TO XX2
           MOVE 1 TO XX1.
           IF (XX2 B-AND XX1) = XX1
                DISPLAY XX2 " B-AND " XX1 " = " XX1 " TRUE"
            ELSE
                DISPLAY XX2 " B-AND " XX1 " = " XX1 " FALSE"
           END-IF.
           COMPUTE XX1 = (XX2 B-XOR XX3) + 1 .
           DISPLAY "(" XX2 " B-XOR " XX3 ") + 1 is " XX1.
           COMPUTE XX1 = XX2 B-XOR (XX3 + 1).
           DISPLAY XX2 " B-XOR (" XX3 " + 1) is " XX1.
           MOVE  x#09 TO XX3.
           MOVE  x#0E TO XX2.
           COMPUTE XX1 = XX2 B-AND XX3 .
           DISPLAY XX2 " B-AND " XX3 " is " XX1.
           COMPUTE XX1 = (x#05 B-OR x#22).
           DISPLAY "x#05 B-OR x#22 is " XX1.
           COMPUTE XX1 = B-NOT XX2 .
           DISPLAY "B-NOT " XX2 " is " XX1.
           COMPUTE XX1 = B-NOT x#22 .
           DISPLAY "B-NOT x#22 is " XX1.

           DISPLAY "  -----"
           DISPLAY "Test using PIC X COMP-X"
           COMPUTE X1 = (X2 B-OR X3).
           DISPLAY X2 " B-OR  " X3 " is " X1.
           MOVE 3 TO X3.
           COMPUTE X1 = (X2 B-XOR X3).
           DISPLAY X2 " B-XOR " X3 " is " X1.
           MOVE 3 TO X2
           MOVE 1 TO X1.
           IF (X2 B-AND X1) = X1
                DISPLAY X2 " B-AND " X1 " = " X1 " TRUE"
            ELSE
                DISPLAY X2 " B-AND " X1 " = " X1 " FALSE"
           END-IF.
           COMPUTE X1 = (X2 B-XOR X3) + 1 .
           DISPLAY "(" X2 " B-XOR " X3 ") + 1 is " X1.
           COMPUTE X1 = X2 B-XOR (X3 + 1).
           DISPLAY X2 " B-XOR (" X3 " + 1) is " X1.
           MOVE  x#09 TO X3.
           MOVE  x#0E TO X2.
           COMPUTE X1 = X2 B-AND X3 .
           DISPLAY X2 " B-AND " X3 " is " X1.
           COMPUTE X1 = B-NOT X2 .
           DISPLAY "B-NOT " X2 " is " X1.
           COMPUTE X1 = B-NOT x#22 .
           DISPLAY "B-NOT x#22 is " X1.
           STOP RUN.
])

AT_CHECK([$COMPILE -facu-literal=ok -fno-trunc prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[Test using PIC XX COMP-X
00002 B-OR  00004 is 00006
00002 B-XOR 00003 is 00001
00003 B-AND 00001 = 00001 TRUE
(00003 B-XOR 00003) + 1 is 00001
00003 B-XOR (00003 + 1) is 00007
00014 B-AND 00009 is 00008
x#05 B-OR x#22 is 00039
B-NOT 00014 is 65521
B-NOT x#22 is 65501
  -----
Test using PIC X COMP-X
002 B-OR  004 is 006
002 B-XOR 003 is 001
003 B-AND 001 = 001 TRUE
(003 B-XOR 003) + 1 is 001
003 B-XOR (003 + 1) is 007
014 B-AND 009 is 008
B-NOT 014 is 241
B-NOT x#22 is 221
], [])

AT_CLEANUP


AT_SETUP([Bit Shift Operations])
AT_KEYWORDS([BIT-WISE])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01 X1 PIC XX COMP-X VALUE 0.
       01 X2 PIC XX COMP-X VALUE 0.
       01 N1 PIC 9(4) COMP-5 VALUE 0.
       01 N2 PIC 9(4) COMP-5 VALUE 0.
       PROCEDURE DIVISION.
           MOVE  x#0A TO X2.
           DISPLAY "Using PIC XX COMP-X"
           COMPUTE X1 = (x#22 B-LEFT x#05).
           DISPLAY " x#22 B-LEFT  x#05   is " X1.
           COMPUTE X1 = (x#22 B-RIGHT x#02).
           DISPLAY " x#22 B-RIGHT x#02   is " X1.
           COMPUTE X1 = (x#22 B-SHIFT-L x#05).
           DISPLAY " x#22 B-SHIFT-L x#05 is " X1.
           COMPUTE X1 = (x#22 B-SHIFT-R x#02).
           DISPLAY " x#22 B-SHIFT-R x#02 is " X1.
           COMPUTE X1 = (X2 B-LEFT x#05).
           DISPLAY X2 " B-LEFT  x#05   is " X1.
           COMPUTE X1 = (X2 B-RIGHT x#02).
           DISPLAY X2 " B-RIGHT x#02   is " X1.
           MOVE  x#7573 TO X2.
           COMPUTE X1 = (X2 B-SHIFT-LC 4).
           DISPLAY X2 " B-SHIFT-LC 4   is " X1.
           COMPUTE X1 = (X2 B-SHIFT-RC 4).
           DISPLAY X2 " B-SHIFT-RC 4   is " X1.

           MOVE  10 TO N2.
           DISPLAY "Using PIC 9(4) COMP-5"
           COMPUTE N1 = (x#22 B-LEFT x#05).
           DISPLAY " x#22 B-LEFT  x#05   is " N1.
           COMPUTE N1 = (x#22 B-RIGHT x#02).
           DISPLAY " x#22 B-RIGHT x#02   is " N1.
           COMPUTE N1 = (x#22 B-SHIFT-L x#05).
           DISPLAY " x#22 B-SHIFT-L x#05 is " N1.
           COMPUTE N1 = (x#22 B-SHIFT-R x#02).
           DISPLAY " x#22 B-SHIFT-R x#02 is " N1.
           COMPUTE N1 = (N2 B-LEFT x#05).
           DISPLAY N2 " B-LEFT  x#05   is " N1.
           COMPUTE N1 = (N2 B-RIGHT x#02).
           DISPLAY N2 " B-RIGHT x#02   is " N1.
           STOP RUN.
])

# also syntax-checking MF aliases...
AT_CHECK([$COMPILE -std=mf -fno-trunc prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[Using PIC XX COMP-X
 x#22 B-LEFT  x#05   is 01088
 x#22 B-RIGHT x#02   is 00008
 x#22 B-SHIFT-L x#05 is 01088
 x#22 B-SHIFT-R x#02 is 00008
00010 B-LEFT  x#05   is 00320
00010 B-RIGHT x#02   is 00002
30067 B-SHIFT-LC 4   is 22327
30067 B-SHIFT-RC 4   is 14167
Using PIC 9(4) COMP-5
 x#22 B-LEFT  x#05   is 01088
 x#22 B-RIGHT x#02   is 00008
 x#22 B-SHIFT-L x#05 is 01088
 x#22 B-SHIFT-R x#02 is 00008
00010 B-LEFT  x#05   is 00320
00010 B-RIGHT x#02   is 00002
], [])

AT_CLEANUP


AT_SETUP([GCOS floating-point usages])
AT_KEYWORDS([gcos])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       01 FLOATS.
         03 FLOAT-BINARY-32  USAGE COMPUTATIONAL-9 VALUE -4.2E+1.
         03 FLOAT-BINARY-64  USAGE COMPUTATIONAL-10 VALUE 0.0.
         03 FLOAT-BINARY-128 USAGE COMPUTATIONAL-15 VALUE 1.0.

       PROCEDURE        DIVISION.
           DISPLAY FLOAT-BINARY-32

           DISPLAY FLOAT-BINARY-64
           MOVE 9.899999999999E+304 TO FLOAT-BINARY-64
           DISPLAY FLOAT-BINARY-64
           ADD -1.111111111011E302 TO FLOAT-BINARY-64
           DISPLAY FLOAT-BINARY-64

        *> NOTE: FLOAT-BINARY-128 is only syntax-checked as support for
        *> 128bit floating-point is still partial

           STOP RUN.
])

AT_CHECK([$COMPILE -std=gcos-strict prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[-42
0
9.899999999998999E+304
9.888888888888887E+304
], [])

AT_CLEANUP


AT_SETUP([PICTURE L])
AT_KEYWORDS([extensions gcos picture-l odo])

# Basic behaviors

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       1 W-DATA.
         2 X-DAT       PICTURE LX(10) DEPENDING ON LGX.
         2 X-ALPHA     PICTURE LA(10) DEPENDING ON LGX.
         2 Y-DAT       PICTURE LX(9) DEPENDING ON LGY.
         2 Y-ALPHA     PICTURE LA(9) DEPENDING ON LGY.
       1 W-NESTED.
         2 X-GRP.
           3 X-0       PICTURE X VALUE "0".
           3 X-V       PICTURE LX(10) DEPENDING ON LGX.
           3 X-1       PICTURE X VALUE "1".
       1 W-LGS.
          2 LGX         USAGE COMP-1 VALUE 10.
          2 LGY         PIC 9 VALUE 9.
       1 W-LEN          USAGE COMP-1.
       PROCEDURE        DIVISION.
       MAIN.
           MOVE SPACES TO W-DATA
           MOVE SPACES TO X-V
           IF X-DAT   NOT EQUAL "          " OR
              X-ALPHA NOT EQUAL "          " OR
              Y-DAT   NOT EQUAL "         " OR
              Y-ALPHA NOT EQUAL "         "
              DISPLAY "GROUP INITIALIZATION WITH SPACES FAILED"
              PERFORM SHOW-VARS
           END-IF
           MOVE 5 TO LGX
           MOVE 1 TO LGY
           IF W-DATA NOT EQUAL "                                      "
              DISPLAY "GROUP COMPARISON FAILED (W-DATA)"
              PERFORM SHOW-VARS
           END-IF
           IF W-NESTED NOT EQUAL "0          1" OR
              X-GRP    NOT EQUAL W-NESTED       OR
              X-V      NOT EQUAL "     "
              DISPLAY "GROUP COMPARISON FAILED (W-NESTED)"
              PERFORM SHOW-VARS
           END-IF
           MOVE ".........." TO X-DAT
           MOVE "XXXXXXXXXX" TO X-ALPHA
           MOVE "999999999" TO Y-DAT
           MOVE "AAAAAAAAA" TO Y-ALPHA
           IF X-DAT   NOT EQUAL "....." OR
              X-ALPHA NOT EQUAL "XXXXX" OR
              Y-DAT   NOT EQUAL "9" OR
              Y-ALPHA NOT EQUAL "A"
              DISPLAY "MOVES FROM LITERALS FAILED"
              PERFORM SHOW-VARS
           END-IF
           MOVE X-DAT TO Y-DAT
           MOVE Y-ALPHA TO X-ALPHA
           IF X-DAT   NOT EQUAL "....." OR
              X-ALPHA NOT EQUAL "A    " OR
              Y-DAT   NOT EQUAL "." OR
              Y-ALPHA NOT EQUAL "A"
              DISPLAY "MOVES FROM/TO VARS FAILED"
              PERFORM SHOW-VARS
           END-IF
           MOVE "AAAAA" TO X-ALPHA
           MOVE 1 TO LGX
           INITIALIZE X-ALPHA
           MOVE 10 TO LGX
           IF X-ALPHA NOT EQUAL " AAAA     "
              DISPLAY "DIRECT VAR INITIALIZATION FAILED"
              PERFORM SHOW-VARS
           END-IF
           MOVE 1 TO LGX
           COMPUTE W-LEN = LENGTH OF X-DAT
           IF W-LEN NOT EQUAL 10
              DISPLAY "UNEXPECTED RESULT FOR 'LENGTH OF X-DAT': "
                     W-LEN
              PERFORM SHOW-VARS
           END-IF
           COMPUTE W-LEN = FUNCTION LENGTH (X-ALPHA)
           IF W-LEN NOT EQUAL 1
              DISPLAY "UNEXPECTED RESULT FOR 'FUNCTION LENGTH "
                      "(X-ALPHA)': " W-LEN
              PERFORM SHOW-VARS
           END-IF
           MOVE 9 TO LGY
           MOVE ALL "A" TO Y-ALPHA
           MOVE 5 TO LGY
           INITIALIZE Y-ALPHA
           MOVE 9 TO LGY
           IF Y-ALPHA NOT EQUAL "     AAAA"
              DISPLAY "UNEXPECTED RESULT AFTER 'MOVE ALL/INITIALIZE': "
                      Y-ALPHA
              PERFORM SHOW-VARS
           END-IF
           STOP RUN
           .
       SHOW-VARS.
           DISPLAY W-DATA "*"
           DISPLAY X-DAT "*" X-ALPHA "*" Y-DAT "*" Y-ALPHA "*"
           DISPLAY W-NESTED "*"
           DISPLAY X-GRP "*"
           DISPLAY X-V "*"
           .
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [])
AT_CHECK([$COMPILE -fodoslide -o prog-x prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog-x], [0], [])

# under/over shoot

AT_DATA([under.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      under.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       1 X              PICTURE LX(9) DEPENDING ON LGX.
       1 LGX            PIC 9 VALUE 9.
       PROCEDURE        DIVISION.
       MAIN.
           MOVE 0 TO LGX
           DISPLAY X
           STOP RUN
           .
])
AT_CHECK([$COMPILE under.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./under], [1], [],
[libcob: under.cob:11: error: OCCURS DEPENDING ON 'LGX' out of bounds: 0
note: minimum subscript for 'FILLER 1': 1
])
AT_CHECK([$COMPILE -fodoslide -o under-x under.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./under-x], [1], [],
[libcob: under.cob:11: error: OCCURS DEPENDING ON 'LGX' out of bounds: 0
note: minimum subscript for 'FILLER 1': 1
])

AT_DATA([over.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      over.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       1 X              PICTURE LX(5) DEPENDING ON LGX.
       1 LGX            PIC 9 VALUE 9.
       PROCEDURE        DIVISION.
       MAIN.
           DISPLAY X
           STOP RUN
           .
])
AT_CHECK([$COMPILE over.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./over], [1], [],
[libcob: over.cob:10: error: OCCURS DEPENDING ON 'LGX' out of bounds: 9
note: maximum subscript for 'FILLER 1': 5
])
AT_CHECK([$COMPILE -fodoslide -o over-x over.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./over-x], [1], [],
[libcob: over.cob:10: error: OCCURS DEPENDING ON 'LGX' out of bounds: 9
note: maximum subscript for 'FILLER 1': 5
])

# MOVE CORRESPONDING

AT_DATA([corr.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      corr.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       1 W-DATA.
         2 GA.
           3 X          PICTURE X VALUE "X".
           3 YZ         PICTURE XX VALUE "YZ".
           3 X1         PICTURE LX(5) DEPENDING ON LGX.
         2 GB.
           3 X1         PICTURE LX(5) DEPENDING ON LGX.
           3 X          PICTURE X VALUE SPACE.
         2 GC.
           3 X1         PICTURE X(5) VALUE "+++++".
       1 LGX            USAGE COMP-1 VALUE 5.
       1 CNT            USAGE COMP-1.
       PROCEDURE        DIVISION.
       MAIN.
           MOVE "AAAAA" TO X1 OF GA
           MOVE "BBBBB" TO X1 OF GB
           IF X1 OF GA NOT EQUAL "AAAAA" OR
              X1 OF GB NOT EQUAL "BBBBB"
              DISPLAY "GLOBAL INITIALIZATION FAILED"
              PERFORM SHOW-VARS
           END-IF
           MOVE 2 TO LGX
           IF W-DATA NOT EQUAL "XYZAAAAABBBBB +++++"
              DISPLAY "GROUP COMPARISON FAILED"
              DISPLAY GA
              PERFORM SHOW-VARS
           END-IF
      *    From basic to pic-l field: curr size should be ignored
           MOVE CORRESPONDING GC TO GA
           IF X1 OF GA NOT EQUAL "++" OR
              GA       NOT EQUAL "XYZ+++++"
              DISPLAY "MOVE CORRESPONDING GC TO GA: FAILED"
              PERFORM SHOW-VARS
           END-IF
      *    From pic-l to basic field: curr. size is ignored
           MOVE CORRESPONDING GB TO GC
           INSPECT X1 OF GC TALLYING CNT FOR ALL "B"
           IF X1 OF GC NOT EQUAL "BBBBB" OR
              CNT      NOT EQUAL 5
              DISPLAY "MOVE CORRESPONDING GB TO GC: FAILED"
              PERFORM SHOW-VARS
           END-IF
      *    From pic-l to pic-l: sizes are ignored
           MOVE CORRESPONDING GA TO GB
           MOVE 0 TO CNT
           INSPECT X1 OF GB TALLYING CNT FOR ALL "+"
           MOVE 5 TO LGX
           IF X1 OF GB NOT EQUAL "+++++" OR
              X  OF GB NOT EQUAL "X" OR
              CNT      NOT EQUAL 2
              DISPLAY "MOVE CORRESPONDING GA TO GB: FAILED"
              PERFORM SHOW-VARS
           END-IF
           STOP RUN
           .
       SHOW-VARS.
           DISPLAY "LGX: " LGX
           DISPLAY "W-DATA: *" W-DATA "*"
           DISPLAY "CNT: " CNT
           .
])

AT_CHECK([$COMPILE corr.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./corr], [0], [])
AT_CHECK([$COMPILE -fodoslide -o corr-x corr.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./corr-x], [0], [])

# OCCURS ... PIC L  ...

AT_DATA([nested.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      nested.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       1 W-DATA.
         2 A            OCCURS 4
                        PICTURE LX(3) DEPENDING ON LGX.
         2 B            OCCURS 1 TO 10 DEPENDING ON LGY
                        PICTURE LX(3) DEPENDING ON LGX.
       1 LGX            USAGE COMP-1 VALUE 3.
       1 LGY            USAGE COMP-1 VALUE 4.
       PROCEDURE        DIVISION.
       MAIN.
           MOVE "AAAAAAAAAAAABBBBBBBBBBBB" TO W-DATA
           IF W-DATA NOT EQUAL "AAAAAAAAAAAABBBBBBBBBBBB" OR
              A (1)  NOT EQUAL "AAA"
              DISPLAY "GLOBAL INITIALIZATION FAILED"
              DISPLAY A (1)
              PERFORM SHOW-VARS
           END-IF
           MOVE "CCC" TO A (4)
           IF W-DATA NOT EQUAL "AAAAAAAAACCCBBBBBBBBBBBB" OR
              A (4)  NOT EQUAL "CCC"
              DISPLAY "MOVE TO A (4) FAILED"
              DISPLAY A (4)
              PERFORM SHOW-VARS
           END-IF
           MOVE A (3) TO B (2)
           IF W-DATA NOT EQUAL "AAAAAAAAACCCBBBAAABBBBBB" OR
              B (2)  NOT EQUAL "AAA"
              DISPLAY "MOVE A (3) TO B (2) FAILED"
              DISPLAY B (2)
              PERFORM SHOW-VARS
           END-IF
           MOVE 6 TO LGY
           MOVE 2 TO LGX
      *    Operand of 'INITIALIZE' may not have 'OCCURS DEPENDING ON':
      *    INITIALIZE B (5)
           MOVE SPACES TO B (5)
      *    *> NO ODOSLIDE: W-DATA EQUAL "AAAAAAAAACCCBBBAAABBBBBB      "
      *    *>    ODOSLIDE: W-DATA EQUAL "AAAAAAAAACCCBBBAAABB"
           IF A (3)  NOT EQUAL "AA" OR
              A (4)  NOT EQUAL "CC" OR
              B (4)  NOT EQUAL "BB" OR
              B (5)  NOT EQUAL "  "
              DISPLAY "MOVE 2,6 TO LGX,Y; INITIALIZE B (5); FAILED"
              PERFORM SHOW-VARS
           END-IF
           STOP RUN
           .
       SHOW-VARS.
           DISPLAY "W-DATA: *" W-DATA "*"
           DISPLAY "LGX: " LGX
           DISPLAY "LGY: " LGY
           .
])

AT_CHECK([$COMPILE nested.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./nested], [0], [])
AT_CHECK([$COMPILE -fodoslide -o nested-x nested.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./nested-x], [0], [])

# REDEFINES

AT_DATA([redefines.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      redefines.
       DATA             DIVISION.
       WORKING-STORAGE  SECTION.
       1 W-DATA.
          2 UNUSED-1    PIC X VALUE "?".
          2 X-DAT       PICTURE X(10).
          2 Y1-DAT      REDEFINES X-DAT PICTURE LX(5) DEPENDING ON LGY.
          2 Y2-DAT      REDEFINES X-DAT PICTURE LX(5) DEPENDING ON LGY.
          2 UNUSED-2    PIC X VALUE "!".
          2 Z-DAT       PICTURE LX(7) DEPENDING ON LGZ.
          2 T-DAT       REDEFINES Z-DAT PICTURE LX(7) DEPENDING ON LGT.
          2 UNUSED-3    PIC X VALUE ".".
       1 W-LGS.
          2 LGX         PIC 99 VALUE 10.
          2 LGY         PIC 9 VALUE 5.
          2 LGZ         PIC 9 VALUE 7.
          2 LGT         PIC 9 VALUE 5.
       PROCEDURE        DIVISION.
       MAIN.
           MOVE "......." TO Z-DAT
           MOVE 3 TO LGZ
           MOVE "0123456789" TO X-DAT
           IF Y1-DAT NOT EQUAL "01234" OR
              Y2-DAT NOT EQUAL "01234"
              DISPLAY "INITIAL MOVE FAILED"
              PERFORM SHOW-VARS
           END-IF
           MOVE "0123456" TO Z-DAT.
           IF T-DAT NOT EQUAL "012.." OR
              Z-DAT NOT EQUAL "012"
              DISPLAY "SECOND MOVE FAILED"
              PERFORM SHOW-VARS
           END-IF
      *    Initialize group containing PICTURE L field: curr. size should be ignored
           MOVE 1 TO LGZ
           INITIALIZE W-DATA
           MOVE 7 TO LGT
           IF T-DAT NOT EQUAL "       "
              DISPLAY "UNEXPECTED T-DAT AFTER 'INITIALIZE W-DATA': "
                       T-DAT
              PERFORM SHOW-VARS
           END-IF
      *    Initialize PICTURE L field: curr. size is ignored
           MOVE "???????" TO T-DAT
           INITIALIZE Z-DAT
           MOVE 2 TO LGZ
           IF T-DAT NOT EQUAL " ??????" OR
              Z-DAT NOT EQUAL " ?"
              DISPLAY "UNEXPECTED T-DAT/Z-DAT AFTER "
                       "'INITIALIZE Z-DAT': " T-DAT "/" Z-DAT "*"
              PERFORM SHOW-VARS
           END-IF
           STOP RUN
           .
       SHOW-VARS.
           DISPLAY X-DAT "*" Y1-DAT "*" Y2-DAT "*" T-DAT "*" Z-DAT "*"
           .
])

AT_CHECK([$COMPILE redefines.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./redefines], [0], [])
AT_CHECK([$COMPILE -fodoslide -o redefines-x redefines.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./redefines-x], [0], [])

AT_CLEANUP
